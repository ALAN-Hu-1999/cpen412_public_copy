680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 07 Apr 2022      Time: 22:40:36          Source: C:\M68KV6.0 - 800BY480\ASSIGNMENT6\PARTB_PROJ\PARTB.SRC

                       1          section   code
                       2   ;********************************************************************************************************
                       3   ;                                               uC/OS-II
                       4   ;                                         The Real-Time Kernel
                       5   ;
                       6   ;                            (c) Copyright 1999, Jean J. Labrosse, Weston, FL
                       7   ;                                          All Rights Reserved
                       8   ;
                       9   ;
                      10   ;                                        IDE68K Specific boot code
                      11   ;
                      12   ;
                      13   ; File         : OS_BOOT.ASM
                      14   ; By           : PJ Davies to suit DE1 board
                      15   ;********************************************************************************************************
                      16   
                      17   ;********************************************************************************************************
                      18   ;                                               NOTES
                      19   ;
                      20   ; This is the "Board Support Package" or BSP for the DE1 board  It defines memory layout,
                      21   ; interrupt vectors and a few BIOS functions.
                      22   ;
                      23   ;********************************************************************************************************
                      24   
                      25   ;********************************************************************************************************
                      26   ;                                           REVISION HISTORY
                      27   ;
                      28   ; $Log$
                      29   ;
                      30   ;********************************************************************************************************
                      31   
          0000 0000   32   ROM        equ         $00000000       ; ROM starts at $00000000
          0800 0000   33   RAM        equ         $08000000       ; RAM starts at $08000000
          0001 0000   34   RAMsize    equ         $00010000       ; Size of RAM 64kbytes
                      35   
                      36   ;           option      S0              ; Generate S0 record in .hex file since Rom is at location 0
                      37   
00000000              38              org         ROM				; starting at location 0, generate the following constants
          0000 0000   39   begin_ROM  equ         *				; beginning of rom constant is 0
          0000 0000   40   code       equ         *				; code starts at 0
                      41   
                      42   
                      43   ;*******************************************************************************************************************
                      44   ; start of 68000 vector table (256 long word entries covering reset, interrupts, initial stack pointer etc)
                      45   ;*******************************************************************************************************************
                      46   
00000000  0801 0000   47   InitialSP       dc.l __stack          ;initial supervisor state stack pointer(stack decrements first before being used
00000004  0000 0400   48   InitialPC       dc.l startup             ;address of 1st instruction of program after a reset
00000008  0000 05D2   49   BusError        dc.l E_BErro           ;bus error - stop program
0000000C  0000 05E4   50   AddressError    dc.l E_AErro           ;address error - stop program
00000010  0000 05F6   51   IllegalInstr    dc.l E_IInst           ;illegal instruction - stop program
00000014  0000 0608   52   DividebyZero    dc.l E_DZero           ;divide by zero error - stop program
00000018  0000 061A   53   Check           dc.l E_Check           ;Check instruction - stop program
0000001C  0000 062C   54   TrapV           dc.l E_Trapv           ;Trapv instruction - stop program
00000020  0000 063E   55   Privilege       dc.l E_Priv            ;privilige violation - stop program
00000024  0000 0650   56   Trace           dc.l E_Trace           ;stop on trace
00000028  0000 0662   57   Line1010emul    dc.l E_1010            ;1010 instructions stop
0000002C  0000 0674   58   Line1111emul    dc.l E_1111            ;1111 instructions stop
00000030  0000 0686   59   Unassigned1     dc.l E_Unnas1           ;unassigned vector
00000034  0000 0686   60   Unassigned2     dc.l E_Unnas2           ;unassigned vector
00000038  0000 0686   61   Unassigned3     dc.l E_Unnas3           ;unassigned vector
0000003C  0000 0686   62   Uninit_IRQ      dc.l E_UnitI           ;uninitialised interrupt
00000040  0000 0686   63   Unassigned4     dc.l E_Unnas4           ;unassigned vector
00000044  0000 0686   64   Unassigned5     dc.l E_Unnas5           ;unassigned vector
00000048  0000 0686   65   Unassigned6     dc.l E_Unnas6           ;unassigned vector
0000004C  0000 0686   66   Unassigned7     dc.l E_Unnas7           ;unassigned vector
00000050  0000 0686   67   Unassigned8     dc.l E_Unnas8           ;unassigned vector
00000054  0000 0686   68   Unassigned9     dc.l E_Unnas9           ;unassigned vector
00000058  0000 0686   69   Unassigned10    dc.l E_Unnas10           ;unassigned vector
0000005C  0000 0686   70   Unassigned11    dc.l E_Unnas11           ;unassigned vector
00000060  0000 0686   71   SpuriousIRQ     dc.l E_Spuri           ;stop on spurious irq
                      72   *
                      73   *
00000064  0000 0434   74   Level1IRQ       dc.l Level1RamISR
00000068  0000 0446   75   Level2IRQ       dc.l Level2RamISR
0000006C  0000 07BE   76   Level3IRQ       dc.l _OSTickISR        ;Level3RamISR (Timer Tick) - ISR needs to be installed at run time for DE1 timer
00000070  0000 046A   77   Level4IRQ       dc.l Level4RamISR
00000074  0000 047C   78   Level5IRQ       dc.l Level5RamISR
00000078  0000 048E   79   Level6IRQ       dc.l Level6RamISR
0000007C  0000 04A0   80   Level7IRQ       dc.l Level7RamISR
                      81   *
                      82   *
00000080  0000 06B2   83   Trap0           dc.l _OSCtxSw           ; User installed trap handler (Context Switch) - invoked by a trap0 instruction contained in os_cpu.h file
00000084  0000 04C4   84   Trap1           dc.l Trap1RamISR        ; User installed trap handler
00000088  0000 04D6   85   Trap2           dc.l Trap2RamISR        ; User installed trap handler
0000008C  0000 04E8   86   Trap3           dc.l Trap3RamISR        ; User installed trap handler
00000090  0000 04FA   87   Trap4           dc.l Trap4RamISR        ; User installed trap handler
00000094  0000 050C   88   Trap5           dc.l Trap5RamISR        ; User installed trap handler
00000098  0000 051E   89   Trap6           dc.l Trap6RamISR        ; User installed trap handler
0000009C  0000 0530   90   Trap7           dc.l Trap7RamISR        ; User installed trap handler
000000A0  0000 0542   91   Trap8           dc.l Trap8RamISR        ; User installed trap handler
000000A4  0000 0554   92   Trap9           dc.l Trap9RamISR        ; User installed trap handler
000000A8  0000 0566   93   Trap10          dc.l Trap10RamISR       ; User installed trap handler
000000AC  0000 0578   94   Trap11          dc.l Trap11RamISR       ; User installed trap handler
000000B0  0000 058A   95   Trap12          dc.l Trap12RamISR       ; User installed trap handler
000000B4  0000 059C   96   Trap13          dc.l Trap13RamISR       ; User installed trap handler
000000B8  0000 05AE   97   Trap14          dc.l Trap14RamISR       ; User installed trap handler
000000BC  0000 05C0   98   Trap15          dc.l Trap15RamISR       ; User installed trap handler (System call - but a legacy from running on IDE68k simulator)
                      99   
                     100   
                     101   *
                     102   * Other vectors 64-255 are users vectors for autovectored IO device (not implemented in TG68)
                     103   *
                     104   
00000400             105                   org       $00000400    ; end of vector table/start of code
                     106   
                     107              ; this is where the program code initially begins (see table avove vector #1 - initial Program counter value is defined as "startup"
                     108              ; here we can write some boot code and carry out some memory/constant initialisation
                     109              ; add your own code here or you can do it later in C (try to keep assembler code to a minimum)
                     110   startup:
00000400  41F9 0800  111              lea         bss,A0			; put start address of unitialised variables into register A0
00000404  0008      
00000406  4218       112              clr.b       (A0)+           ; set bss section (unitialised variables) to zero (clear the byte pointed to by A0 and then increment A0)
00000408  B1FC 0800  113              cmp.l       #heap,A0			; compare A0 with immediate value defined by heap
0000040C  1B12      
0000040E  65F6       114              bcs.s       *-8				; if not there yet go back 8 bytes to clr.b instruction
00000410  23FC FFFF  115              move.l      #-1,__ungetbuf  ; initialose ungetbuffer for keyboard input (don't remove this otherwise scanf() etc will not work)
00000414  FFFF 0800 
00000418  00C8      
                     116              ;
0000041A  23FC 0000  117              move.l      #(end_ROM-begin_ROM),__romsize	; initialise some values related to rom and ram limits (needed by OS)
0000041E  7504 0800 
00000422  00D4      
00000424  23FC 0000  118              move.l      #(end_RAM-begin_RAM),__ramsize
00000428  1B12 0800 
0000042C  00D8      
0000042E  4EB9 0000  119              jsr         _main							; now call main() from our C program (yeah!!!!)
00000432  5BCE      
                     120   
                     121   *********************************************************************************************************
                     122   * Code to call Ram Based Interrupt handler and other exeception handler code
                     123   *********************************************************************************************************
00000434  48E7 FFFE  124   Level1RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000438  2079 0800  125                   move.l    VL1IRQ,a0               get ram based address into a0
0000043C  006C      
0000043E  4E90       126                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000440  4CDF 7FFF  127                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000444  4E73       128                   rte
00000446  48E7 FFFE  129   Level2RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000044A  2079 0800  130                   move.l    VL2IRQ,a0               get ram based address into a0
0000044E  0070      
00000450  4E90       131                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000452  4CDF 7FFF  132                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000456  4E73       133                   rte
00000458  48E7 FFFE  134   Level3RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000045C  2079 0800  135                   move.l    VL3IRQ,a0               get ram based address into a0
00000460  0074      
00000462  4E90       136                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000464  4CDF 7FFF  137                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000468  4E73       138                   rte
0000046A  48E7 FFFE  139   Level4RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000046E  2079 0800  140                   move.l    VL4IRQ,a0               get ram based address into a0
00000472  0078      
00000474  4E90       141                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000476  4CDF 7FFF  142                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000047A  4E73       143                   rte
                     144   
0000047C  48E7 FFFE  145   Level5RamISR    movem.l   d0-d7/a0-a6,-(SP)        save everything not automatically saved
00000480  2079 0800  146                   move.l    VL5IRQ,a0               get ram based address into a0
00000484  007C      
00000486  4E90       147                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000488  4CDF 7FFF  148                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000048C  4E73       149                   rte
                     150   
0000048E  48E7 FFFE  151   Level6RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000492  2079 0800  152                   move.l    VL6IRQ,a0               get ram based address into a0
00000496  0080      
00000498  4E90       153                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
0000049A  4CDF 7FFF  154                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000049E  4E73       155                   rte
                     156   
000004A0  48E7 FFFE  157   Level7RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004A4  2079 0800  158                   move.l    VL7IRQ,a0               get ram based address into a0
000004A8  0084      
000004AA  4E90       159                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004AC  4CDF 7FFF  160                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004B0  4E73       161                   rte
                     162   
                     163   
                     164   ********************************************************************************************************
                     165   * Ram based Trap handler and other exeception handler code
                     166   *********************************************************************************************************
                     167   
000004B2  48E7 FFFE  168   Trap0RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004B6  2079 0800  169                   move.l    VTrap0,a0                get ram based address into a0
000004BA  0088      
000004BC  4E90       170                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004BE  4CDF 7FFF  171                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004C2  4E73       172                   rte
                     173   
000004C4  48E7 FFFE  174   Trap1RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004C8  2079 0800  175                   move.l    VTrap1,a0                get ram based address into a0
000004CC  008C      
000004CE  4E90       176                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004D0  4CDF 7FFF  177                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004D4  4E73       178                   rte
                     179   
000004D6  48E7 FFFE  180   Trap2RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004DA  2079 0800  181                   move.l    VTrap2,a0                get ram based address into a0
000004DE  0090      
000004E0  4E90       182                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004E2  4CDF 7FFF  183                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004E6  4E73       184                   rte
                     185   
000004E8  48E7 FFFE  186   Trap3RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004EC  2079 0800  187                   move.l    VTrap3,a0                get ram based address into a0
000004F0  0094      
000004F2  4E90       188                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004F4  4CDF 7FFF  189                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004F8  4E73       190                   rte
                     191   
000004FA  48E7 FFFE  192   Trap4RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004FE  2079 0800  193                   move.l    VTrap4,a0                get ram based address into a0
00000502  0098      
00000504  4E90       194                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000506  4CDF 7FFF  195                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000050A  4E73       196                   rte
                     197   
0000050C  48E7 FFFE  198   Trap5RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000510  2079 0800  199                   move.l    VTrap5,a0                get ram based address into a0
00000514  009C      
00000516  4E90       200                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000518  4CDF 7FFF  201                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000051C  4E73       202                   rte
                     203   
0000051E  48E7 FFFE  204   Trap6RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000522  2079 0800  205                   move.l    VTrap6,a0                get ram based address into a0
00000526  00A0      
00000528  4E90       206                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000052A  4CDF 7FFF  207                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000052E  4E73       208                   rte
                     209   
00000530  48E7 FFFE  210   Trap7RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000534  2079 0800  211                   move.l    VTrap7,a0                get ram based address into a0
00000538  00A4      
0000053A  4E90       212                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000053C  4CDF 7FFF  213                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000540  4E73       214                   rte
                     215   
00000542  48E7 FFFE  216   Trap8RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000546  2079 0800  217                   move.l    VTrap8,a0                get ram based address into a0
0000054A  00A8      
0000054C  4E90       218                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000054E  4CDF 7FFF  219                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000552  4E73       220                   rte
                     221   
00000554  48E7 FFFE  222   Trap9RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000558  2079 0800  223                   move.l    VTrap9,a0                get ram based address into a0
0000055C  00AC      
0000055E  4E90       224                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000560  4CDF 7FFF  225                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000564  4E73       226                   rte
                     227   
00000566  48E7 FFFE  228   Trap10RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000056A  2079 0800  229                   move.l    VTrap10,a0                get ram based address into a0
0000056E  00B0      
00000570  4E90       230                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000572  4CDF 7FFF  231                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000576  4E73       232                   rte
                     233   
00000578  48E7 FFFE  234   Trap11RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000057C  2079 0800  235                   move.l    VTrap11,a0                get ram based address into a0
00000580  00B4      
00000582  4E90       236                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000584  4CDF 7FFF  237                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000588  4E73       238                   rte
                     239   
0000058A  48E7 FFFE  240   Trap12RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000058E  2079 0800  241                   move.l    VTrap12,a0                get ram based address into a0
00000592  00B8      
00000594  4E90       242                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000596  4CDF 7FFF  243                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000059A  4E73       244                   rte
                     245   
0000059C  48E7 FFFE  246   Trap13RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005A0  2079 0800  247                   move.l    VTrap13,a0                get ram based address into a0
000005A4  00BC      
000005A6  4E90       248                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005A8  4CDF 7FFF  249                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005AC  4E73       250                   rte
                     251   
000005AE  48E7 FFFE  252   Trap14RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005B2  2079 0800  253                   move.l    VTrap14,a0              get ram based address into a0
000005B6  00C0      
000005B8  4E90       254                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005BA  4CDF 7FFF  255                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005BE  4E73       256                   rte
                     257   
000005C0  48E7 FFFE  258   Trap15RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005C4  2079 0800  259                   move.l    VTrap15,a0              get ram based address into a0
000005C8  00C4      
000005CA  4E90       260                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005CC  4CDF 7FFF  261                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005D0  4E73       262                   rte
                     263   
                     264   *********************************************************************************************************
                     265   *Default exception handler for everything without a specific handler
                     266   *********************************************************************************************************
                     267   
000005D2  48E7 FFFE  268   E_BErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005D6  2079 0800  269                   move.l    VBusError,a0            get ram based address into a0
000005DA  0010      
000005DC  4E90       270                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005DE  4CDF 7FFF  271                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005E2  4E73       272                   rte
000005E4  48E7 FFFE  273   E_AErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005E8  2079 0800  274                   move.l    VAddressError,a0        get ram based address into a0
000005EC  0014      
000005EE  4E90       275                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005F0  4CDF 7FFF  276                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005F4  4E73       277                   rte
000005F6  48E7 FFFE  278   E_IInst         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005FA  2079 0800  279                   move.l    VIllegalInstr,a0        get ram based address into a0
000005FE  0018      
00000600  4E90       280                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000602  4CDF 7FFF  281                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000606  4E73       282                   rte
00000608  48E7 FFFE  283   E_DZero         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000060C  2079 0800  284                   move.l    VDividebyZero,a0        get ram based address into a0
00000610  001C      
00000612  4E90       285                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000614  4CDF 7FFF  286                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000618  4E73       287                   rte
0000061A  48E7 FFFE  288   E_Check         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000061E  2079 0800  289                   move.l    VCheck,a0               get ram based address into a0
00000622  0020      
00000624  4E90       290                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000626  4CDF 7FFF  291                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000062A  4E73       292                   rte
0000062C  48E7 FFFE  293   E_Trapv         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000630  2079 0800  294                   move.l    VTrapV,a0               get ram based address into a0
00000634  0024      
00000636  4E90       295                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000638  4CDF 7FFF  296                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000063C  4E73       297                   rte
0000063E  48E7 FFFE  298   E_Priv          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000642  2079 0800  299                   move.l    VPrivilege,a0           get ram based address into a0
00000646  0028      
00000648  4E90       300                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000064A  4CDF 7FFF  301                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000064E  4E73       302                   rte
00000650  48E7 FFFE  303   E_Trace         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000654  2079 0800  304                   move.l    VTrace,a0               get ram based address into a0
00000658  002C      
0000065A  4E90       305                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000065C  4CDF 7FFF  306                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000660  4E73       307                   rte
00000662  48E7 FFFE  308   E_1010          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000666  2079 0800  309                   move.l    VLine1010emul,a0        get ram based address into a0
0000066A  0030      
0000066C  4E90       310                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000066E  4CDF 7FFF  311                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000672  4E73       312                   rte
00000674  48E7 FFFE  313   E_1111          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000678  2079 0800  314                   move.l    VLine1111emul,a0        get ram based address into a0
0000067C  0034      
0000067E  4E90       315                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000680  4CDF 7FFF  316                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000684  4E73       317                   rte
                     318   
                     319   ; at the moment all these exceptions cause the processor to stop (or at least loop) with no further application processing
                     320   E_Unnas1
                     321   E_Unnas2
                     322   E_Unnas3
                     323   E_UnitI
                     324   E_Unnas4
                     325   E_Unnas5
                     326   E_Unnas6
                     327   E_Unnas7
                     328   E_Unnas8
                     329   E_Unnas9
                     330   E_Unnas10
                     331   E_Unnas11
                     332   E_Spuri
00000686  60FE       333   _stop            bra _stop             ; stop
                     334   
                     335   __exit:                                ; exit() and _exit()functions
                     336   
00000688  6000 FD76  337              bra         startup         ; restart program if exit() called
                     338   
                     339   ; I don't think these two time related functions are relevant anymore and neither is Trap 15 handler
                     340   ; but they are left in for the moment until I am certain they can be removed
                     341   __time:
0000068C  4E4F       342              trap        #15             ; IDE68K system call 40 -> GETTIME
0000068E  0028       343              dc.w        40              ; D0 = seconds since Jan 1, 1970, 00:00:00 hr UTC
00000690  4E75       344              rts
                     345   
                     346   __localoffset:
00000692  4E4F       347              trap        #15             ; IDE68K system call 41 -> LOCALOFFSET
00000694  0029       348              dc.w        41              ; D0 = offset in seconds between UTC and local time
00000696  4E75       349              rts
                     350   
                     351   ;********************************************************************************************************
                     352   ;                                               uC/OS-II
                     353   ;                                         The Real-Time Kernel
                     354   ;
                     355   ;                            (c) Copyright 1999, Jean J. Labrosse, Weston, FL
                     356   ;                                          All Rights Reserved
                     357   ;
                     358   ;
                     359   ;                                     68000 Specific assembly code
                     360   ;                                               IDE68K
                     361   ;
                     362   ; File         : OS_CPU_A.ASM
                     363   ; By           : Jean J. Labrosse, Peter J. Fondse
                     364   ;********************************************************************************************************
                     365   
                     366   
                     367   ;********************************************************************************************************
                     368   ;                                            REVISION HISTORY
                     369   ;
                     370   ; $Log$
                     371   ;
                     372   ;********************************************************************************************************
                     373   
                     374   
                     375   ;********************************************************************************************************
                     376   ;                                          PUBLIC DECLARATIONS
                     377   ;********************************************************************************************************
                     378   
                     379   
                     380   ;********************************************************************************************************
                     381   ;                                         EXTERNAL DECLARATIONS
                     382   ;********************************************************************************************************
                     383   
                     384   
                     385   ;********************************************************************************************************
                     386   ;                               START HIGHEST PRIORITY TASK READY-TO-RUN
                     387   ;
                     388   ; Description : This function is called by OSStart() to start the highest priority task that was created
                     389   ;               by your application before calling OSStart().
                     390   ;
                     391   ; Arguments   : none
                     392   ;
                     393   ; Note(s)     : 1) The stack frame is assumed to look as follows:
                     394   ;
                     395   ;                  OSTCBHighRdy->OSTCBStkPtr +  0  ---->  D0    (H)        Low Memory
                     396   ;                                            +  2         D0    (L)
                     397   ;                                            +  4         D1    (H)
                     398   ;                                            +  6         D1    (L)
                     399   ;                                            +  8         D2    (H)
                     400   ;                                            + 10         D2    (L)
                     401   ;                                            + 12         D3    (H)
                     402   ;                                            + 14         D3    (L)
                     403   ;                                            + 16         D4    (H)
                     404   ;                                            + 18         D4    (L)
                     405   ;                                            + 20         D5    (H)
                     406   ;                                            + 22         D5    (L)
                     407   ;                                            + 24         D6    (H)
                     408   ;                                            + 26         D6    (L)
                     409   ;                                            + 28         D7    (H)
                     410   ;                                            + 30         D7    (L)
                     411   ;                                            + 32         A0    (H)
                     412   ;                                            + 34         A0    (L)
                     413   ;                                            + 36         A1    (H)
                     414   ;                                            + 38         A1    (L)
                     415   ;                                            + 40         A2    (H)
                     416   ;                                            + 42         A2    (L)
                     417   ;                                            + 44         A3    (H)
                     418   ;                                            + 46         A3    (L)
                     419   ;                                            + 48         A4    (H)
                     420   ;                                            + 50         A4    (L)
                     421   ;                                            + 52         A5    (H)
                     422   ;                                            + 54         A5    (L)
                     423   ;                                            + 56         A6    (H)
                     424   ;                                            + 58         A6    (L)
                     425   ;                                            + 60         OS_INITIAL_SR
                     426   ;                                            + 62         task  (H)
                     427   ;                                            + 64         task  (L)
                     428   ;                                            + 66         task  (H)
                     429   ;                                            + 68         task  (L)
                     430   ;                                            + 70         pdata (H)
                     431   ;                                            + 72         pdata (L)        High Memory
                     432   ;
                     433   ;               2) OSStartHighRdy() MUST:
                     434   ;                      a) Call OSTaskSwHook() then,
                     435   ;                      b) Set OSRunning to TRUE,
                     436   ;                      c) Switch to the highest priority task.
                     437   ;********************************************************************************************************
                     438   
                     439   ; Pseudocode for OSStartHighRdy:
                     440   ;          Call OSTaskSwHook();
                     441   ;          Set OSRunning to 1;
                     442   ;          Load the processor stack pointer with OSTCBHighRdy->OSTCBStkPtr;
                     443   ;          POP all the processor registers from the stack;
                     444   ;          Execute a Return from Interrupt instruction;
                     445   
                     446   
                     447   _OSStartHighRdy:
00000698  4EB9 0000  448           jsr       _OSTaskSwHook            ; Invoke user defined context switch hook
0000069C  08CE      
0000069E  5239 0800  449           addq.b    #1,_OSRunning            ; Indicate that we are multitasking
000006A2  0320      
000006A4  2079 0800  450           move.l    _OSTCBHighRdy,A0         ; Point to TCB of highest priority task ready to run
000006A8  0430      
000006AA  2E50       451           move.l    (A0),A7                  ; Get the stack pointer of the task to resume
000006AC  4CDF 7FFF  452           movem.l   (A7)+,A0-A6/D0-D7        ; Restore the CPU registers
000006B0  4E73       453           rte                                ; Run task
                     454   
                     455   ;********************************************************************************************************
                     456   ;                                       TASK LEVEL CONTEXT SWITCH
                     457   ;
                     458   ; Description : This function is called when a task makes a higher priority task ready-to-run.
                     459   ;               Called with TRAP #0 instruction (see vector table entry at address 0x0080 in boot.asm)
                     460   ;
                     461   ; Arguments   : none
                     462   ;
                     463   ; Note(s)     : 1) Upon entry,
                     464   ;                  OSTCBCur     points to the OS_TCB of the task to suspend
                     465   ;                  OSTCBHighRdy points to the OS_TCB of the task to resume
                     466   ;
                     467   ;               2) The stack frame of the task to suspend looks as follows (the registers for
                     468   ;                  task to suspend need to be saved):
                     469   ;
                     470   ;                                         SP +  0  ---->  SR                   Low Memory
                     471   ;                                            +  2         PC of task  (H)
                     472   ;                                            +  4         PC of task  (L)      High Memory
                     473   ;
                     474   ;               3) The stack frame of the task to resume looks as follows:
                     475   ;
                     476   ;                  OSTCBHighRdy->OSTCBStkPtr +  0  ---->  D0    (H)           Low Memory
                     477   ;                                            +  2         D0    (L)
                     478   ;                                            +  4         D1    (H)
                     479   ;                                            +  6         D1    (L)
                     480   ;                                            +  8         D2    (H)
                     481   ;                                            + 10         D2    (L)
                     482   ;                                            + 12         D3    (H)
                     483   ;                                            + 14         D3    (L)
                     484   ;                                            + 16         D4    (H)
                     485   ;                                            + 18         D4    (L)
                     486   ;                                            + 20         D5    (H)
                     487   ;                                            + 22         D5    (L)
                     488   ;                                            + 24         D6    (H)
                     489   ;                                            + 26         D6    (L)
                     490   ;                                            + 28         D7    (H)
                     491   ;                                            + 30         D7    (L)
                     492   ;                                            + 32         A0    (H)
                     493   ;                                            + 34         A0    (L)
                     494   ;                                            + 36         A1    (H)
                     495   ;                                            + 38         A1    (L)
                     496   ;                                            + 40         A2    (H)
                     497   ;                                            + 42         A2    (L)
                     498   ;                                            + 44         A3    (H)
                     499   ;                                            + 46         A3    (L)
                     500   ;                                            + 48         A4    (H)
                     501   ;                                            + 50         A4    (L)
                     502   ;                                            + 52         A5    (H)
                     503   ;                                            + 54         A5    (L)
                     504   ;                                            + 56         A6    (H)
                     505   ;                                            + 58         A6    (L)
                     506   ;                                            + 60         OS_INITIAL_SR       (See OS_CPU.H)
                     507   ;                                            + 62         PC of task  (H)
                     508   ;                                            + 64         PC of task  (L)     High Memory
                     509   ;********************************************************************************************************
                     510   
                     511   ; Pseudocode for OSCtxSw:
                     512   ; OSCtxSw:
                     513   ; PUSH processor registers onto the current task’s stack;
                     514   ; Save the stack pointer at OSTCBCur->OSTCBStkPtr;
                     515   ; Call OSTaskSwHook(); (1)
                     516   ; OSTCBCur = OSTCBHighRdy;
                     517   ; OSPrioCur = OSPrioHighRdy; (2)
                     518   ; Load the processor stack pointer with OSTCBHighRdy->OSTCBStkPtr;
                     519   ; POP all the processor registers from the stack;
                     520   ; Execute a Return from Interrupt instruction;
                     521   
                     522   _OSCtxSw:
000006B2  48E7 FFFE  523           movem.l   A0-A6/D0-D7,-(A7)              ; Save the registers of the current task
000006B6  2079 0800  524           move.l    _OSTCBCur,A0                   ; Save the stack pointer in the suspended task TCB
000006BA  0428      
000006BC  208F       525           move.l    A7,(A0)
000006BE  4EB9 0000  526           jsr       _OSTaskSwHook                  ; Invoke user defined context switch hook
000006C2  08CE      
000006C4  13F9 0800  527           move.b    _OSPrioHighRdy,_OSPrioCur      ; OSPrioCur = OSPrioHighRdy
000006C8  0314 0800 
000006CC  0312      
000006CE  2079 0800  528           move.l    _OSTCBHighRdy,A0               ; OSTCBCur  = OSTCBHighRdy
000006D2  0430      
000006D4  23C8 0800  529           move.l    A0,_OSTCBCur
000006D8  0428      
000006DA  2E50       530           move.l    (A0),A7                        ; Get the stack pointer of the task to resume
000006DC  4CDF 7FFF  531           movem.l   (A7)+,A0-A6/D0-D7              ; Restore the CPU registers
000006E0  4E73       532           rte                                      ; Run task
                     533   
                     534   ;********************************************************************************************************
                     535   ;                                      INTERRUPT LEVEL CONTEXT SWITCH
                     536   ;
                     537   ; Description : This function is called from OSIntExit() in OS_CORE.C
                     538   ;               Provided for backward compatibility.
                     539   ;               The ISR MUST NOT call OSIntExit(), but should jump to OSIntExit68K().
                     540   ;********************************************************************************************************
                     541   
                     542   ; Pseudocode for OSIntCtxSw
                     543   ; OSIntCtxSw
                     544   ;          Save the stack pointer at OSTCBCur->OSTCBStkPtr;
                     545   ;          Call OSTaskSwHook(); (1)
                     546   ;          OSTCBCur = OSTCBHighRdy;
                     547   ;          OSPrioCur = OSPrioHighRdy; (2)
                     548   ;          Load the processor stack pointer with OSTCBHighRdy->OSTCBStkPtr;
                     549   ;          POP all the processor registers from the stack;
                     550   ;          Execute a Return from Interrupt instruction;
                     551   
                     552   _OSIntCtxSw:
000006E2  DFFC 0000  553           adda.l    #10,A7                         ; Adjust the stack (note this code is called as a subroutine by OS so extra copy of PC stored on stack - along with PC and SR - so adjust by 10 bytes to point to A6)
000006E6  000A      
000006E8  2279 0800  554           move.l    _OSTCBCur,A1                   ; Save the stack pointer in the suspended task TCB
000006EC  0428      
000006EE  228F       555           move.l    A7,(A1)
                     556   ;
000006F0  4EB9 0000  557           jsr       _OSTaskSwHook                  ; Invoke user defined context switch hook
000006F4  08CE      
                     558   ;
000006F6  2279 0800  559           move.l    _OSTCBHighRdy,A1               ; OSTCBCur  = OSTCBHighRdy
000006FA  0430      
000006FC  23C9 0800  560           move.l    A1,_OSTCBCur
00000700  0428      
00000702  2E51       561           move.l    (A1),A7                        ; Get the stack pointer of the task to resume
                     562   ;
00000704  13F9 0800  563           move.b    _OSPrioHighRdy,_OSPrioCur      ; OSPrioCur = OSPrioHighRdy
00000708  0314 0800 
0000070C  0312      
0000070E  4CDF 7FFF  564           movem.l   (A7)+,A0-A6/D0-D7              ; Restore the CPU registers
00000712  4E73       565           rte                                      ; Run task
                     566   
                     567   ;********************************************************************************************************
                     568   ;                           INTERRUPT EXIT FUNCTION (IDE68K specific)
                     569   ;
                     570   ; Description : ISR's (written in Assembly) must directly JUMP to OSIntExit68K
                     571   ;
                     572   ; Notes       : You must NOT call OSIntExit() to exit an ISR with IDE68K, but JUMP to OSIntExit68K().
                     573   ;
                     574   ; Stack frame upon entry:
                     575   ;
                     576   ;                  SP +  0  ---->  D0    (H)
                     577   ;                     +  2         D0    (L)
                     578   ;                     +  4         D1    (H)
                     579   ;                     +  6         D1    (L)
                     580   ;                     +  8         D2    (H)
                     581   ;                     + 10         D2    (L)
                     582   ;                     + 12         D3    (H)
                     583   ;                     + 14         D3    (L)
                     584   ;                     + 16         D4    (H)
                     585   ;                     + 18         D4    (L)
                     586   ;                     + 20         D5    (H)
                     587   ;                     + 22         D5    (L)
                     588   ;                     + 24         D6    (H)
                     589   ;                     + 26         D6    (L)
                     590   ;                     + 28         D7    (H)
                     591   ;                     + 30         D7    (L)
                     592   ;                     + 32         A0    (H)
                     593   ;                     + 34         A0    (L)
                     594   ;                     + 36         A1    (H)
                     595   ;                     + 38         A1    (L)
                     596   ;                     + 40         A2    (H)
                     597   ;                     + 42         A2    (L)
                     598   ;                     + 44         A3    (H)
                     599   ;                     + 46         A3    (L)
                     600   ;                     + 48         A4    (H)
                     601   ;                     + 50         A4    (L)
                     602   ;                     + 52         A5    (H)
                     603   ;                     + 54         A5    (L)
                     604   ;                     + 56         A6    (H)
                     605   ;                     + 58         A6    (L)
                     606   ;                     + 60         Task or ISR's SR
                     607   ;                     + 62         PC of task  (H)
                     608   ;                     + 64         PC of task  (L)                   High Memory
                     609   ;********************************************************************************************************
                     610   
                     611   ; C Code for OSInterrupt exit taken from test book on OS example program 3.16 page 96/305
                     612   
                     613   ; void OSIntExit (void)
                     614   ; {
                     615   ;           OS_ENTER_CRITICAL();
                     616   ;           if ((--OSIntNesting | OSLockNesting) == 0) {
                     617   ;                       OSIntExitY = OSUnMapTbl[OSRdyGrp];
                     618   ;                       OSPrioHighRdy = (INT8U)((OSIntExitY << 3) + OSUnMapTbl[OSRdyTbl[OSIntExitY]]);
                     619   ;                       if (OSPrioHighRdy != OSPrioCur) {
                     620   ;                                       OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
                     621   ;                                       OSCtxSwCtr++;
                     622   ;                                       OSIntCtxSw();
                     623   ;                       }
                     624   ;           }
                     625   ;           OS_EXIT_CRITICAL();
                     626   ; }
                     627   
                     628   OSIntExit68K:
00000714  5339 0800  629           subq.b    #1,_OSIntNesting              ; if (--OSIntNesting == 0)
00000718  030E      
0000071A  6600 009C  630           bne       OSIntExit68K_1
0000071E  4A39 0800  631           tst.b     _OSLockNesting                ; if (OSLockNesting == 0)
00000722  0310      
00000724  6600 0092  632           bne       OSIntExit68K_1
                     633   
                     634   ;       re-enabling interrupts
00000728  302F 003C  635           move.w    (60,A7),D0                    ; must be LAST nested ISR
0000072C  C07C 0700  636           and.w     #$0700,D0                     ; do we want to change S bit in SR
                     637   ;
00000730  6600 0086  638           bne       OSIntExit68K_1
00000734  41F9 0000  639           lea       _OSUnMapTbl,A0                ;  y = OSUnMapTbl[OSRdyGrp];
00000738  70DE      
0000073A  4280       640           clr.l     D0
0000073C  1039 0800  641           move.b    _OSRdyGrp,D0
00000740  0316      
00000742  1230 0800  642           move.b    0(A0,D0.L),D1                 ;  y in D1
                     643   ;
00000746  41F9 0800  644           lea       _OSRdyTbl,A0                  ;  OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
0000074A  0318      
0000074C  4280       645           clr.l     D0
0000074E  1001       646           move.b    D1,D0
00000750  41F0 0800  647           lea       0(A0,D0.L),A0
00000754  4280       648           clr.l     D0
00000756  1010       649           move.b    (A0),D0                       ;  OSRdyTbl[y] in D0
00000758  41F9 0000  650           lea       _OSUnMapTbl,A0
0000075C  70DE      
0000075E  41F0 0800  651           lea       0(A0,D0.L),A0                 ;  &OSUnMapTbl[OSRdyTbl[y]] in A0
00000762  1001       652           move.b    D1,D0
00000764  E708       653           lsl.b     #3,D0                         ;  (y << 3) in D0
00000766  D010       654           add.b     (A0),D0
00000768  13C0 0800  655           move.b    D0,_OSPrioHighRdy
0000076C  0314      
                     656   ;
0000076E  B039 0800  657           cmp.b     _OSPrioCur,D0                 ;  if (OSPrioCur != OSPrioHighRdy) {
00000772  0312      
00000774  6742       658           beq.s     OSIntExit68K_1
                     659   ;
00000776  41F9 0800  660           lea       _OSTCBPrioTbl,A0              ;    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
0000077A  0438      
0000077C  4281       661           clr.l     D1
0000077E  1200       662           move.b    D0,D1
00000780  E589       663           lsl.l     #2,D1
00000782  41F0 1800  664           lea       0(A0,D1.L),A0
00000786  23D0 0800  665           move.l    (A0),_OSTCBHighRdy
0000078A  0430      
                     666   ;
0000078C  52B9 0800  667           addq.l    #1,_OSCtxSwCtr                ;    OSCtxSwCtr++;
00000790  00DE      
                     668   ;
00000792  2079 0800  669           move.l    _OSTCBCur,A0                  ;    Save the stack pointer in the suspended task TCB
00000796  0428      
00000798  208F       670           move.l    A7,(A0)
0000079A  4EB9 0000  671           jsr       _OSTaskSwHook                 ;    Invoke user defined context switch hook
0000079E  08CE      
000007A0  2079 0800  672           move.l    _OSTCBHighRdy,A0              ;    OSTCBCur  = OSTCBHighRdy
000007A4  0430      
000007A6  23C8 0800  673           move.l    A0,_OSTCBCur
000007AA  0428      
000007AC  13F9 0800  674           move.b    _OSPrioHighRdy,_OSPrioCur     ;    OSPrioCur = OSPrioHighRdy
000007B0  0314 0800 
000007B4  0312      
000007B6  2E50       675           move.l    (A0),A7                       ;    Get the stack pointer of the task to resume
                     676   OSIntExit68K_1:
000007B8  4CDF 7FFF  677           movem.l   (A7)+,A0-A6/D0-D7             ;  Restore the CPU registers
000007BC  4E73       678           rte                                     ;  Return to task or nested ISR
                     679   
                     680   ;********************************************************************************************************
                     681   ;                                           SYSTEM TICK ISR
                     682   ;
                     683   ; Description : This function is the ISR used to notify uC/OS-II that a system tick has occurred.
                     684   ;
                     685   ; Arguments   : none
                     686   ;
                     687   ; Notes       : 1) You MUST increment 'OSIntNesting' and NOT call OSIntEnter()
                     688   ;               2) You MUST save ALL the CPU registers as shown below
                     689   ;               3) You MUST JUMP to OSIntExit68K() instead of call the function.
                     690   ;********************************************************************************************************
                     691   
                     692   ; C Code for OSInterrupt exit taken from text book on OS example program
                     693   
                     694   ; void OSTickISR(void)
                     695   ; {
                     696   ;          Save processor registers;
                     697   ;          Call OSIntEnter() or increment OSIntNesting;
                     698   ;          Call OSTimeTick();
                     699   ;          Call OSIntExit();
                     700   ;          Restore processor registers;
                     701   ;          Execute a return from interrupt instruction;
                     702   ; }
                     703   
                     704   
                     705   _OSTickISR:
000007BE  007C 0700  706           or.w      #$0700,SR                     ; Disable ALL interrupts
000007C2  5239 0800  707           addq.b    #1,_OSIntNesting              ; OSIntNesting++;
000007C6  030E      
000007C8  48E7 FFFE  708           movem.l   A0-A6/D0-D7,-(A7)             ; Save the registers of the current task
                     709           ; call your ISR here to clear the tick interrupt
000007CC  4EB9 0000  710           jsr       _Timer_ISR
000007D0  5BA6      
                     711           ;
000007D2  4EB9 0000  712           jsr       _OSTimeTick                   ; Call uC/OS-II's tick updating function
000007D6  0F2C      
000007D8  6000 FF3A  713           bra       OSIntExit68K                  ; Exit ISR
                     714   ; C:\IDE68K\UCOSII\OS_CPU_C.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     715   ; /*
                     716   ; *********************************************************************************************************
                     717   ; *                                               uC/OS-II
                     718   ; *                                         The Real-Time Kernel
                     719   ; *
                     720   ; *                            (c) Copyright 2000, Jean J. Labrosse, Weston, FL
                     721   ; *                                          All Rights Reserved
                     722   ; *
                     723   ; *
                     724   ; *                                         68000 Specific C code
                     725   ; *                                                IDE68K
                     726   ; *
                     727   ; * File         : OS_CPU_C.C
                     728   ; * By           : Jean J. Labrosse
                     729   ; *********************************************************************************************************
                     730   ; */
                     731   ; #ifndef  OS_MASTER_FILE
                     732   ; #include <ucos_ii.h>
                     733   ; #endif
                     734   ; #include <Bios.h>
                     735   ; /*
                     736   ; *********************************************************************************************************
                     737   ; *                                           REVISION HISTORY
                     738   ; *
                     739   ; * $Log$
                     740   ; *
                     741   ; *********************************************************************************************************
                     742   ; */
                     743   ; #if OS_TMR_EN > 0
                     744   ; INT8U OSTmrTickCtr;
                     745   ; #endif
                     746   ; /*$PAGE*/
                     747   ; /*
                     748   ; *********************************************************************************************************
                     749   ; *                                        INITIALIZE A TASK'S STACK
                     750   ; *
                     751   ; * Description: This function is called by either OSTaskCreate() or OSTaskCreateExt() to initialize the
                     752   ; *              stack frame of the task being created.  This function is highly processor specific.
                     753   ; *
                     754   ; * Arguments  : task          is a pointer to the task code
                     755   ; *
                     756   ; *              pdata         is a pointer to a user supplied data area that will be passed to the task
                     757   ; *                            when the task first executes.
                     758   ; *
                     759   ; *              ptos          is a pointer to the top of stack.  It is assumed that 'ptos' points to
                     760   ; *                            a 'free' entry on the task stack.  If OS_STK_GROWTH is set to 1 then
                     761   ; *                            'ptos' will contain the HIGHEST valid address of the stack.  Similarly, if
                     762   ; *                            OS_STK_GROWTH is set to 0, the 'ptos' will contains the LOWEST valid address
                     763   ; *                            of the stack.
                     764   ; *
                     765   ; *              opt           specifies options that can be used to alter the behavior of OSTaskStkInit().
                     766   ; *                            (see uCOS_II.H for OS_TASK_OPT_???).
                     767   ; *
                     768   ; * Returns    : Always returns the location of the new top-of-stack' once the processor registers have
                     769   ; *              been placed on the stack in the proper order.
                     770   ; *
                     771   ; * Note(s)    : 1) The initial value of the Status Register (SR) is OS_INITIAL_SR sets the 68xxx processor
                     772   ; *                 to run in SUPERVISOR mode.  It is assumed that all uC/OS-II tasks run in supervisor
                     773   ; *                 mode.
                     774   ; *              2) You can pass the above options in the 'opt' argument.  You MUST only use the upper
                     775   ; *                 8 bits of 'opt' because the lower bits are reserved by uC/OS-II.  If you make changes
                     776   ; *                 to the code below, you will need to ensure that it doesn't affect the behaviour of
                     777   ; *                 OSTaskIdle() and OSTaskStat().
                     778   ; *              3) Registers are initialized to make them easy to differentiate with a debugger.
                     779   ; *********************************************************************************************************
                     780   ; */
                     781   ; OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *ptos, INT16U opt)
                     782   ; {
                     783   _OSTaskStkInit:
000007DC  4E56 0000  784          link      A6,#0
000007E0  48E7 3000  785          movem.l   D2/D3,-(A7)
                     786   ; INT32U  *pstk32;
                     787   ; INT16U  *pstk16;
                     788   ; opt       = opt;                                  /* 'opt' is not used, prevent warning            */
                     789   ; /* Load stack pointer and align on 32-bit bound  */
                     790   ; pstk32    = (INT32U *)((INT32U)ptos & 0xFFFFFFFCL);
000007E4  202E 0010  791          move.l    16(A6),D0
000007E8  C0BC 7FFF  792          and.l     #2147483647,D0
000007EC  FFFF      
000007EE  2400       793          move.l    D0,D2
                     794   ; /* -- SIMULATE CALL TO FUNCTION WITH ARGUMENT -- */
                     795   ; *--pstk32 = (INT32U)pdata;                        /*    pdata                                      */
000007F0  5982       796          subq.l    #4,D2
000007F2  2042       797          move.l    D2,A0
000007F4  20AE 000C  798          move.l    12(A6),(A0)
                     799   ; *--pstk32 = (INT32U)task;                         /*    Task return address                        */
000007F8  5982       800          subq.l    #4,D2
000007FA  2042       801          move.l    D2,A0
000007FC  20AE 0008  802          move.l    8(A6),(A0)
                     803   ; /* ------ SIMULATE INTERRUPT STACK FRAME ------- */
                     804   ; *--pstk32 = (INT32U)task;                         /*    Task return address                        */
00000800  5982       805          subq.l    #4,D2
00000802  2042       806          move.l    D2,A0
00000804  20AE 0008  807          move.l    8(A6),(A0)
                     808   ; pstk16    = (INT16U *)pstk32;                     /* Switch to 16-bit wide stack                   */
00000808  2602       809          move.l    D2,D3
                     810   ; *--pstk16 = (INT16U)OS_INITIAL_SR;                /*    Initial Status Register value for the task */
0000080A  5583       811          subq.l    #2,D3
0000080C  2043       812          move.l    D3,A0
0000080E  30BC 2000  813          move.w    #8192,(A0)
                     814   ; pstk32    = (INT32U *)pstk16;                     /* Switch to 32-bit wide stack                   */
00000812  2403       815          move.l    D3,D2
                     816   ; /* ------- SAVE ALL PROCESSOR REGISTERS -------- */
                     817   ; *--pstk32 = (INT32U)0x00A600A6L;                  /* Register A6                                   */
00000814  5982       818          subq.l    #4,D2
00000816  2042       819          move.l    D2,A0
00000818  20BC 00A6  820          move.l    #10879142,(A0)
0000081C  00A6      
                     821   ; *--pstk32 = (INT32U)0x00A500A5L;                  /* Register A5                                   */
0000081E  5982       822          subq.l    #4,D2
00000820  2042       823          move.l    D2,A0
00000822  20BC 00A5  824          move.l    #10813605,(A0)
00000826  00A5      
                     825   ; *--pstk32 = (INT32U)0x00A400A4L;                  /* Register A4                                   */
00000828  5982       826          subq.l    #4,D2
0000082A  2042       827          move.l    D2,A0
0000082C  20BC 00A4  828          move.l    #10748068,(A0)
00000830  00A4      
                     829   ; *--pstk32 = (INT32U)0x00A300A3L;                  /* Register A3                                   */
00000832  5982       830          subq.l    #4,D2
00000834  2042       831          move.l    D2,A0
00000836  20BC 00A3  832          move.l    #10682531,(A0)
0000083A  00A3      
                     833   ; *--pstk32 = (INT32U)0x00A200A2L;                  /* Register A2                                   */
0000083C  5982       834          subq.l    #4,D2
0000083E  2042       835          move.l    D2,A0
00000840  20BC 00A2  836          move.l    #10616994,(A0)
00000844  00A2      
                     837   ; *--pstk32 = (INT32U)0x00A100A1L;                  /* Register A1                                   */
00000846  5982       838          subq.l    #4,D2
00000848  2042       839          move.l    D2,A0
0000084A  20BC 00A1  840          move.l    #10551457,(A0)
0000084E  00A1      
                     841   ; *--pstk32 = (INT32U)0x00A000A0L;                  /* Register A0                                   */
00000850  5982       842          subq.l    #4,D2
00000852  2042       843          move.l    D2,A0
00000854  20BC 00A0  844          move.l    #10485920,(A0)
00000858  00A0      
                     845   ; *--pstk32 = (INT32U)0x00D700D7L;                  /* Register D7                                   */
0000085A  5982       846          subq.l    #4,D2
0000085C  2042       847          move.l    D2,A0
0000085E  20BC 00D7  848          move.l    #14090455,(A0)
00000862  00D7      
                     849   ; *--pstk32 = (INT32U)0x00D600D6L;                  /* Register D6                                   */
00000864  5982       850          subq.l    #4,D2
00000866  2042       851          move.l    D2,A0
00000868  20BC 00D6  852          move.l    #14024918,(A0)
0000086C  00D6      
                     853   ; *--pstk32 = (INT32U)0x00D500D5L;                  /* Register D5                                   */
0000086E  5982       854          subq.l    #4,D2
00000870  2042       855          move.l    D2,A0
00000872  20BC 00D5  856          move.l    #13959381,(A0)
00000876  00D5      
                     857   ; *--pstk32 = (INT32U)0x00D400D4L;                  /* Register D4                                   */
00000878  5982       858          subq.l    #4,D2
0000087A  2042       859          move.l    D2,A0
0000087C  20BC 00D4  860          move.l    #13893844,(A0)
00000880  00D4      
                     861   ; *--pstk32 = (INT32U)0x00D300D3L;                  /* Register D3                                   */
00000882  5982       862          subq.l    #4,D2
00000884  2042       863          move.l    D2,A0
00000886  20BC 00D3  864          move.l    #13828307,(A0)
0000088A  00D3      
                     865   ; *--pstk32 = (INT32U)0x00D200D2L;                  /* Register D2                                   */
0000088C  5982       866          subq.l    #4,D2
0000088E  2042       867          move.l    D2,A0
00000890  20BC 00D2  868          move.l    #13762770,(A0)
00000894  00D2      
                     869   ; *--pstk32 = (INT32U)0x00D100D1L;                  /* Register D1                                   */
00000896  5982       870          subq.l    #4,D2
00000898  2042       871          move.l    D2,A0
0000089A  20BC 00D1  872          move.l    #13697233,(A0)
0000089E  00D1      
                     873   ; *--pstk32 = (INT32U)0x00D000D0L;                  /* Register D0                                   */
000008A0  5982       874          subq.l    #4,D2
000008A2  2042       875          move.l    D2,A0
000008A4  20BC 00D0  876          move.l    #13631696,(A0)
000008A8  00D0      
                     877   ; return ((OS_STK *)pstk32);                        /* Return pointer to new top-of-stack            */
000008AA  2002       878          move.l    D2,D0
000008AC  4CDF 000C  879          movem.l   (A7)+,D2/D3
000008B0  4E5E       880          unlk      A6
000008B2  4E75       881          rts
                     882   ; }
                     883   ; /*$PAGE*/
                     884   ; /*
                     885   ; *********************************************************************************************************
                     886   ; *                                             GET ISR VECTOR
                     887   ; *
                     888   ; * Description: This function is called to get the address of the exception handler specified by 'vect'.
                     889   ; *              It is assumed that the VBR (Vector Base Register) is set to 0x00000000 (Not an issue with 68000 as VBR is always fixed at 0, but other 68k derivaties allowed VBR to be relocated - e.g. 68020).
                     890   ; *
                     891   ; * Arguments  : vect     is the vector number
                     892   ; *
                     893   ; * Note(s)    : 1) Interrupts are disabled during this call
                     894   ; *              2) It is assumed that the VBR (Vector Base Register) is set to 0x00000000.
                     895   ; *********************************************************************************************************
                     896   ; */
                     897   ; /*$PAGE*/
                     898   ; #if OS_CPU_HOOKS_EN
                     899   ; /*
                     900   ; *********************************************************************************************************
                     901   ; *                                       OS INITIALIZATION HOOK
                     902   ; *                                            (BEGINNING)
                     903   ; *
                     904   ; * Description: This function is called by OSInit() at the beginning of OSInit(). Uou can use it to initialise
                     905   ; *              Your board hardware (it could be done somewhere else too, but this is a convenient place)
                     906   ; *
                     907   ; * Arguments  : none
                     908   ; *
                     909   ; * Note(s)    : 1) Interrupts should be disabled during this call.
                     910   ; *********************************************************************************************************
                     911   ; */
                     912   ; void OSInitHookBegin(void)
                     913   ; {
                     914   _OSInitHookBegin:
000008B4  4E75       915          rts
                     916   ; }
                     917   ; /*
                     918   ; *********************************************************************************************************
                     919   ; *                                       OS INITIALIZATION HOOK
                     920   ; *                                               (END)
                     921   ; *
                     922   ; * Description: This function is called by OSInit() at the end of OSInit().
                     923   ; *
                     924   ; * Arguments  : none
                     925   ; *
                     926   ; * Note(s)    : 1) Interrupts should be disabled during this call.
                     927   ; *********************************************************************************************************
                     928   ; */
                     929   ; void OSInitHookEnd(void)
                     930   ; {
                     931   _OSInitHookEnd:
                     932   ; #if OS_TMR_EN > 0
                     933   ; OSTmrTickCtr = 0;
000008B6  4239 0800  934          clr.b     _OSTmrTickCtr.L
000008BA  00DC      
000008BC  4E75       935          rts
                     936   ; #endif
                     937   ; }
                     938   ; /*
                     939   ; *********************************************************************************************************
                     940   ; *                                          TASK CREATION HOOK
                     941   ; *
                     942   ; * Description: This function is called when a task is created.
                     943   ; *
                     944   ; * Arguments  : ptcb   is a pointer to the task control block of the task being created.
                     945   ; *
                     946   ; * Note(s)    : 1) Interrupts are disabled during this call.
                     947   ; *********************************************************************************************************
                     948   ; */
                     949   ; void OSTaskCreateHook(OS_TCB *ptcb)
                     950   ; {
                     951   _OSTaskCreateHook:
000008BE  4E56 0000  952          link      A6,#0
000008C2  4E5E       953          unlk      A6
000008C4  4E75       954          rts
                     955   ; }
                     956   ; /*
                     957   ; *********************************************************************************************************
                     958   ; *                                           TASK DELETION HOOK
                     959   ; *
                     960   ; * Description: This function is called when a task is deleted.
                     961   ; *
                     962   ; * Arguments  : ptcb   is a pointer to the task control block of the task being deleted.
                     963   ; *
                     964   ; * Note(s)    : 1) Interrupts are disabled during this call.
                     965   ; *********************************************************************************************************
                     966   ; */
                     967   ; void OSTaskDelHook(OS_TCB *ptcb)
                     968   ; {
                     969   _OSTaskDelHook:
000008C6  4E56 0000  970          link      A6,#0
000008CA  4E5E       971          unlk      A6
000008CC  4E75       972          rts
                     973   ; }
                     974   ; /*
                     975   ; *********************************************************************************************************
                     976   ; *                                           TASK SWITCH HOOK
                     977   ; *
                     978   ; * Description: This function is called when a task switch is performed.  This allows you to perform other
                     979   ; *              operations during a context switch.
                     980   ; *
                     981   ; * Arguments  : none
                     982   ; *
                     983   ; * Note(s)    : 1) Interrupts are disabled during this call.
                     984   ; *              2) It is assumed that the global pointer 'OSTCBHighRdy' points to the TCB of the task that
                     985   ; *                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
                     986   ; *                 task being switched out (i.e. the preempted task).
                     987   ; *********************************************************************************************************
                     988   ; */
                     989   ; void OSTaskSwHook(void)
                     990   ; {
                     991   _OSTaskSwHook:
000008CE  4E75       992          rts
                     993   ; }
                     994   ; /*
                     995   ; *********************************************************************************************************
                     996   ; *                                           TASK IDLE HOOK
                     997   ; *
                     998   ; * Description: This function is called when a idle task is performed.  This allows you to perform other
                     999   ; *              operations during the idle task.
                    1000   ; *
                    1001   ; * Arguments  : none
                    1002   ; *
                    1003   ; * Note(s)    : none
                    1004   ; *********************************************************************************************************
                    1005   ; */
                    1006   ; void OSTaskIdleHook(void)
                    1007   ; {
                    1008   _OSTaskIdleHook:
000008D0  4E75      1009          rts
                    1010   ; }
                    1011   ; /*
                    1012   ; *********************************************************************************************************
                    1013   ; *                                           TASK RETURN HOOK
                    1014   ; *
                    1015   ; * Description: This function is called if a task accidentally returns without deleting itself.  In other
                    1016   ; *              words, a task should either be an infinite loop or delete itself if it's done.
                    1017   ; *
                    1018   ; * Arguments  : Pointer to currently running TCB
                    1019   ; *
                    1020   ; * Note(s)    : none
                    1021   ; *********************************************************************************************************
                    1022   ; */
                    1023   ; void OSTaskReturnHook(OS_TCB *ptcb)
                    1024   ; {
                    1025   _OSTaskReturnHook:
000008D2  4E56 0000 1026          link      A6,#0
000008D6  4E5E      1027          unlk      A6
000008D8  4E75      1028          rts
                    1029   ; }
                    1030   ; /*
                    1031   ; *********************************************************************************************************
                    1032   ; *                                           STATISTIC TASK HOOK
                    1033   ; *
                    1034   ; * Description: This function is called every second by uC/OS-II's statistics task.  This allows your
                    1035   ; *              application to add functionality to the statistics task.
                    1036   ; *
                    1037   ; * Arguments  : none
                    1038   ; *********************************************************************************************************
                    1039   ; */
                    1040   ; void OSTaskStatHook(void)
                    1041   ; {
                    1042   _OSTaskStatHook:
000008DA  4E75      1043          rts
                    1044   ; }
                    1045   ; /*
                    1046   ; *********************************************************************************************************
                    1047   ; *                                               TICK HOOK
                    1048   ; *
                    1049   ; * Description: This function is called every tick.
                    1050   ; *
                    1051   ; * Arguments  : none
                    1052   ; *
                    1053   ; * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
                    1054   ; *********************************************************************************************************
                    1055   ; */
                    1056   ; void OSTimeTickHook(void)
                    1057   ; {
                    1058   _OSTimeTickHook:
                    1059   ; #if OS_TMR_EN > 0
                    1060   ; if (OSTmrUsed > 0 && ++OSTmrTickCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
000008DC  3039 0800 1061          move.w    _OSTmrUsed.L,D0
000008E0  0D84      
000008E2  0C40 0000 1062          cmp.w     #0,D0
000008E6  631E      1063          bls.s     OSTimeTickHook_1
000008E8  5239 0800 1064          addq.b    #1,_OSTmrTickCtr.L
000008EC  00DC      
000008EE  1039 0800 1065          move.b    _OSTmrTickCtr.L,D0
000008F2  00DC      
000008F4  0C00 000A 1066          cmp.b     #10,D0
000008F8  650C      1067          blo.s     OSTimeTickHook_1
                    1068   ; OSTmrTickCtr = 0;
000008FA  4239 0800 1069          clr.b     _OSTmrTickCtr.L
000008FE  00DC      
                    1070   ; OSTmrSignal();
00000900  4EB9 0000 1071          jsr       _OSTmrSignal
00000904  55A6      
                    1072   OSTimeTickHook_1:
00000906  4E75      1073          rts
                    1074   ; }
                    1075   ; #endif
                    1076   ; }
                    1077   ; /*
                    1078   ; *********************************************************************************************************
                    1079   ; *                                           OSTCBInit() HOOK
                    1080   ; *
                    1081   ; * Description: This function is called by OSTCBInit() after setting up most of the TCB.
                    1082   ; *
                    1083   ; * Arguments  : ptcb    is a pointer to the TCB of the task being created.
                    1084   ; *
                    1085   ; * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
                    1086   ; *********************************************************************************************************
                    1087   ; */
                    1088   ; #if OS_VERSION > 203
                    1089   ; void OSTCBInitHook (OS_TCB *ptcb)
                    1090   ; {
                    1091   _OSTCBInitHook:
00000908  4E56 0000 1092          link      A6,#0
0000090C  4E5E      1093          unlk      A6
0000090E  4E75      1094          rts
                    1095   ; }
                    1096   ; #endif
                    1097   ; #endif // OS_CPU_HOOKS_EN
                    1098   ; C:\IDE68K\UCOSII\UCOS_II.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    1099   ; /*
                    1100   ; *********************************************************************************************************
                    1101   ; *                                                uC/OS-II
                    1102   ; *                                          The Real-Time Kernel
                    1103   ; *                                             CORE FUNCTIONS
                    1104   ; *
                    1105   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    1106   ; *                                           All Rights Reserved
                    1107   ; *
                    1108   ; * File    : OS_CORE.C
                    1109   ; * By      : Jean J. Labrosse
                    1110   ; * Version : V2.92.07
                    1111   ; *
                    1112   ; * LICENSING TERMS:
                    1113   ; * ---------------
                    1114   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    1115   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    1116   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    1117   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    1118   ; * licensing fee.
                    1119   ; *********************************************************************************************************
                    1120   ; */
                    1121   ; #define  MICRIUM_SOURCE
                    1122   ; #ifndef  OS_MASTER_FILE
                    1123   ; #define  OS_GLOBALS
                    1124   ; #include <ucos_ii.h>
                    1125   ; #endif
                    1126   ; /*
                    1127   ; *********************************************************************************************************
                    1128   ; *                                      PRIORITY RESOLUTION TABLE
                    1129   ; *
                    1130   ; * Note: Index into table is bit pattern to resolve highest priority
                    1131   ; *       Indexed value corresponds to highest priority bit position (i.e. 0..7)
                    1132   ; *********************************************************************************************************
                    1133   ; */
                    1134   ; INT8U  const  OSUnMapTbl[256] = {
                    1135   ; 0u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x00 to 0x0F                   */
                    1136   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x10 to 0x1F                   */
                    1137   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x20 to 0x2F                   */
                    1138   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x30 to 0x3F                   */
                    1139   ; 6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x40 to 0x4F                   */
                    1140   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x50 to 0x5F                   */
                    1141   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x60 to 0x6F                   */
                    1142   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x70 to 0x7F                   */
                    1143   ; 7u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x80 to 0x8F                   */
                    1144   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x90 to 0x9F                   */
                    1145   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xA0 to 0xAF                   */
                    1146   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xB0 to 0xBF                   */
                    1147   ; 6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xC0 to 0xCF                   */
                    1148   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xD0 to 0xDF                   */
                    1149   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xE0 to 0xEF                   */
                    1150   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u  /* 0xF0 to 0xFF                   */
                    1151   ; };
                    1152   ; /*$PAGE*/
                    1153   ; /*
                    1154   ; *********************************************************************************************************
                    1155   ; *                                         FUNCTION PROTOTYPES
                    1156   ; *********************************************************************************************************
                    1157   ; */
                    1158   ; static  void  OS_InitEventList(void);
                    1159   ; static  void  OS_InitMisc(void);
                    1160   ; static  void  OS_InitRdyList(void);
                    1161   ; static  void  OS_InitTaskIdle(void);
                    1162   ; #if OS_TASK_STAT_EN > 0u
                    1163   ; static  void  OS_InitTaskStat(void);
                    1164   ; #endif
                    1165   ; static  void  OS_InitTCBList(void);
                    1166   ; static  void  OS_SchedNew(void);
                    1167   ; /*$PAGE*/
                    1168   ; /*
                    1169   ; *********************************************************************************************************
                    1170   ; *                        GET THE NAME OF A SEMAPHORE, MUTEX, MAILBOX or QUEUE
                    1171   ; *
                    1172   ; * Description: This function is used to obtain the name assigned to a semaphore, mutex, mailbox or queue.
                    1173   ; *
                    1174   ; * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
                    1175   ; *                        a mutex, a mailbox or a queue.  Where this function is concerned, the actual
                    1176   ; *                        type is irrelevant.
                    1177   ; *
                    1178   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the semaphore,
                    1179   ; *                        mutex, mailbox or queue.
                    1180   ; *
                    1181   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    1182   ; *
                    1183   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    1184   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
                    1185   ; *                                                   control block type.
                    1186   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    1187   ; *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
                    1188   ; *                        OS_ERR_NAME_GET_ISR        if you are trying to call this function from an ISR
                    1189   ; *
                    1190   ; * Returns    : The length of the string or 0 if the 'pevent' is a NULL pointer.
                    1191   ; *********************************************************************************************************
                    1192   ; */
                    1193   ; #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
                    1194   ; INT8U  OSEventNameGet (OS_EVENT   *pevent,
                    1195   ; INT8U     **pname,
                    1196   ; INT8U      *perr)
                    1197   ; {
                    1198   _OSEventNameGet:
00000910  4E56 FFFC 1199          link      A6,#-4
00000914  2F02      1200          move.l    D2,-(A7)
00000916  242E 0010 1201          move.l    16(A6),D2
                    1202   ; INT8U      len;
                    1203   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    1204   ; OS_CPU_SR  cpu_sr = 0u;
                    1205   ; #endif
                    1206   ; #ifdef OS_SAFETY_CRITICAL
                    1207   ; if (perr == (INT8U *)0) {
                    1208   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    1209   ; return (0u);
                    1210   ; }
                    1211   ; #endif
                    1212   ; #if OS_ARG_CHK_EN > 0u
                    1213   ; if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
                    1214   ; *perr = OS_ERR_PEVENT_NULL;
                    1215   ; return (0u);
                    1216   ; }
                    1217   ; if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
                    1218   ; *perr = OS_ERR_PNAME_NULL;
                    1219   ; return (0u);
                    1220   ; }
                    1221   ; #endif
                    1222   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
0000091A  1039 0800 1223          move.b    _OSIntNesting.L,D0
0000091E  030E      
00000920  0C00 0000 1224          cmp.b     #0,D0
00000924  630C      1225          bls.s     OSEventNameGet_1
                    1226   ; *perr  = OS_ERR_NAME_GET_ISR;
00000926  2042      1227          move.l    D2,A0
00000928  10BC 0011 1228          move.b    #17,(A0)
                    1229   ; return (0u);
0000092C  4200      1230          clr.b     D0
0000092E  6000 0066 1231          bra       OSEventNameGet_3
                    1232   OSEventNameGet_1:
                    1233   ; }
                    1234   ; switch (pevent->OSEventType) {
00000932  206E 0008 1235          move.l    8(A6),A0
00000936  1010      1236          move.b    (A0),D0
00000938  C0BC 0000 1237          and.l     #255,D0
0000093C  00FF      
0000093E  5380      1238          subq.l    #1,D0
00000940  651C      1239          blo.s     OSEventNameGet_4
00000942  0C80 0000 1240          cmp.l     #4,D0
00000946  0004      
00000948  6414      1241          bhs.s     OSEventNameGet_4
0000094A  E380      1242          asl.l     #1,D0
0000094C  303B 0806 1243          move.w    OSEventNameGet_6(PC,D0.L),D0
00000950  4EFB 0002 1244          jmp       OSEventNameGet_6(PC,D0.W)
                    1245   OSEventNameGet_6:
00000954  0008      1246          dc.w      OSEventNameGet_7-OSEventNameGet_6
00000956  0008      1247          dc.w      OSEventNameGet_7-OSEventNameGet_6
00000958  0008      1248          dc.w      OSEventNameGet_7-OSEventNameGet_6
0000095A  0008      1249          dc.w      OSEventNameGet_7-OSEventNameGet_6
                    1250   OSEventNameGet_7:
                    1251   ; case OS_EVENT_TYPE_SEM:
                    1252   ; case OS_EVENT_TYPE_MUTEX:
                    1253   ; case OS_EVENT_TYPE_MBOX:
                    1254   ; case OS_EVENT_TYPE_Q:
                    1255   ; break;
0000095C  600A      1256          bra.s     OSEventNameGet_5
                    1257   OSEventNameGet_4:
                    1258   ; default:
                    1259   ; *perr = OS_ERR_EVENT_TYPE;
0000095E  2042      1260          move.l    D2,A0
00000960  10BC 0001 1261          move.b    #1,(A0)
                    1262   ; return (0u);
00000964  4200      1263          clr.b     D0
00000966  602E      1264          bra.s     OSEventNameGet_3
                    1265   OSEventNameGet_5:
                    1266   ; }
                    1267   ; OS_ENTER_CRITICAL();
00000968  40E7      1268          dc.w      16615
0000096A  007C      1269          dc.w      124
0000096C  0700      1270          dc.w      1792
                    1271   ; *pname = pevent->OSEventName;
0000096E  206E 0008 1272          move.l    8(A6),A0
00000972  226E 000C 1273          move.l    12(A6),A1
00000976  22A8 0012 1274          move.l    18(A0),(A1)
                    1275   ; len    = OS_StrLen(*pname);
0000097A  206E 000C 1276          move.l    12(A6),A0
0000097E  2F10      1277          move.l    (A0),-(A7)
00000980  4EB9 0000 1278          jsr       _OS_StrLen
00000984  1684      
00000986  584F      1279          addq.w    #4,A7
00000988  1D40 FFFF 1280          move.b    D0,-1(A6)
                    1281   ; OS_EXIT_CRITICAL();
0000098C  46DF      1282          dc.w      18143
                    1283   ; *perr  = OS_ERR_NONE;
0000098E  2042      1284          move.l    D2,A0
00000990  4210      1285          clr.b     (A0)
                    1286   ; return (len);
00000992  102E FFFF 1287          move.b    -1(A6),D0
                    1288   OSEventNameGet_3:
00000996  241F      1289          move.l    (A7)+,D2
00000998  4E5E      1290          unlk      A6
0000099A  4E75      1291          rts
                    1292   ; }
                    1293   ; #endif
                    1294   ; /*$PAGE*/
                    1295   ; /*
                    1296   ; *********************************************************************************************************
                    1297   ; *                        ASSIGN A NAME TO A SEMAPHORE, MUTEX, MAILBOX or QUEUE
                    1298   ; *
                    1299   ; * Description: This function assigns a name to a semaphore, mutex, mailbox or queue.
                    1300   ; *
                    1301   ; * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
                    1302   ; *                        a mutex, a mailbox or a queue.  Where this function is concerned, it doesn't
                    1303   ; *                        matter the actual type.
                    1304   ; *
                    1305   ; *              pname     is a pointer to an ASCII string that will be used as the name of the semaphore,
                    1306   ; *                        mutex, mailbox or queue.
                    1307   ; *
                    1308   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    1309   ; *
                    1310   ; *                        OS_ERR_NONE                if the requested task is resumed
                    1311   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
                    1312   ; *                                                   control block type.
                    1313   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    1314   ; *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
                    1315   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    1316   ; *
                    1317   ; * Returns    : None
                    1318   ; *********************************************************************************************************
                    1319   ; */
                    1320   ; #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
                    1321   ; void  OSEventNameSet (OS_EVENT  *pevent,
                    1322   ; INT8U     *pname,
                    1323   ; INT8U     *perr)
                    1324   ; {
                    1325   _OSEventNameSet:
0000099C  4E56 0000 1326          link      A6,#0
000009A0  2F02      1327          move.l    D2,-(A7)
000009A2  242E 0010 1328          move.l    16(A6),D2
                    1329   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    1330   ; OS_CPU_SR  cpu_sr = 0u;
                    1331   ; #endif
                    1332   ; #ifdef OS_SAFETY_CRITICAL
                    1333   ; if (perr == (INT8U *)0) {
                    1334   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    1335   ; return;
                    1336   ; }
                    1337   ; #endif
                    1338   ; #if OS_ARG_CHK_EN > 0u
                    1339   ; if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
                    1340   ; *perr = OS_ERR_PEVENT_NULL;
                    1341   ; return;
                    1342   ; }
                    1343   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    1344   ; *perr = OS_ERR_PNAME_NULL;
                    1345   ; return;
                    1346   ; }
                    1347   ; #endif
                    1348   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
000009A6  1039 0800 1349          move.b    _OSIntNesting.L,D0
000009AA  030E      
000009AC  0C00 0000 1350          cmp.b     #0,D0
000009B0  630A      1351          bls.s     OSEventNameSet_1
                    1352   ; *perr = OS_ERR_NAME_SET_ISR;
000009B2  2042      1353          move.l    D2,A0
000009B4  10BC 0012 1354          move.b    #18,(A0)
                    1355   ; return;
000009B8  6000 004C 1356          bra       OSEventNameSet_3
                    1357   OSEventNameSet_1:
                    1358   ; }
                    1359   ; switch (pevent->OSEventType) {
000009BC  206E 0008 1360          move.l    8(A6),A0
000009C0  1010      1361          move.b    (A0),D0
000009C2  C0BC 0000 1362          and.l     #255,D0
000009C6  00FF      
000009C8  5380      1363          subq.l    #1,D0
000009CA  651C      1364          blo.s     OSEventNameSet_4
000009CC  0C80 0000 1365          cmp.l     #4,D0
000009D0  0004      
000009D2  6414      1366          bhs.s     OSEventNameSet_4
000009D4  E380      1367          asl.l     #1,D0
000009D6  303B 0806 1368          move.w    OSEventNameSet_6(PC,D0.L),D0
000009DA  4EFB 0002 1369          jmp       OSEventNameSet_6(PC,D0.W)
                    1370   OSEventNameSet_6:
000009DE  0008      1371          dc.w      OSEventNameSet_7-OSEventNameSet_6
000009E0  0008      1372          dc.w      OSEventNameSet_7-OSEventNameSet_6
000009E2  0008      1373          dc.w      OSEventNameSet_7-OSEventNameSet_6
000009E4  0008      1374          dc.w      OSEventNameSet_7-OSEventNameSet_6
                    1375   OSEventNameSet_7:
                    1376   ; case OS_EVENT_TYPE_SEM:
                    1377   ; case OS_EVENT_TYPE_MUTEX:
                    1378   ; case OS_EVENT_TYPE_MBOX:
                    1379   ; case OS_EVENT_TYPE_Q:
                    1380   ; break;
000009E6  6008      1381          bra.s     OSEventNameSet_5
                    1382   OSEventNameSet_4:
                    1383   ; default:
                    1384   ; *perr = OS_ERR_EVENT_TYPE;
000009E8  2042      1385          move.l    D2,A0
000009EA  10BC 0001 1386          move.b    #1,(A0)
                    1387   ; return;
000009EE  6016      1388          bra.s     OSEventNameSet_3
                    1389   OSEventNameSet_5:
                    1390   ; }
                    1391   ; OS_ENTER_CRITICAL();
000009F0  40E7      1392          dc.w      16615
000009F2  007C      1393          dc.w      124
000009F4  0700      1394          dc.w      1792
                    1395   ; pevent->OSEventName = pname;
000009F6  206E 0008 1396          move.l    8(A6),A0
000009FA  216E 000C 1397          move.l    12(A6),18(A0)
000009FE  0012      
                    1398   ; OS_EXIT_CRITICAL();
00000A00  46DF      1399          dc.w      18143
                    1400   ; *perr = OS_ERR_NONE;
00000A02  2042      1401          move.l    D2,A0
00000A04  4210      1402          clr.b     (A0)
                    1403   OSEventNameSet_3:
00000A06  241F      1404          move.l    (A7)+,D2
00000A08  4E5E      1405          unlk      A6
00000A0A  4E75      1406          rts
                    1407   ; }
                    1408   ; #endif
                    1409   ; /*$PAGE*/
                    1410   ; /*
                    1411   ; *********************************************************************************************************
                    1412   ; *                                       PEND ON MULTIPLE EVENTS
                    1413   ; *
                    1414   ; * Description: This function waits for multiple events.  If multiple events are ready at the start of the
                    1415   ; *              pend call, then all available events are returned as ready.  If the task must pend on the
                    1416   ; *              multiple events, then only the first posted or aborted event is returned as ready.
                    1417   ; *
                    1418   ; * Arguments  : pevents_pend  is a pointer to a NULL-terminated array of event control blocks to wait for.
                    1419   ; *
                    1420   ; *              pevents_rdy   is a pointer to an array to return which event control blocks are available
                    1421   ; *                            or ready.  The size of the array MUST be greater than or equal to the size
                    1422   ; *                            of the 'pevents_pend' array, including terminating NULL.
                    1423   ; *
                    1424   ; *              pmsgs_rdy     is a pointer to an array to return messages from any available message-type
                    1425   ; *                            events.  The size of the array MUST be greater than or equal to the size of
                    1426   ; *                            the 'pevents_pend' array, excluding the terminating NULL.  Since NULL
                    1427   ; *                            messages are valid messages, this array cannot be NULL-terminated.  Instead,
                    1428   ; *                            every available message-type event returns its messages in the 'pmsgs_rdy'
                    1429   ; *                            array at the same index as the event is returned in the 'pevents_rdy' array.
                    1430   ; *                            All other 'pmsgs_rdy' array indices are filled with NULL messages.
                    1431   ; *
                    1432   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    1433   ; *                            wait for the resources up to the amount of time specified by this argument.
                    1434   ; *                            If you specify 0, however, your task will wait forever for the specified
                    1435   ; *                            events or, until the resources becomes available (or the events occur).
                    1436   ; *
                    1437   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    1438   ; *                            messages are:
                    1439   ; *
                    1440   ; *                            OS_ERR_NONE         The call was successful and your task owns the resources
                    1441   ; *                                                or, the events you are waiting for occurred; check the
                    1442   ; *                                                'pevents_rdy' array for which events are available.
                    1443   ; *                            OS_ERR_PEND_ABORT   The wait on the events was aborted; check the
                    1444   ; *                                                'pevents_rdy' array for which events were aborted.
                    1445   ; *                            OS_ERR_TIMEOUT      The events were not received within the specified
                    1446   ; *                                                'timeout'.
                    1447   ; *                            OS_ERR_PEVENT_NULL  If 'pevents_pend', 'pevents_rdy', or 'pmsgs_rdy' is a
                    1448   ; *                                                NULL pointer.
                    1449   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to an array of semaphores,
                    1450   ; *                                                mailboxes, and/or queues.
                    1451   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    1452   ; *                                                would lead to a suspension.
                    1453   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked.
                    1454   ; *
                    1455   ; * Returns    : >  0          the number of events returned as ready or aborted.
                    1456   ; *              == 0          if no events are returned as ready because of timeout or upon error.
                    1457   ; *
                    1458   ; * Notes      : 1) a. Validate 'pevents_pend' array as valid OS_EVENTs :
                    1459   ; *
                    1460   ; *                        semaphores, mailboxes, queues
                    1461   ; *
                    1462   ; *                 b. Return ALL available events and messages, if any
                    1463   ; *
                    1464   ; *                 c. Add    current task priority as pending to   each events's wait list
                    1465   ; *                      Performed in OS_EventTaskWaitMulti()
                    1466   ; *
                    1467   ; *                 d. Wait on any of multiple events
                    1468   ; *
                    1469   ; *                 e. Remove current task priority as pending from each events's wait list
                    1470   ; *                      Performed in OS_EventTaskRdy(), if events posted or aborted
                    1471   ; *
                    1472   ; *                 f. Return any event posted or aborted, if any
                    1473   ; *                      else
                    1474   ; *                    Return timeout
                    1475   ; *
                    1476   ; *              2) 'pevents_rdy' initialized to NULL PRIOR to all other validation or function handling in
                    1477   ; *                 case of any error(s).
                    1478   ; *********************************************************************************************************
                    1479   ; */
                    1480   ; /*$PAGE*/
                    1481   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    1482   ; INT16U  OSEventPendMulti (OS_EVENT  **pevents_pend,
                    1483   ; OS_EVENT  **pevents_rdy,
                    1484   ; void      **pmsgs_rdy,
                    1485   ; INT32U      timeout,
                    1486   ; INT8U      *perr)
                    1487   ; {
                    1488   _OSEventPendMulti:
00000A0C  4E56 FFFC 1489          link      A6,#-4
00000A10  48E7 3F38 1490          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4,-(A7)
00000A14  45F9 0800 1491          lea       _OSTCBCur.L,A2
00000A18  0428      
00000A1A  282E 0018 1492          move.l    24(A6),D4
00000A1E  2A2E 000C 1493          move.l    12(A6),D5
00000A22  266E 0010 1494          move.l    16(A6),A3
00000A26  286E 0008 1495          move.l    8(A6),A4
                    1496   ; OS_EVENT  **pevents;
                    1497   ; OS_EVENT   *pevent;
                    1498   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    1499   ; OS_Q       *pq;
                    1500   ; #endif
                    1501   ; BOOLEAN     events_rdy;
                    1502   ; INT16U      events_rdy_nbr;
                    1503   ; INT8U       events_stat;
                    1504   ; #if (OS_CRITICAL_METHOD == 3u)                          /* Allocate storage for CPU status register    */
                    1505   ; OS_CPU_SR   cpu_sr = 0u;
                    1506   ; #endif
                    1507   ; #ifdef OS_SAFETY_CRITICAL
                    1508   ; if (perr == (INT8U *)0) {
                    1509   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    1510   ; return (0u);
                    1511   ; }
                    1512   ; #endif
                    1513   ; #if (OS_ARG_CHK_EN > 0u)
                    1514   ; if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
                    1515   ; *perr =  OS_ERR_PEVENT_NULL;
                    1516   ; return (0u);
                    1517   ; }
                    1518   ; if (*pevents_pend  == (OS_EVENT *)0) {              /* Validate 'pevents_pend'                     */
                    1519   ; *perr =  OS_ERR_PEVENT_NULL;
                    1520   ; return (0u);
                    1521   ; }
                    1522   ; if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
                    1523   ; *perr =  OS_ERR_PEVENT_NULL;
                    1524   ; return (0u);
                    1525   ; }
                    1526   ; if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
                    1527   ; *perr =  OS_ERR_PEVENT_NULL;
                    1528   ; return (0u);
                    1529   ; }
                    1530   ; #endif
                    1531   ; *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
00000A2A  2045      1532          move.l    D5,A0
00000A2C  4290      1533          clr.l     (A0)
                    1534   ; pevents     =  pevents_pend;
00000A2E  2E0C      1535          move.l    A4,D7
                    1536   ; pevent      = *pevents;
00000A30  2047      1537          move.l    D7,A0
00000A32  2410      1538          move.l    (A0),D2
                    1539   ; while  (pevent != (OS_EVENT *)0) {
                    1540   OSEventPendMulti_1:
00000A34  4A82      1541          tst.l     D2
00000A36  6700 0046 1542          beq       OSEventPendMulti_3
                    1543   ; switch (pevent->OSEventType) {                  /* Validate event block types                  */
00000A3A  2042      1544          move.l    D2,A0
00000A3C  1010      1545          move.b    (A0),D0
00000A3E  C0BC 0000 1546          and.l     #255,D0
00000A42  00FF      
00000A44  5380      1547          subq.l    #1,D0
00000A46  6522      1548          blo.s     OSEventPendMulti_10
00000A48  0C80 0000 1549          cmp.l     #5,D0
00000A4C  0005      
00000A4E  641A      1550          bhs.s     OSEventPendMulti_10
00000A50  E380      1551          asl.l     #1,D0
00000A52  303B 0806 1552          move.w    OSEventPendMulti_6(PC,D0.L),D0
00000A56  4EFB 0002 1553          jmp       OSEventPendMulti_6(PC,D0.W)
                    1554   OSEventPendMulti_6:
00000A5A  000C      1555          dc.w      OSEventPendMulti_8-OSEventPendMulti_6
00000A5C  000E      1556          dc.w      OSEventPendMulti_9-OSEventPendMulti_6
00000A5E  000A      1557          dc.w      OSEventPendMulti_7-OSEventPendMulti_6
00000A60  0010      1558          dc.w      OSEventPendMulti_10-OSEventPendMulti_6
00000A62  0010      1559          dc.w      OSEventPendMulti_10-OSEventPendMulti_6
                    1560   OSEventPendMulti_7:
                    1561   ; #if (OS_SEM_EN  > 0u)
                    1562   ; case OS_EVENT_TYPE_SEM:
                    1563   ; break;
00000A64  6010      1564          bra.s     OSEventPendMulti_5
                    1565   OSEventPendMulti_8:
                    1566   ; #endif
                    1567   ; #if (OS_MBOX_EN > 0u)
                    1568   ; case OS_EVENT_TYPE_MBOX:
                    1569   ; break;
00000A66  600E      1570          bra.s     OSEventPendMulti_5
                    1571   OSEventPendMulti_9:
                    1572   ; #endif
                    1573   ; #if ((OS_Q_EN   > 0u) && (OS_MAX_QS > 0u))
                    1574   ; case OS_EVENT_TYPE_Q:
                    1575   ; break;
00000A68  600C      1576          bra.s     OSEventPendMulti_5
                    1577   OSEventPendMulti_10:
                    1578   ; #endif
                    1579   ; case OS_EVENT_TYPE_MUTEX:
                    1580   ; case OS_EVENT_TYPE_FLAG:
                    1581   ; default:
                    1582   ; *perr = OS_ERR_EVENT_TYPE;
00000A6A  2044      1583          move.l    D4,A0
00000A6C  10BC 0001 1584          move.b    #1,(A0)
                    1585   ; return (0u);
00000A70  4240      1586          clr.w     D0
00000A72  6000 02C2 1587          bra       OSEventPendMulti_13
                    1588   OSEventPendMulti_5:
                    1589   ; }
                    1590   ; pevents++;
00000A76  5887      1591          addq.l    #4,D7
                    1592   ; pevent = *pevents;
00000A78  2047      1593          move.l    D7,A0
00000A7A  2410      1594          move.l    (A0),D2
00000A7C  60B6      1595          bra       OSEventPendMulti_1
                    1596   OSEventPendMulti_3:
                    1597   ; }
                    1598   ; if (OSIntNesting  > 0u) {                           /* See if called from ISR ...                  */
00000A7E  1039 0800 1599          move.b    _OSIntNesting.L,D0
00000A82  030E      
00000A84  0C00 0000 1600          cmp.b     #0,D0
00000A88  630C      1601          bls.s     OSEventPendMulti_14
                    1602   ; *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
00000A8A  2044      1603          move.l    D4,A0
00000A8C  10BC 0002 1604          move.b    #2,(A0)
                    1605   ; return (0u);
00000A90  4240      1606          clr.w     D0
00000A92  6000 02A2 1607          bra       OSEventPendMulti_13
                    1608   OSEventPendMulti_14:
                    1609   ; }
                    1610   ; if (OSLockNesting > 0u) {                           /* See if called with scheduler locked ...     */
00000A96  1039 0800 1611          move.b    _OSLockNesting.L,D0
00000A9A  0310      
00000A9C  0C00 0000 1612          cmp.b     #0,D0
00000AA0  630C      1613          bls.s     OSEventPendMulti_16
                    1614   ; *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
00000AA2  2044      1615          move.l    D4,A0
00000AA4  10BC 000D 1616          move.b    #13,(A0)
                    1617   ; return (0u);
00000AA8  4240      1618          clr.w     D0
00000AAA  6000 028A 1619          bra       OSEventPendMulti_13
                    1620   OSEventPendMulti_16:
                    1621   ; }
                    1622   ; /*$PAGE*/
                    1623   ; events_rdy     =  OS_FALSE;
00000AAE  422E FFFE 1624          clr.b     -2(A6)
                    1625   ; events_rdy_nbr =  0u;
00000AB2  4243      1626          clr.w     D3
                    1627   ; events_stat    =  OS_STAT_RDY;
00000AB4  422E FFFF 1628          clr.b     -1(A6)
                    1629   ; pevents        =  pevents_pend;
00000AB8  2E0C      1630          move.l    A4,D7
                    1631   ; pevent         = *pevents;
00000ABA  2047      1632          move.l    D7,A0
00000ABC  2410      1633          move.l    (A0),D2
                    1634   ; OS_ENTER_CRITICAL();
00000ABE  40E7      1635          dc.w      16615
00000AC0  007C      1636          dc.w      124
00000AC2  0700      1637          dc.w      1792
                    1638   ; while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
                    1639   OSEventPendMulti_18:
00000AC4  4A82      1640          tst.l     D2
00000AC6  6700 010A 1641          beq       OSEventPendMulti_20
                    1642   ; switch (pevent->OSEventType) {
00000ACA  2042      1643          move.l    D2,A0
00000ACC  1010      1644          move.b    (A0),D0
00000ACE  C0BC 0000 1645          and.l     #255,D0
00000AD2  00FF      
00000AD4  5380      1646          subq.l    #1,D0
00000AD6  6500 00DE 1647          blo       OSEventPendMulti_27
00000ADA  0C80 0000 1648          cmp.l     #5,D0
00000ADE  0005      
00000AE0  6400 00D4 1649          bhs       OSEventPendMulti_27
00000AE4  E380      1650          asl.l     #1,D0
00000AE6  303B 0806 1651          move.w    OSEventPendMulti_23(PC,D0.L),D0
00000AEA  4EFB 0002 1652          jmp       OSEventPendMulti_23(PC,D0.W)
                    1653   OSEventPendMulti_23:
00000AEE  003A      1654          dc.w      OSEventPendMulti_25-OSEventPendMulti_23
00000AF0  0068      1655          dc.w      OSEventPendMulti_26-OSEventPendMulti_23
00000AF2  000A      1656          dc.w      OSEventPendMulti_24-OSEventPendMulti_23
00000AF4  00C8      1657          dc.w      OSEventPendMulti_27-OSEventPendMulti_23
00000AF6  00C8      1658          dc.w      OSEventPendMulti_27-OSEventPendMulti_23
                    1659   OSEventPendMulti_24:
                    1660   ; #if (OS_SEM_EN > 0u)
                    1661   ; case OS_EVENT_TYPE_SEM:
                    1662   ; if (pevent->OSEventCnt > 0u) {         /* If semaphore count > 0, resource available; */
00000AF8  2042      1663          move.l    D2,A0
00000AFA  3028 0006 1664          move.w    6(A0),D0
00000AFE  0C40 0000 1665          cmp.w     #0,D0
00000B02  631A      1666          bls.s     OSEventPendMulti_30
                    1667   ; pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
00000B04  2002      1668          move.l    D2,D0
00000B06  5C80      1669          addq.l    #6,D0
00000B08  2040      1670          move.l    D0,A0
00000B0A  5350      1671          subq.w    #1,(A0)
                    1672   ; *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
00000B0C  2045      1673          move.l    D5,A0
00000B0E  5885      1674          addq.l    #4,D5
00000B10  2082      1675          move.l    D2,(A0)
                    1676   ; events_rdy   =  OS_TRUE;
00000B12  1D7C 0001 1677          move.b    #1,-2(A6)
00000B16  FFFE      
                    1678   ; *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
00000B18  429B      1679          clr.l     (A3)+
                    1680   ; events_rdy_nbr++;
00000B1A  5243      1681          addq.w    #1,D3
00000B1C  6006      1682          bra.s     OSEventPendMulti_31
                    1683   OSEventPendMulti_30:
                    1684   ; } else {
                    1685   ; events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
00000B1E  002E 0001 1686          or.b      #1,-1(A6)
00000B22  FFFF      
                    1687   OSEventPendMulti_31:
                    1688   ; }
                    1689   ; break;
00000B24  6000 00A2 1690          bra       OSEventPendMulti_22
                    1691   OSEventPendMulti_25:
                    1692   ; #endif
                    1693   ; #if (OS_MBOX_EN > 0u)
                    1694   ; case OS_EVENT_TYPE_MBOX:
                    1695   ; if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
00000B28  2042      1696          move.l    D2,A0
00000B2A  2028 0002 1697          move.l    2(A0),D0
00000B2E  671C      1698          beq.s     OSEventPendMulti_32
                    1699   ; /* ... return available message,           ... */
                    1700   ; *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
00000B30  2042      1701          move.l    D2,A0
00000B32  26E8 0002 1702          move.l    2(A0),(A3)+
                    1703   ; pevent->OSEventPtr  = (void *)0;
00000B36  2042      1704          move.l    D2,A0
00000B38  42A8 0002 1705          clr.l     2(A0)
                    1706   ; *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
00000B3C  2045      1707          move.l    D5,A0
00000B3E  5885      1708          addq.l    #4,D5
00000B40  2082      1709          move.l    D2,(A0)
                    1710   ; events_rdy         =  OS_TRUE;
00000B42  1D7C 0001 1711          move.b    #1,-2(A6)
00000B46  FFFE      
                    1712   ; events_rdy_nbr++;
00000B48  5243      1713          addq.w    #1,D3
00000B4A  6006      1714          bra.s     OSEventPendMulti_33
                    1715   OSEventPendMulti_32:
                    1716   ; } else {
                    1717   ; events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
00000B4C  002E 0002 1718          or.b      #2,-1(A6)
00000B50  FFFF      
                    1719   OSEventPendMulti_33:
                    1720   ; }
                    1721   ; break;
00000B52  6000 0074 1722          bra       OSEventPendMulti_22
                    1723   OSEventPendMulti_26:
                    1724   ; #endif
                    1725   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    1726   ; case OS_EVENT_TYPE_Q:
                    1727   ; pq = (OS_Q *)pevent->OSEventPtr;
00000B56  2042      1728          move.l    D2,A0
00000B58  2C28 0002 1729          move.l    2(A0),D6
                    1730   ; if (pq->OSQEntries > 0u) {             /* If queue NOT empty;                     ... */
00000B5C  2046      1731          move.l    D6,A0
00000B5E  3028 0016 1732          move.w    22(A0),D0
00000B62  0C40 0000 1733          cmp.w     #0,D0
00000B66  6300 0046 1734          bls       OSEventPendMulti_34
                    1735   ; /* ... return available message,           ... */
                    1736   ; *pmsgs_rdy++ = (void *)*pq->OSQOut++;
00000B6A  2006      1737          move.l    D6,D0
00000B6C  0680 0000 1738          add.l     #16,D0
00000B70  0010      
00000B72  2040      1739          move.l    D0,A0
00000B74  2250      1740          move.l    (A0),A1
00000B76  5890      1741          addq.l    #4,(A0)
00000B78  26D1      1742          move.l    (A1),(A3)+
                    1743   ; if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
00000B7A  2046      1744          move.l    D6,A0
00000B7C  2246      1745          move.l    D6,A1
00000B7E  2028 0010 1746          move.l    16(A0),D0
00000B82  B0A9 0008 1747          cmp.l     8(A1),D0
00000B86  660A      1748          bne.s     OSEventPendMulti_36
                    1749   ; pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
00000B88  2046      1750          move.l    D6,A0
00000B8A  2246      1751          move.l    D6,A1
00000B8C  2368 0004 1752          move.l    4(A0),16(A1)
00000B90  0010      
                    1753   OSEventPendMulti_36:
                    1754   ; }
                    1755   ; pq->OSQEntries--;                  /* Update number of queue entries              */
00000B92  2006      1756          move.l    D6,D0
00000B94  0680 0000 1757          add.l     #22,D0
00000B98  0016      
00000B9A  2040      1758          move.l    D0,A0
00000B9C  5350      1759          subq.w    #1,(A0)
                    1760   ; *pevents_rdy++ = pevent;            /* ... and return available queue event        */
00000B9E  2045      1761          move.l    D5,A0
00000BA0  5885      1762          addq.l    #4,D5
00000BA2  2082      1763          move.l    D2,(A0)
                    1764   ; events_rdy   = OS_TRUE;
00000BA4  1D7C 0001 1765          move.b    #1,-2(A6)
00000BA8  FFFE      
                    1766   ; events_rdy_nbr++;
00000BAA  5243      1767          addq.w    #1,D3
00000BAC  6006      1768          bra.s     OSEventPendMulti_35
                    1769   OSEventPendMulti_34:
                    1770   ; } else {
                    1771   ; events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
00000BAE  002E 0004 1772          or.b      #4,-1(A6)
00000BB2  FFFF      
                    1773   OSEventPendMulti_35:
                    1774   ; }
                    1775   ; break;
00000BB4  6012      1776          bra.s     OSEventPendMulti_22
                    1777   OSEventPendMulti_27:
                    1778   ; #endif
                    1779   ; case OS_EVENT_TYPE_MUTEX:
                    1780   ; case OS_EVENT_TYPE_FLAG:
                    1781   ; default:
                    1782   ; OS_EXIT_CRITICAL();
00000BB6  46DF      1783          dc.w      18143
                    1784   ; *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
00000BB8  2045      1785          move.l    D5,A0
00000BBA  4290      1786          clr.l     (A0)
                    1787   ; *perr        =  OS_ERR_EVENT_TYPE;
00000BBC  2044      1788          move.l    D4,A0
00000BBE  10BC 0001 1789          move.b    #1,(A0)
                    1790   ; return (events_rdy_nbr);
00000BC2  3003      1791          move.w    D3,D0
00000BC4  6000 0170 1792          bra       OSEventPendMulti_13
                    1793   OSEventPendMulti_22:
                    1794   ; }
                    1795   ; pevents++;
00000BC8  5887      1796          addq.l    #4,D7
                    1797   ; pevent = *pevents;
00000BCA  2047      1798          move.l    D7,A0
00000BCC  2410      1799          move.l    (A0),D2
00000BCE  6000 FEF4 1800          bra       OSEventPendMulti_18
                    1801   OSEventPendMulti_20:
                    1802   ; }
                    1803   ; if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
00000BD2  102E FFFE 1804          move.b    -2(A6),D0
00000BD6  0C00 0001 1805          cmp.b     #1,D0
00000BDA  6610      1806          bne.s     OSEventPendMulti_38
                    1807   ; *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
00000BDC  2045      1808          move.l    D5,A0
00000BDE  4290      1809          clr.l     (A0)
                    1810   ; OS_EXIT_CRITICAL();
00000BE0  46DF      1811          dc.w      18143
                    1812   ; *perr        =  OS_ERR_NONE;
00000BE2  2044      1813          move.l    D4,A0
00000BE4  4210      1814          clr.b     (A0)
                    1815   ; return (events_rdy_nbr);
00000BE6  3003      1816          move.w    D3,D0
00000BE8  6000 014C 1817          bra       OSEventPendMulti_13
                    1818   OSEventPendMulti_38:
                    1819   ; }
                    1820   ; /*$PAGE*/
                    1821   ; /* Otherwise, must wait until any event occurs */
                    1822   ; OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
00000BEC  2052      1823          move.l    (A2),A0
00000BEE  102E FFFF 1824          move.b    -1(A6),D0
00000BF2  803C 0080 1825          or.b      #128,D0
00000BF6  8128 0032 1826          or.b      D0,50(A0)
                    1827   ; OS_STAT_MULTI;           /* ... pend on multiple events                 */
                    1828   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00000BFA  2052      1829          move.l    (A2),A0
00000BFC  4228 0033 1830          clr.b     51(A0)
                    1831   ; OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
00000C00  2052      1832          move.l    (A2),A0
00000C02  216E 0014 1833          move.l    20(A6),46(A0)
00000C06  002E      
                    1834   ; OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
00000C08  2F0C      1835          move.l    A4,-(A7)
00000C0A  4EB9 0000 1836          jsr       _OS_EventTaskWaitMulti
00000C0E  1162      
00000C10  584F      1837          addq.w    #4,A7
                    1838   ; OS_EXIT_CRITICAL();
00000C12  46DF      1839          dc.w      18143
                    1840   ; OS_Sched();                                         /* Find next highest priority task ready       */
00000C14  4EB9 0000 1841          jsr       _OS_Sched
00000C18  15DA      
                    1842   ; OS_ENTER_CRITICAL();
00000C1A  40E7      1843          dc.w      16615
00000C1C  007C      1844          dc.w      124
00000C1E  0700      1845          dc.w      1792
                    1846   ; switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
00000C20  2052      1847          move.l    (A2),A0
00000C22  1028 0033 1848          move.b    51(A0),D0
00000C26  C0BC 0000 1849          and.l     #255,D0
00000C2A  00FF      
00000C2C  0C80 0000 1850          cmp.l     #1,D0
00000C30  0001      
00000C32  6700 0046 1851          beq       OSEventPendMulti_44
00000C36  6208      1852          bhi.s     OSEventPendMulti_46
00000C38  4A80      1853          tst.l     D0
00000C3A  6710      1854          beq.s     OSEventPendMulti_42
00000C3C  6000 003C 1855          bra       OSEventPendMulti_44
                    1856   OSEventPendMulti_46:
00000C40  0C80 0000 1857          cmp.l     #2,D0
00000C44  0002      
00000C46  6704      1858          beq.s     OSEventPendMulti_42
00000C48  6000 0030 1859          bra       OSEventPendMulti_44
                    1860   OSEventPendMulti_42:
                    1861   ; case OS_STAT_PEND_OK:
                    1862   ; case OS_STAT_PEND_ABORT:
                    1863   ; pevent = OSTCBCur->OSTCBEventPtr;
00000C4C  2052      1864          move.l    (A2),A0
00000C4E  2428 001C 1865          move.l    28(A0),D2
                    1866   ; if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
00000C52  4A82      1867          tst.l     D2
00000C54  670E      1868          beq.s     OSEventPendMulti_47
                    1869   ; *pevents_rdy++   =  pevent;             /* ... return available event ...              */
00000C56  2045      1870          move.l    D5,A0
00000C58  5885      1871          addq.l    #4,D5
00000C5A  2082      1872          move.l    D2,(A0)
                    1873   ; *pevents_rdy     = (OS_EVENT *)0;       /* ... & NULL terminate return event array     */
00000C5C  2045      1874          move.l    D5,A0
00000C5E  4290      1875          clr.l     (A0)
                    1876   ; events_rdy_nbr =  1;
00000C60  7601      1877          moveq     #1,D3
00000C62  6014      1878          bra.s     OSEventPendMulti_48
                    1879   OSEventPendMulti_47:
                    1880   ; } else {                                   /* Else NO event available, handle as timeout  */
                    1881   ; OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
00000C64  2052      1882          move.l    (A2),A0
00000C66  117C 0001 1883          move.b    #1,51(A0)
00000C6A  0033      
                    1884   ; OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
00000C6C  2F0C      1885          move.l    A4,-(A7)
00000C6E  2F12      1886          move.l    (A2),-(A7)
00000C70  4EB9 0000 1887          jsr       _OS_EventTaskRemoveMulti
00000C74  1252      
00000C76  504F      1888          addq.w    #8,A7
                    1889   OSEventPendMulti_48:
                    1890   ; }
                    1891   ; break;
00000C78  600C      1892          bra.s     OSEventPendMulti_41
                    1893   OSEventPendMulti_44:
                    1894   ; case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
                    1895   ; default:                                        /* ... remove task from events' wait lists     */
                    1896   ; OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
00000C7A  2F0C      1897          move.l    A4,-(A7)
00000C7C  2F12      1898          move.l    (A2),-(A7)
00000C7E  4EB9 0000 1899          jsr       _OS_EventTaskRemoveMulti
00000C82  1252      
00000C84  504F      1900          addq.w    #8,A7
                    1901   ; break;
                    1902   OSEventPendMulti_41:
                    1903   ; }
                    1904   ; switch (OSTCBCur->OSTCBStatPend) {
00000C86  2052      1905          move.l    (A2),A0
00000C88  1028 0033 1906          move.b    51(A0),D0
00000C8C  C0BC 0000 1907          and.l     #255,D0
00000C90  00FF      
00000C92  0C80 0000 1908          cmp.l     #1,D0
00000C96  0001      
00000C98  6700 0072 1909          beq       OSEventPendMulti_53
00000C9C  6208      1910          bhi.s     OSEventPendMulti_55
00000C9E  4A80      1911          tst.l     D0
00000CA0  6712      1912          beq.s     OSEventPendMulti_51
00000CA2  6000 0068 1913          bra       OSEventPendMulti_53
                    1914   OSEventPendMulti_55:
00000CA6  0C80 0000 1915          cmp.l     #2,D0
00000CAA  0002      
00000CAC  6700 0054 1916          beq       OSEventPendMulti_52
00000CB0  6000 005A 1917          bra       OSEventPendMulti_53
                    1918   OSEventPendMulti_51:
                    1919   ; case OS_STAT_PEND_OK:
                    1920   ; switch (pevent->OSEventType) {             /* Return event's message                      */
00000CB4  2042      1921          move.l    D2,A0
00000CB6  1010      1922          move.b    (A0),D0
00000CB8  C0BC 0000 1923          and.l     #255,D0
00000CBC  00FF      
00000CBE  5380      1924          subq.l    #1,D0
00000CC0  6528      1925          blo.s     OSEventPendMulti_62
00000CC2  0C80 0000 1926          cmp.l     #5,D0
00000CC6  0005      
00000CC8  6420      1927          bhs.s     OSEventPendMulti_62
00000CCA  E380      1928          asl.l     #1,D0
00000CCC  303B 0806 1929          move.w    OSEventPendMulti_58(PC,D0.L),D0
00000CD0  4EFB 0002 1930          jmp       OSEventPendMulti_58(PC,D0.W)
                    1931   OSEventPendMulti_58:
00000CD4  000E      1932          dc.w      OSEventPendMulti_60-OSEventPendMulti_58
00000CD6  000E      1933          dc.w      OSEventPendMulti_60-OSEventPendMulti_58
00000CD8  000A      1934          dc.w      OSEventPendMulti_59-OSEventPendMulti_58
00000CDA  0016      1935          dc.w      OSEventPendMulti_62-OSEventPendMulti_58
00000CDC  0016      1936          dc.w      OSEventPendMulti_62-OSEventPendMulti_58
                    1937   OSEventPendMulti_59:
                    1938   ; #if (OS_SEM_EN > 0u)
                    1939   ; case OS_EVENT_TYPE_SEM:
                    1940   ; *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
00000CDE  429B      1941          clr.l     (A3)+
                    1942   ; break;
00000CE0  601A      1943          bra.s     OSEventPendMulti_57
                    1944   OSEventPendMulti_60:
                    1945   ; #endif
                    1946   ; #if ((OS_MBOX_EN > 0u) ||                 \
                    1947   ; ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
                    1948   ; case OS_EVENT_TYPE_MBOX:
                    1949   ; case OS_EVENT_TYPE_Q:
                    1950   ; *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
00000CE2  2052      1951          move.l    (A2),A0
00000CE4  26E8 0024 1952          move.l    36(A0),(A3)+
                    1953   ; break;
00000CE8  6012      1954          bra.s     OSEventPendMulti_57
                    1955   OSEventPendMulti_62:
                    1956   ; #endif
                    1957   ; case OS_EVENT_TYPE_MUTEX:
                    1958   ; case OS_EVENT_TYPE_FLAG:
                    1959   ; default:
                    1960   ; OS_EXIT_CRITICAL();
00000CEA  46DF      1961          dc.w      18143
                    1962   ; *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
00000CEC  2045      1963          move.l    D5,A0
00000CEE  4290      1964          clr.l     (A0)
                    1965   ; *perr        =  OS_ERR_EVENT_TYPE;
00000CF0  2044      1966          move.l    D4,A0
00000CF2  10BC 0001 1967          move.b    #1,(A0)
                    1968   ; return (events_rdy_nbr);
00000CF6  3003      1969          move.w    D3,D0
00000CF8  6000 003C 1970          bra       OSEventPendMulti_13
                    1971   OSEventPendMulti_57:
                    1972   ; }
                    1973   ; *perr = OS_ERR_NONE;
00000CFC  2044      1974          move.l    D4,A0
00000CFE  4210      1975          clr.b     (A0)
                    1976   ; break;
00000D00  6012      1977          bra.s     OSEventPendMulti_50
                    1978   OSEventPendMulti_52:
                    1979   ; case OS_STAT_PEND_ABORT:
                    1980   ; *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
00000D02  429B      1981          clr.l     (A3)+
                    1982   ; *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
00000D04  2044      1983          move.l    D4,A0
00000D06  10BC 000E 1984          move.b    #14,(A0)
                    1985   ; break;
00000D0A  6008      1986          bra.s     OSEventPendMulti_50
                    1987   OSEventPendMulti_53:
                    1988   ; case OS_STAT_PEND_TO:
                    1989   ; default:
                    1990   ; *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
00000D0C  429B      1991          clr.l     (A3)+
                    1992   ; *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
00000D0E  2044      1993          move.l    D4,A0
00000D10  10BC 000A 1994          move.b    #10,(A0)
                    1995   ; break;
                    1996   OSEventPendMulti_50:
                    1997   ; }
                    1998   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
00000D14  2052      1999          move.l    (A2),A0
00000D16  4228 0032 2000          clr.b     50(A0)
                    2001   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
00000D1A  2052      2002          move.l    (A2),A0
00000D1C  4228 0033 2003          clr.b     51(A0)
                    2004   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
00000D20  2052      2005          move.l    (A2),A0
00000D22  42A8 001C 2006          clr.l     28(A0)
                    2007   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
00000D26  2052      2008          move.l    (A2),A0
00000D28  42A8 0020 2009          clr.l     32(A0)
                    2010   ; #if ((OS_MBOX_EN > 0u) ||                 \
                    2011   ; ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
                    2012   ; OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
00000D2C  2052      2013          move.l    (A2),A0
00000D2E  42A8 0024 2014          clr.l     36(A0)
                    2015   ; #endif
                    2016   ; OS_EXIT_CRITICAL();
00000D32  46DF      2017          dc.w      18143
                    2018   ; return (events_rdy_nbr);
00000D34  3003      2019          move.w    D3,D0
                    2020   OSEventPendMulti_13:
00000D36  4CDF 1CFC 2021          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4
00000D3A  4E5E      2022          unlk      A6
00000D3C  4E75      2023          rts
                    2024   ; }
                    2025   ; #endif
                    2026   ; /*$PAGE*/
                    2027   ; /*
                    2028   ; *********************************************************************************************************
                    2029   ; *                                           INITIALIZATION
                    2030   ; *
                    2031   ; * Description: This function is used to initialize the internals of uC/OS-II and MUST be called prior to
                    2032   ; *              creating any uC/OS-II object and, prior to calling OSStart().
                    2033   ; *
                    2034   ; * Arguments  : none
                    2035   ; *
                    2036   ; * Returns    : none
                    2037   ; *********************************************************************************************************
                    2038   ; */
                    2039   ; void  OSInit (void)
                    2040   ; {
                    2041   _OSInit:
                    2042   ; OSInitHookBegin();                                           /* Call port specific initialization code   */
00000D3E  4EB8 08B4 2043          jsr       _OSInitHookBegin
                    2044   ; OS_InitMisc();                                               /* Initialize miscellaneous variables       */
00000D42  4EB9 0000 2045          jsr       @ucos_ii_OS_InitMisc
00000D46  139A      
                    2046   ; OS_InitRdyList();                                            /* Initialize the Ready List                */
00000D48  4EB9 0000 2047          jsr       @ucos_ii_OS_InitRdyList
00000D4C  13DE      
                    2048   ; OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
00000D4E  4EB9 0000 2049          jsr       @ucos_ii_OS_InitTCBList
00000D52  14D6      
                    2050   ; OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
00000D54  4EB9 0000 2051          jsr       @ucos_ii_OS_InitEventList
00000D58  12F2      
                    2052   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    2053   ; OS_FlagInit();                                               /* Initialize the event flag structures     */
00000D5A  4EB9 0000 2054          jsr       _OS_FlagInit
00000D5E  22E8      
                    2055   ; #endif
                    2056   ; #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
                    2057   ; OS_MemInit();                                                /* Initialize the memory manager            */
00000D60  4EB9 0000 2058          jsr       _OS_MemInit
00000D64  2BA6      
                    2059   ; #endif
                    2060   ; #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
                    2061   ; OS_QInit();                                                  /* Initialize the message queue structures  */
00000D66  4EB9 0000 2062          jsr       _OS_QInit
00000D6A  3D0C      
                    2063   ; #endif
                    2064   ; OS_InitTaskIdle();                                           /* Create the Idle Task                     */
00000D6C  4EB9 0000 2065          jsr       @ucos_ii_OS_InitTaskIdle
00000D70  141E      
                    2066   ; #if OS_TASK_STAT_EN > 0u
                    2067   ; OS_InitTaskStat();                                           /* Create the Statistic Task                */
00000D72  4EB9 0000 2068          jsr       @ucos_ii_OS_InitTaskStat
00000D76  147A      
                    2069   ; #endif
                    2070   ; #if OS_TMR_EN > 0u
                    2071   ; OSTmr_Init();                                                /* Initialize the Timer Manager             */
00000D78  4EB9 0000 2072          jsr       _OSTmr_Init
00000D7C  565E      
                    2073   ; #endif
                    2074   ; OSInitHookEnd();                                             /* Call port specific init. code            */
00000D7E  4EB8 08B6 2075          jsr       _OSInitHookEnd
00000D82  4E75      2076          rts
                    2077   ; #if OS_DEBUG_EN > 0u
                    2078   ; OSDebugInit();
                    2079   ; #endif
                    2080   ; }
                    2081   ; /*$PAGE*/
                    2082   ; /*
                    2083   ; *********************************************************************************************************
                    2084   ; *                                              ENTER ISR
                    2085   ; *
                    2086   ; * Description: This function is used to notify uC/OS-II that you are about to service an interrupt
                    2087   ; *              service routine (ISR).  This allows uC/OS-II to keep track of interrupt nesting and thus
                    2088   ; *              only perform rescheduling at the last nested ISR.
                    2089   ; *
                    2090   ; * Arguments  : none
                    2091   ; *
                    2092   ; * Returns    : none
                    2093   ; *
                    2094   ; * Notes      : 1) This function should be called with interrupts already disabled
                    2095   ; *              2) Your ISR can directly increment OSIntNesting without calling this function because
                    2096   ; *                 OSIntNesting has been declared 'global'.
                    2097   ; *              3) You MUST still call OSIntExit() even though you increment OSIntNesting directly.
                    2098   ; *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
                    2099   ; *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
                    2100   ; *                 end of the ISR.
                    2101   ; *              5) You are allowed to nest interrupts up to 255 levels deep.
                    2102   ; *              6) I removed the OS_ENTER_CRITICAL() and OS_EXIT_CRITICAL() around the increment because
                    2103   ; *                 OSIntEnter() is always called with interrupts disabled.
                    2104   ; *********************************************************************************************************
                    2105   ; */
                    2106   ; void  OSIntEnter (void)
                    2107   ; {
                    2108   _OSIntEnter:
                    2109   ; if (OSRunning == OS_TRUE) {
00000D84  1039 0800 2110          move.b    _OSRunning.L,D0
00000D88  0320      
00000D8A  0C00 0001 2111          cmp.b     #1,D0
00000D8E  6612      2112          bne.s     OSIntEnter_3
                    2113   ; if (OSIntNesting < 255u) {
00000D90  1039 0800 2114          move.b    _OSIntNesting.L,D0
00000D94  030E      
00000D96  0C00 00FF 2115          cmp.b     #255,D0
00000D9A  6406      2116          bhs.s     OSIntEnter_3
                    2117   ; OSIntNesting++;                      /* Increment ISR nesting level                        */
00000D9C  5239 0800 2118          addq.b    #1,_OSIntNesting.L
00000DA0  030E      
                    2119   OSIntEnter_3:
00000DA2  4E75      2120          rts
                    2121   ; }
                    2122   ; }
                    2123   ; }
                    2124   ; /*$PAGE*/
                    2125   ; /*
                    2126   ; *********************************************************************************************************
                    2127   ; *                                              EXIT ISR
                    2128   ; *
                    2129   ; * Description: This function is used to notify uC/OS-II that you have completed servicing an ISR.  When
                    2130   ; *              the last nested ISR has completed, uC/OS-II will call the scheduler to determine whether
                    2131   ; *              a new, high-priority task, is ready to run.
                    2132   ; *
                    2133   ; * Arguments  : none
                    2134   ; *
                    2135   ; * Returns    : none
                    2136   ; *
                    2137   ; * Notes      : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
                    2138   ; *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
                    2139   ; *                 end of the ISR.
                    2140   ; *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
                    2141   ; *********************************************************************************************************
                    2142   ; */
                    2143   ; void  OSIntExit (void)
                    2144   ; {
                    2145   _OSIntExit:
                    2146   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    2147   ; OS_CPU_SR  cpu_sr = 0u;
                    2148   ; #endif
                    2149   ; if (OSRunning == OS_TRUE) {
00000DA4  1039 0800 2150          move.b    _OSRunning.L,D0
00000DA8  0320      
00000DAA  0C00 0001 2151          cmp.b     #1,D0
00000DAE  6600 0078 2152          bne       OSIntExit_1
                    2153   ; OS_ENTER_CRITICAL();
00000DB2  40E7      2154          dc.w      16615
00000DB4  007C      2155          dc.w      124
00000DB6  0700      2156          dc.w      1792
                    2157   ; if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
00000DB8  1039 0800 2158          move.b    _OSIntNesting.L,D0
00000DBC  030E      
00000DBE  0C00 0000 2159          cmp.b     #0,D0
00000DC2  6306      2160          bls.s     OSIntExit_3
                    2161   ; OSIntNesting--;
00000DC4  5339 0800 2162          subq.b    #1,_OSIntNesting.L
00000DC8  030E      
                    2163   OSIntExit_3:
                    2164   ; }
                    2165   ; if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
00000DCA  1039 0800 2166          move.b    _OSIntNesting.L,D0
00000DCE  030E      
00000DD0  6600 0054 2167          bne       OSIntExit_9
                    2168   ; if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
00000DD4  1039 0800 2169          move.b    _OSLockNesting.L,D0
00000DD8  0310      
00000DDA  664A      2170          bne.s     OSIntExit_9
                    2171   ; OS_SchedNew();
00000DDC  4EB9 0000 2172          jsr       @ucos_ii_OS_SchedNew
00000DE0  163E      
                    2173   ; OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
00000DE2  1039 0800 2174          move.b    _OSPrioHighRdy.L,D0
00000DE6  0314      
00000DE8  C0BC 0000 2175          and.l     #255,D0
00000DEC  00FF      
00000DEE  E588      2176          lsl.l     #2,D0
00000DF0  41F9 0800 2177          lea       _OSTCBPrioTbl.L,A0
00000DF4  0438      
00000DF6  23F0 0800 2178          move.l    0(A0,D0.L),_OSTCBHighRdy.L
00000DFA  0800 0430 
                    2179   ; if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
00000DFE  1039 0800 2180          move.b    _OSPrioHighRdy.L,D0
00000E02  0314      
00000E04  B039 0800 2181          cmp.b     _OSPrioCur.L,D0
00000E08  0312      
00000E0A  671A      2182          beq.s     OSIntExit_9
                    2183   ; #if OS_TASK_PROFILE_EN > 0u
                    2184   ; OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
00000E0C  2039 0800 2185          move.l    _OSTCBHighRdy.L,D0
00000E10  0430      
00000E12  0680 0000 2186          add.l     #58,D0
00000E16  003A      
00000E18  2040      2187          move.l    D0,A0
00000E1A  5290      2188          addq.l    #1,(A0)
                    2189   ; #endif
                    2190   ; OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
00000E1C  52B9 0800 2191          addq.l    #1,_OSCtxSwCtr.L
00000E20  00DE      
                    2192   ; OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
00000E22  4EB8 06E2 2193          jsr       _OSIntCtxSw
                    2194   OSIntExit_9:
                    2195   ; }
                    2196   ; }
                    2197   ; }
                    2198   ; OS_EXIT_CRITICAL();
00000E26  46DF      2199          dc.w      18143
                    2200   OSIntExit_1:
00000E28  4E75      2201          rts
                    2202   ; }
                    2203   ; }
                    2204   ; /*$PAGE*/
                    2205   ; /*
                    2206   ; *********************************************************************************************************
                    2207   ; *                         INDICATE THAT IT'S NO LONGER SAFE TO CREATE OBJECTS
                    2208   ; *
                    2209   ; * Description: This function is called by the application code to indicate that all initialization has
                    2210   ; *              been completed and that kernel objects are no longer allowed to be created.
                    2211   ; *
                    2212   ; * Arguments  : none
                    2213   ; *
                    2214   ; * Returns    : none
                    2215   ; *
                    2216   ; * Note(s)    : 1) You should call this function when you no longer want to allow application code to
                    2217   ; *                 create kernel objects.
                    2218   ; *              2) You need to define the macro 'OS_SAFETY_CRITICAL_IEC61508'
                    2219   ; *********************************************************************************************************
                    2220   ; */
                    2221   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    2222   ; void  OSSafetyCriticalStart (void)
                    2223   ; {
                    2224   ; OSSafetyCriticalStartFlag = OS_TRUE;
                    2225   ; }
                    2226   ; #endif
                    2227   ; /*$PAGE*/
                    2228   ; /*
                    2229   ; *********************************************************************************************************
                    2230   ; *                                         PREVENT SCHEDULING
                    2231   ; *
                    2232   ; * Description: This function is used to prevent rescheduling to take place.  This allows your application
                    2233   ; *              to prevent context switches until you are ready to permit context switching.
                    2234   ; *
                    2235   ; * Arguments  : none
                    2236   ; *
                    2237   ; * Returns    : none
                    2238   ; *
                    2239   ; * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
                    2240   ; *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
                    2241   ; *********************************************************************************************************
                    2242   ; */
                    2243   ; #if OS_SCHED_LOCK_EN > 0u
                    2244   ; void  OSSchedLock (void)
                    2245   ; {
                    2246   _OSSchedLock:
                    2247   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    2248   ; OS_CPU_SR  cpu_sr = 0u;
                    2249   ; #endif
                    2250   ; if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
00000E2A  1039 0800 2251          move.b    _OSRunning.L,D0
00000E2E  0320      
00000E30  0C00 0001 2252          cmp.b     #1,D0
00000E34  6622      2253          bne.s     OSSchedLock_1
                    2254   ; OS_ENTER_CRITICAL();
00000E36  40E7      2255          dc.w      16615
00000E38  007C      2256          dc.w      124
00000E3A  0700      2257          dc.w      1792
                    2258   ; if (OSIntNesting == 0u) {                /* Can't call from an ISR                             */
00000E3C  1039 0800 2259          move.b    _OSIntNesting.L,D0
00000E40  030E      
00000E42  6612      2260          bne.s     OSSchedLock_5
                    2261   ; if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
00000E44  1039 0800 2262          move.b    _OSLockNesting.L,D0
00000E48  0310      
00000E4A  0C00 00FF 2263          cmp.b     #255,D0
00000E4E  6406      2264          bhs.s     OSSchedLock_5
                    2265   ; OSLockNesting++;                 /* Increment lock nesting level                       */
00000E50  5239 0800 2266          addq.b    #1,_OSLockNesting.L
00000E54  0310      
                    2267   OSSchedLock_5:
                    2268   ; }
                    2269   ; }
                    2270   ; OS_EXIT_CRITICAL();
00000E56  46DF      2271          dc.w      18143
                    2272   OSSchedLock_1:
00000E58  4E75      2273          rts
                    2274   ; }
                    2275   ; }
                    2276   ; #endif
                    2277   ; /*$PAGE*/
                    2278   ; /*
                    2279   ; *********************************************************************************************************
                    2280   ; *                                          ENABLE SCHEDULING
                    2281   ; *
                    2282   ; * Description: This function is used to re-allow rescheduling.
                    2283   ; *
                    2284   ; * Arguments  : none
                    2285   ; *
                    2286   ; * Returns    : none
                    2287   ; *
                    2288   ; * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
                    2289   ; *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
                    2290   ; *********************************************************************************************************
                    2291   ; */
                    2292   ; #if OS_SCHED_LOCK_EN > 0u
                    2293   ; void  OSSchedUnlock (void)
                    2294   ; {
                    2295   _OSSchedUnlock:
                    2296   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    2297   ; OS_CPU_SR  cpu_sr = 0u;
                    2298   ; #endif
                    2299   ; if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
00000E5A  1039 0800 2300          move.b    _OSRunning.L,D0
00000E5E  0320      
00000E60  0C00 0001 2301          cmp.b     #1,D0
00000E64  6600 003E 2302          bne       OSSchedUnlock_4
                    2303   ; OS_ENTER_CRITICAL();
00000E68  40E7      2304          dc.w      16615
00000E6A  007C      2305          dc.w      124
00000E6C  0700      2306          dc.w      1792
                    2307   ; if (OSIntNesting == 0u) {                          /* Can't call from an ISR                   */
00000E6E  1039 0800 2308          move.b    _OSIntNesting.L,D0
00000E72  030E      
00000E74  662C      2309          bne.s     OSSchedUnlock_3
                    2310   ; if (OSLockNesting > 0u) {                      /* Do not decrement if already 0            */
00000E76  1039 0800 2311          move.b    _OSLockNesting.L,D0
00000E7A  0310      
00000E7C  0C00 0000 2312          cmp.b     #0,D0
00000E80  631C      2313          bls.s     OSSchedUnlock_5
                    2314   ; OSLockNesting--;                           /* Decrement lock nesting level             */
00000E82  5339 0800 2315          subq.b    #1,_OSLockNesting.L
00000E86  0310      
                    2316   ; if (OSLockNesting == 0u) {                 /* See if scheduler is enabled              */
00000E88  1039 0800 2317          move.b    _OSLockNesting.L,D0
00000E8C  0310      
00000E8E  660A      2318          bne.s     OSSchedUnlock_7
                    2319   ; OS_EXIT_CRITICAL();
00000E90  46DF      2320          dc.w      18143
                    2321   ; OS_Sched();                            /* See if a HPT is ready                    */
00000E92  4EB9 0000 2322          jsr       _OS_Sched
00000E96  15DA      
00000E98  6002      2323          bra.s     OSSchedUnlock_8
                    2324   OSSchedUnlock_7:
                    2325   ; } else {
                    2326   ; OS_EXIT_CRITICAL();
00000E9A  46DF      2327          dc.w      18143
                    2328   OSSchedUnlock_8:
00000E9C  6002      2329          bra.s     OSSchedUnlock_6
                    2330   OSSchedUnlock_5:
                    2331   ; }
                    2332   ; } else {
                    2333   ; OS_EXIT_CRITICAL();
00000E9E  46DF      2334          dc.w      18143
                    2335   OSSchedUnlock_6:
00000EA0  6002      2336          bra.s     OSSchedUnlock_4
                    2337   OSSchedUnlock_3:
                    2338   ; }
                    2339   ; } else {
                    2340   ; OS_EXIT_CRITICAL();
00000EA2  46DF      2341          dc.w      18143
                    2342   OSSchedUnlock_4:
00000EA4  4E75      2343          rts
                    2344   ; }
                    2345   ; }
                    2346   ; }
                    2347   ; #endif
                    2348   ; /*$PAGE*/
                    2349   ; /*
                    2350   ; *********************************************************************************************************
                    2351   ; *                                         START MULTITASKING
                    2352   ; *
                    2353   ; * Description: This function is used to start the multitasking process which lets uC/OS-II manages the
                    2354   ; *              task that you have created.  Before you can call OSStart(), you MUST have called OSInit()
                    2355   ; *              and you MUST have created at least one task.
                    2356   ; *
                    2357   ; * Arguments  : none
                    2358   ; *
                    2359   ; * Returns    : none
                    2360   ; *
                    2361   ; * Note       : OSStartHighRdy() MUST:
                    2362   ; *                 a) Call OSTaskSwHook() then,
                    2363   ; *                 b) Set OSRunning to OS_TRUE.
                    2364   ; *                 c) Load the context of the task pointed to by OSTCBHighRdy.
                    2365   ; *                 d_ Execute the task.
                    2366   ; *********************************************************************************************************
                    2367   ; */
                    2368   ; void  OSStart (void)
                    2369   ; {
                    2370   _OSStart:
                    2371   ; if (OSRunning == OS_FALSE) {
00000EA6  1039 0800 2372          move.b    _OSRunning.L,D0
00000EAA  0320      
00000EAC  663A      2373          bne.s     OSStart_1
                    2374   ; OS_SchedNew();                               /* Find highest priority's task priority number   */
00000EAE  4EB9 0000 2375          jsr       @ucos_ii_OS_SchedNew
00000EB2  163E      
                    2376   ; OSPrioCur     = OSPrioHighRdy;
00000EB4  13F9 0800 2377          move.b    _OSPrioHighRdy.L,_OSPrioCur.L
00000EB8  0314 0800 
00000EBC  0312      
                    2378   ; OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
00000EBE  1039 0800 2379          move.b    _OSPrioHighRdy.L,D0
00000EC2  0314      
00000EC4  C0BC 0000 2380          and.l     #255,D0
00000EC8  00FF      
00000ECA  E588      2381          lsl.l     #2,D0
00000ECC  41F9 0800 2382          lea       _OSTCBPrioTbl.L,A0
00000ED0  0438      
00000ED2  23F0 0800 2383          move.l    0(A0,D0.L),_OSTCBHighRdy.L
00000ED6  0800 0430 
                    2384   ; OSTCBCur      = OSTCBHighRdy;
00000EDA  23F9 0800 2385          move.l    _OSTCBHighRdy.L,_OSTCBCur.L
00000EDE  0430 0800 
00000EE2  0428      
                    2386   ; OSStartHighRdy();                            /* Execute target specific code to start task     */
00000EE4  4EB8 0698 2387          jsr       _OSStartHighRdy
                    2388   OSStart_1:
00000EE8  4E75      2389          rts
                    2390   ; }
                    2391   ; }
                    2392   ; /*$PAGE*/
                    2393   ; /*
                    2394   ; *********************************************************************************************************
                    2395   ; *                                      STATISTICS INITIALIZATION
                    2396   ; *
                    2397   ; * Description: This function is called by your application to establish CPU usage by first determining
                    2398   ; *              how high a 32-bit counter would count to in 1 second if no other tasks were to execute
                    2399   ; *              during that time.  CPU usage is then determined by a low priority task which keeps track
                    2400   ; *              of this 32-bit counter every second but this time, with other tasks running.  CPU usage is
                    2401   ; *              determined by:
                    2402   ; *
                    2403   ; *                                             OSIdleCtr
                    2404   ; *                 CPU Usage (%) = 100 * (1 - ------------)
                    2405   ; *                                            OSIdleCtrMax
                    2406   ; *
                    2407   ; * Arguments  : none
                    2408   ; *
                    2409   ; * Returns    : none
                    2410   ; *********************************************************************************************************
                    2411   ; */
                    2412   ; #if OS_TASK_STAT_EN > 0u
                    2413   ; void  OSStatInit (void)
                    2414   ; {
                    2415   _OSStatInit:
                    2416   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    2417   ; OS_CPU_SR  cpu_sr = 0u;
                    2418   ; #endif
                    2419   ; OSTimeDly(2u);                               /* Synchronize with clock tick                        */
00000EEA  4878 0002 2420          pea       2
00000EEE  4EB9 0000 2421          jsr       _OSTimeDly
00000EF2  4DD6      
00000EF4  584F      2422          addq.w    #4,A7
                    2423   ; OS_ENTER_CRITICAL();
00000EF6  40E7      2424          dc.w      16615
00000EF8  007C      2425          dc.w      124
00000EFA  0700      2426          dc.w      1792
                    2427   ; OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
00000EFC  42B9 0800 2428          clr.l     _OSIdleCtr.L
00000F00  0324      
                    2429   ; OS_EXIT_CRITICAL();
00000F02  46DF      2430          dc.w      18143
                    2431   ; OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
00000F04  4878 000A 2432          pea       10
00000F08  4EB9 0000 2433          jsr       _OSTimeDly
00000F0C  4DD6      
00000F0E  584F      2434          addq.w    #4,A7
                    2435   ; OS_ENTER_CRITICAL();
00000F10  40E7      2436          dc.w      16615
00000F12  007C      2437          dc.w      124
00000F14  0700      2438          dc.w      1792
                    2439   ; OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
00000F16  23F9 0800 2440          move.l    _OSIdleCtr.L,_OSIdleCtrMax.L
00000F1A  0324 0800 
00000F1E  0204      
                    2441   ; OSStatRdy    = OS_TRUE;
00000F20  13FC 0001 2442          move.b    #1,_OSStatRdy.L
00000F24  0800 020C 
                    2443   ; OS_EXIT_CRITICAL();
00000F28  46DF      2444          dc.w      18143
00000F2A  4E75      2445          rts
                    2446   ; }
                    2447   ; #endif
                    2448   ; /*$PAGE*/
                    2449   ; /*
                    2450   ; *********************************************************************************************************
                    2451   ; *                                         PROCESS SYSTEM TICK
                    2452   ; *
                    2453   ; * Description: This function is used to signal to uC/OS-II the occurrence of a 'system tick' (also known
                    2454   ; *              as a 'clock tick').  This function should be called by the ticker ISR but, can also be
                    2455   ; *              called by a high priority task.
                    2456   ; *
                    2457   ; * Arguments  : none
                    2458   ; *
                    2459   ; * Returns    : none
                    2460   ; *********************************************************************************************************
                    2461   ; */
                    2462   ; void  OSTimeTick (void)
                    2463   ; {
                    2464   _OSTimeTick:
00000F2C  2F02      2465          move.l    D2,-(A7)
                    2466   ; OS_TCB    *ptcb;
                    2467   ; #if OS_TICK_STEP_EN > 0u
                    2468   ; BOOLEAN    step;
                    2469   ; #endif
                    2470   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register     */
                    2471   ; OS_CPU_SR  cpu_sr = 0u;
                    2472   ; #endif
                    2473   ; #if OS_TIME_TICK_HOOK_EN > 0u
                    2474   ; OSTimeTickHook();                                      /* Call user definable hook                     */
00000F2E  4EB8 08DC 2475          jsr       _OSTimeTickHook
                    2476   ; #endif
                    2477   ; #if OS_TIME_GET_SET_EN > 0u
                    2478   ; OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
00000F32  40E7      2479          dc.w      16615
00000F34  007C      2480          dc.w      124
00000F36  0700      2481          dc.w      1792
                    2482   ; OSTime++;
00000F38  52B9 0800 2483          addq.l    #1,_OSTime.L
00000F3C  0D7E      
                    2484   ; OS_EXIT_CRITICAL();
00000F3E  46DF      2485          dc.w      18143
                    2486   ; #endif
                    2487   ; if (OSRunning == OS_TRUE) {
00000F40  1039 0800 2488          move.b    _OSRunning.L,D0
00000F44  0320      
00000F46  0C00 0001 2489          cmp.b     #1,D0
00000F4A  6600 00A2 2490          bne       OSTimeTick_5
                    2491   ; #if OS_TICK_STEP_EN > 0u
                    2492   ; switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
                    2493   ; case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                    2494   ; step = OS_TRUE;
                    2495   ; break;
                    2496   ; case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                    2497   ; step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
                    2498   ; break;
                    2499   ; case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                    2500   ; step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
                    2501   ; OSTickStepState = OS_TICK_STEP_WAIT;
                    2502   ; break;
                    2503   ; default:                                       /* Invalid case, correct situation              */
                    2504   ; step            = OS_TRUE;
                    2505   ; OSTickStepState = OS_TICK_STEP_DIS;
                    2506   ; break;
                    2507   ; }
                    2508   ; if (step == OS_FALSE) {                            /* Return if waiting for step command           */
                    2509   ; return;
                    2510   ; }
                    2511   ; #endif
                    2512   ; ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
00000F4E  2439 0800 2513          move.l    _OSTCBList.L,D2
00000F52  0434      
                    2514   ; while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
                    2515   OSTimeTick_3:
00000F54  2042      2516          move.l    D2,A0
00000F56  1028 0034 2517          move.b    52(A0),D0
00000F5A  0C00 003F 2518          cmp.b     #63,D0
00000F5E  6700 008E 2519          beq       OSTimeTick_5
                    2520   ; OS_ENTER_CRITICAL();
00000F62  40E7      2521          dc.w      16615
00000F64  007C      2522          dc.w      124
00000F66  0700      2523          dc.w      1792
                    2524   ; if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
00000F68  2042      2525          move.l    D2,A0
00000F6A  2028 002E 2526          move.l    46(A0),D0
00000F6E  6700 0072 2527          beq       OSTimeTick_12
                    2528   ; ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
00000F72  2002      2529          move.l    D2,D0
00000F74  0680 0000 2530          add.l     #46,D0
00000F78  002E      
00000F7A  2040      2531          move.l    D0,A0
00000F7C  5390      2532          subq.l    #1,(A0)
                    2533   ; if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
00000F7E  2042      2534          move.l    D2,A0
00000F80  2028 002E 2535          move.l    46(A0),D0
00000F84  6600 005C 2536          bne       OSTimeTick_12
                    2537   ; if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
00000F88  2042      2538          move.l    D2,A0
00000F8A  1028 0032 2539          move.b    50(A0),D0
00000F8E  C03C 0037 2540          and.b     #55,D0
00000F92  6714      2541          beq.s     OSTimeTick_10
                    2542   ; ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
00000F94  2042      2543          move.l    D2,A0
00000F96  7037      2544          moveq     #55,D0
00000F98  4600      2545          not.b     D0
00000F9A  C128 0032 2546          and.b     D0,50(A0)
                    2547   ; ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
00000F9E  2042      2548          move.l    D2,A0
00000FA0  117C 0001 2549          move.b    #1,51(A0)
00000FA4  0033      
00000FA6  6006      2550          bra.s     OSTimeTick_11
                    2551   OSTimeTick_10:
                    2552   ; } else {
                    2553   ; ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
00000FA8  2042      2554          move.l    D2,A0
00000FAA  4228 0033 2555          clr.b     51(A0)
                    2556   OSTimeTick_11:
                    2557   ; }
                    2558   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
00000FAE  2042      2559          move.l    D2,A0
00000FB0  1028 0032 2560          move.b    50(A0),D0
00000FB4  C03C 0008 2561          and.b     #8,D0
00000FB8  6628      2562          bne.s     OSTimeTick_12
                    2563   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
00000FBA  2042      2564          move.l    D2,A0
00000FBC  1028 0038 2565          move.b    56(A0),D0
00000FC0  8139 0800 2566          or.b      D0,_OSRdyGrp.L
00000FC4  0316      
                    2567   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00000FC6  2042      2568          move.l    D2,A0
00000FC8  1028 0036 2569          move.b    54(A0),D0
00000FCC  C0BC 0000 2570          and.l     #255,D0
00000FD0  00FF      
00000FD2  41F9 0800 2571          lea       _OSRdyTbl.L,A0
00000FD6  0318      
00000FD8  2242      2572          move.l    D2,A1
00000FDA  1229 0037 2573          move.b    55(A1),D1
00000FDE  8330 0800 2574          or.b      D1,0(A0,D0.L)
                    2575   OSTimeTick_12:
                    2576   ; }
                    2577   ; }
                    2578   ; }
                    2579   ; ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
00000FE2  2042      2580          move.l    D2,A0
00000FE4  2428 0014 2581          move.l    20(A0),D2
                    2582   ; OS_EXIT_CRITICAL();
00000FE8  46DF      2583          dc.w      18143
00000FEA  6000 FF68 2584          bra       OSTimeTick_3
                    2585   OSTimeTick_5:
00000FEE  241F      2586          move.l    (A7)+,D2
00000FF0  4E75      2587          rts
                    2588   ; }
                    2589   ; }
                    2590   ; }
                    2591   ; /*$PAGE*/
                    2592   ; /*
                    2593   ; *********************************************************************************************************
                    2594   ; *                                             GET VERSION
                    2595   ; *
                    2596   ; * Description: This function is used to return the version number of uC/OS-II.  The returned value 
                    2597   ; *              corresponds to uC/OS-II's version number multiplied by 10000.  In other words, version 
                    2598   ; *              2.01.00 would be returned as 20100.
                    2599   ; *
                    2600   ; * Arguments  : none
                    2601   ; *
                    2602   ; * Returns    : The version number of uC/OS-II multiplied by 10000.
                    2603   ; *********************************************************************************************************
                    2604   ; */
                    2605   ; INT16U  OSVersion (void)
                    2606   ; {
                    2607   _OSVersion:
                    2608   ; return (OS_VERSION);
00000FF2  303C 7217 2609          move.w    #29207,D0
00000FF6  4E75      2610          rts
                    2611   ; }
                    2612   ; /*$PAGE*/
                    2613   ; /*
                    2614   ; *********************************************************************************************************
                    2615   ; *                                           DUMMY FUNCTION
                    2616   ; *
                    2617   ; * Description: This function doesn't do anything.  It is called by OSTaskDel().
                    2618   ; *
                    2619   ; * Arguments  : none
                    2620   ; *
                    2621   ; * Returns    : none
                    2622   ; *********************************************************************************************************
                    2623   ; */
                    2624   ; #if OS_TASK_DEL_EN > 0u
                    2625   ; void  OS_Dummy (void)
                    2626   ; {
                    2627   _OS_Dummy:
00000FF8  4E75      2628          rts
                    2629   ; }
                    2630   ; #endif
                    2631   ; /*$PAGE*/
                    2632   ; /*
                    2633   ; *********************************************************************************************************
                    2634   ; *                           MAKE TASK READY TO RUN BASED ON EVENT OCCURING
                    2635   ; *
                    2636   ; * Description: This function is called by other uC/OS-II services and is used to ready a task that was
                    2637   ; *              waiting for an event to occur.
                    2638   ; *
                    2639   ; * Arguments  : pevent      is a pointer to the event control block corresponding to the event.
                    2640   ; *
                    2641   ; *              pmsg        is a pointer to a message.  This pointer is used by message oriented services
                    2642   ; *                          such as MAILBOXEs and QUEUEs.  The pointer is not used when called by other
                    2643   ; *                          service functions.
                    2644   ; *
                    2645   ; *              msk         is a mask that is used to clear the status byte of the TCB.  For example,
                    2646   ; *                          OSSemPost() will pass OS_STAT_SEM, OSMboxPost() will pass OS_STAT_MBOX etc.
                    2647   ; *
                    2648   ; *              pend_stat   is used to indicate the readied task's pending status:
                    2649   ; *
                    2650   ; *                          OS_STAT_PEND_OK      Task ready due to a post (or delete), not a timeout or
                    2651   ; *                                               an abort.
                    2652   ; *                          OS_STAT_PEND_ABORT   Task ready due to an abort.
                    2653   ; *
                    2654   ; * Returns    : none
                    2655   ; *
                    2656   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    2657   ; *********************************************************************************************************
                    2658   ; */
                    2659   ; #if (OS_EVENT_EN)
                    2660   ; INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
                    2661   ; void      *pmsg,
                    2662   ; INT8U      msk,
                    2663   ; INT8U      pend_stat)
                    2664   ; {
                    2665   _OS_EventTaskRdy:
00000FFA  4E56 FFFC 2666          link      A6,#-4
00000FFE  48E7 3C00 2667          movem.l   D2/D3/D4/D5,-(A7)
00001002  262E 0008 2668          move.l    8(A6),D3
                    2669   ; OS_TCB   *ptcb;
                    2670   ; INT8U     y;
                    2671   ; INT8U     x;
                    2672   ; INT8U     prio;
                    2673   ; #if OS_LOWEST_PRIO > 63u
                    2674   ; OS_PRIO  *ptbl;
                    2675   ; #endif
                    2676   ; #if OS_LOWEST_PRIO <= 63u
                    2677   ; y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
00001006  2043      2678          move.l    D3,A0
00001008  1028 0008 2679          move.b    8(A0),D0
0000100C  C0BC 0000 2680          and.l     #255,D0
00001010  00FF      
00001012  41F9 0000 2681          lea       _OSUnMapTbl.L,A0
00001016  70DE      
00001018  1830 0800 2682          move.b    0(A0,D0.L),D4
                    2683   ; x    = OSUnMapTbl[pevent->OSEventTbl[y]];
0000101C  2043      2684          move.l    D3,A0
0000101E  C8BC 0000 2685          and.l     #255,D4
00001022  00FF      
00001024  D1C4      2686          add.l     D4,A0
00001026  1028 000A 2687          move.b    10(A0),D0
0000102A  C0BC 0000 2688          and.l     #255,D0
0000102E  00FF      
00001030  41F9 0000 2689          lea       _OSUnMapTbl.L,A0
00001034  70DE      
00001036  1D70 0800 2690          move.b    0(A0,D0.L),-1(A6)
0000103A  FFFF      
                    2691   ; prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
0000103C  1004      2692          move.b    D4,D0
0000103E  E708      2693          lsl.b     #3,D0
00001040  D02E FFFF 2694          add.b     -1(A6),D0
00001044  1A00      2695          move.b    D0,D5
                    2696   ; #else
                    2697   ; if ((pevent->OSEventGrp & 0xFFu) != 0u) {           /* Find HPT waiting for message                */
                    2698   ; y = OSUnMapTbl[ pevent->OSEventGrp & 0xFFu];
                    2699   ; } else {
                    2700   ; y = OSUnMapTbl[(OS_PRIO)(pevent->OSEventGrp >> 8u) & 0xFFu] + 8u;
                    2701   ; }
                    2702   ; ptbl = &pevent->OSEventTbl[y];
                    2703   ; if ((*ptbl & 0xFFu) != 0u) {
                    2704   ; x = OSUnMapTbl[*ptbl & 0xFFu];
                    2705   ; } else {
                    2706   ; x = OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u;
                    2707   ; }
                    2708   ; prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
                    2709   ; #endif
                    2710   ; ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
00001046  CABC 0000 2711          and.l     #255,D5
0000104A  00FF      
0000104C  2005      2712          move.l    D5,D0
0000104E  E588      2713          lsl.l     #2,D0
00001050  41F9 0800 2714          lea       _OSTCBPrioTbl.L,A0
00001054  0438      
00001056  2430 0800 2715          move.l    0(A0,D0.L),D2
                    2716   ; ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
0000105A  2042      2717          move.l    D2,A0
0000105C  42A8 002E 2718          clr.l     46(A0)
                    2719   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
                    2720   ; ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
00001060  2042      2721          move.l    D2,A0
00001062  216E 000C 2722          move.l    12(A6),36(A0)
00001066  0024      
                    2723   ; #else
                    2724   ; pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
                    2725   ; #endif
                    2726   ; ptcb->OSTCBStat      &= (INT8U)~msk;                /* Clear bit associated with event type        */
00001068  2042      2727          move.l    D2,A0
0000106A  102E 0013 2728          move.b    19(A6),D0
0000106E  4600      2729          not.b     D0
00001070  C128 0032 2730          and.b     D0,50(A0)
                    2731   ; ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
00001074  2042      2732          move.l    D2,A0
00001076  116E 0017 2733          move.b    23(A6),51(A0)
0000107A  0033      
                    2734   ; /* See if task is ready (could be susp'd)      */
                    2735   ; if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
0000107C  2042      2736          move.l    D2,A0
0000107E  1028 0032 2737          move.b    50(A0),D0
00001082  C03C 0008 2738          and.b     #8,D0
00001086  6622      2739          bne.s     OS_EventTaskRdy_1
                    2740   ; OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
00001088  2042      2741          move.l    D2,A0
0000108A  1028 0038 2742          move.b    56(A0),D0
0000108E  8139 0800 2743          or.b      D0,_OSRdyGrp.L
00001092  0316      
                    2744   ; OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
00001094  C8BC 0000 2745          and.l     #255,D4
00001098  00FF      
0000109A  41F9 0800 2746          lea       _OSRdyTbl.L,A0
0000109E  0318      
000010A0  2242      2747          move.l    D2,A1
000010A2  1029 0037 2748          move.b    55(A1),D0
000010A6  8130 4800 2749          or.b      D0,0(A0,D4.L)
                    2750   OS_EventTaskRdy_1:
                    2751   ; }
                    2752   ; OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
000010AA  2F03      2753          move.l    D3,-(A7)
000010AC  2F02      2754          move.l    D2,-(A7)
000010AE  4EB9 0000 2755          jsr       _OS_EventTaskRemove
000010B2  1200      
000010B4  504F      2756          addq.w    #8,A7
                    2757   ; #if (OS_EVENT_MULTI_EN > 0u)
                    2758   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
000010B6  2042      2759          move.l    D2,A0
000010B8  2028 0020 2760          move.l    32(A0),D0
000010BC  6716      2761          beq.s     OS_EventTaskRdy_3
                    2762   ; OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
000010BE  2042      2763          move.l    D2,A0
000010C0  2F28 0020 2764          move.l    32(A0),-(A7)
000010C4  2F02      2765          move.l    D2,-(A7)
000010C6  4EB9 0000 2766          jsr       _OS_EventTaskRemoveMulti
000010CA  1252      
000010CC  504F      2767          addq.w    #8,A7
                    2768   ; ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
000010CE  2042      2769          move.l    D2,A0
000010D0  2143 001C 2770          move.l    D3,28(A0)
                    2771   OS_EventTaskRdy_3:
                    2772   ; }
                    2773   ; #endif
                    2774   ; return (prio);
000010D4  1005      2775          move.b    D5,D0
000010D6  4CDF 003C 2776          movem.l   (A7)+,D2/D3/D4/D5
000010DA  4E5E      2777          unlk      A6
000010DC  4E75      2778          rts
                    2779   ; }
                    2780   ; #endif
                    2781   ; /*$PAGE*/
                    2782   ; /*
                    2783   ; *********************************************************************************************************
                    2784   ; *                                  MAKE TASK WAIT FOR EVENT TO OCCUR
                    2785   ; *
                    2786   ; * Description: This function is called by other uC/OS-II services to suspend a task because an event has
                    2787   ; *              not occurred.
                    2788   ; *
                    2789   ; * Arguments  : pevent   is a pointer to the event control block for which the task will be waiting for.
                    2790   ; *
                    2791   ; * Returns    : none
                    2792   ; *
                    2793   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    2794   ; *********************************************************************************************************
                    2795   ; */
                    2796   ; #if (OS_EVENT_EN)
                    2797   ; void  OS_EventTaskWait (OS_EVENT *pevent)
                    2798   ; {
                    2799   _OS_EventTaskWait:
000010DE  4E56 0000 2800          link      A6,#0
000010E2  48E7 3020 2801          movem.l   D2/D3/A2,-(A7)
000010E6  45F9 0800 2802          lea       _OSTCBCur.L,A2
000010EA  0428      
000010EC  262E 0008 2803          move.l    8(A6),D3
                    2804   ; INT8U  y;
                    2805   ; OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
000010F0  2052      2806          move.l    (A2),A0
000010F2  2143 001C 2807          move.l    D3,28(A0)
                    2808   ; pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
000010F6  2043      2809          move.l    D3,A0
000010F8  2252      2810          move.l    (A2),A1
000010FA  1029 0036 2811          move.b    54(A1),D0
000010FE  C0BC 0000 2812          and.l     #255,D0
00001102  00FF      
00001104  D1C0      2813          add.l     D0,A0
00001106  2252      2814          move.l    (A2),A1
00001108  1029 0037 2815          move.b    55(A1),D0
0000110C  8128 000A 2816          or.b      D0,10(A0)
                    2817   ; pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
00001110  2043      2818          move.l    D3,A0
00001112  2252      2819          move.l    (A2),A1
00001114  1029 0038 2820          move.b    56(A1),D0
00001118  8128 0008 2821          or.b      D0,8(A0)
                    2822   ; y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
0000111C  2052      2823          move.l    (A2),A0
0000111E  1428 0036 2824          move.b    54(A0),D2
                    2825   ; OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
00001122  C4BC 0000 2826          and.l     #255,D2
00001126  00FF      
00001128  41F9 0800 2827          lea       _OSRdyTbl.L,A0
0000112C  0318      
0000112E  2252      2828          move.l    (A2),A1
00001130  1029 0037 2829          move.b    55(A1),D0
00001134  4600      2830          not.b     D0
00001136  C130 2800 2831          and.b     D0,0(A0,D2.L)
                    2832   ; if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
0000113A  C4BC 0000 2833          and.l     #255,D2
0000113E  00FF      
00001140  41F9 0800 2834          lea       _OSRdyTbl.L,A0
00001144  0318      
00001146  1030 2800 2835          move.b    0(A0,D2.L),D0
0000114A  660E      2836          bne.s     OS_EventTaskWait_1
                    2837   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
0000114C  2052      2838          move.l    (A2),A0
0000114E  1028 0038 2839          move.b    56(A0),D0
00001152  4600      2840          not.b     D0
00001154  C139 0800 2841          and.b     D0,_OSRdyGrp.L
00001158  0316      
                    2842   OS_EventTaskWait_1:
0000115A  4CDF 040C 2843          movem.l   (A7)+,D2/D3/A2
0000115E  4E5E      2844          unlk      A6
00001160  4E75      2845          rts
                    2846   ; }
                    2847   ; }
                    2848   ; #endif
                    2849   ; /*$PAGE*/
                    2850   ; /*
                    2851   ; *********************************************************************************************************
                    2852   ; *                         MAKE TASK WAIT FOR ANY OF MULTIPLE EVENTS TO OCCUR
                    2853   ; *
                    2854   ; * Description: This function is called by other uC/OS-II services to suspend a task because any one of
                    2855   ; *              multiple events has not occurred.
                    2856   ; *
                    2857   ; * Arguments  : pevents_wait     is a pointer to an array of event control blocks, NULL-terminated, for
                    2858   ; *                               which the task will be waiting for.
                    2859   ; *
                    2860   ; * Returns    : none.
                    2861   ; *
                    2862   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    2863   ; *********************************************************************************************************
                    2864   ; */
                    2865   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    2866   ; void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
                    2867   ; {
                    2868   _OS_EventTaskWaitMulti:
00001162  4E56 0000 2869          link      A6,#0
00001166  48E7 3820 2870          movem.l   D2/D3/D4/A2,-(A7)
0000116A  45F9 0800 2871          lea       _OSTCBCur.L,A2
0000116E  0428      
                    2872   ; OS_EVENT **pevents;
                    2873   ; OS_EVENT  *pevent;
                    2874   ; INT8U      y;
                    2875   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
00001170  2052      2876          move.l    (A2),A0
00001172  42A8 001C 2877          clr.l     28(A0)
                    2878   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
00001176  2052      2879          move.l    (A2),A0
00001178  216E 0008 2880          move.l    8(A6),32(A0)
0000117C  0020      
                    2881   ; pevents =  pevents_wait;
0000117E  262E 0008 2882          move.l    8(A6),D3
                    2883   ; pevent  = *pevents;
00001182  2043      2884          move.l    D3,A0
00001184  2410      2885          move.l    (A0),D2
                    2886   ; while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
                    2887   OS_EventTaskWaitMulti_1:
00001186  4A82      2888          tst.l     D2
00001188  6700 0030 2889          beq       OS_EventTaskWaitMulti_3
                    2890   ; pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
0000118C  2042      2891          move.l    D2,A0
0000118E  2252      2892          move.l    (A2),A1
00001190  1029 0036 2893          move.b    54(A1),D0
00001194  C0BC 0000 2894          and.l     #255,D0
00001198  00FF      
0000119A  D1C0      2895          add.l     D0,A0
0000119C  2252      2896          move.l    (A2),A1
0000119E  1029 0037 2897          move.b    55(A1),D0
000011A2  8128 000A 2898          or.b      D0,10(A0)
                    2899   ; pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
000011A6  2042      2900          move.l    D2,A0
000011A8  2252      2901          move.l    (A2),A1
000011AA  1029 0038 2902          move.b    56(A1),D0
000011AE  8128 0008 2903          or.b      D0,8(A0)
                    2904   ; pevents++;
000011B2  5883      2905          addq.l    #4,D3
                    2906   ; pevent = *pevents;
000011B4  2043      2907          move.l    D3,A0
000011B6  2410      2908          move.l    (A0),D2
000011B8  60CC      2909          bra       OS_EventTaskWaitMulti_1
                    2910   OS_EventTaskWaitMulti_3:
                    2911   ; }
                    2912   ; y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
000011BA  2052      2913          move.l    (A2),A0
000011BC  1828 0036 2914          move.b    54(A0),D4
                    2915   ; OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
000011C0  C8BC 0000 2916          and.l     #255,D4
000011C4  00FF      
000011C6  41F9 0800 2917          lea       _OSRdyTbl.L,A0
000011CA  0318      
000011CC  2252      2918          move.l    (A2),A1
000011CE  1029 0037 2919          move.b    55(A1),D0
000011D2  4600      2920          not.b     D0
000011D4  C130 4800 2921          and.b     D0,0(A0,D4.L)
                    2922   ; if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
000011D8  C8BC 0000 2923          and.l     #255,D4
000011DC  00FF      
000011DE  41F9 0800 2924          lea       _OSRdyTbl.L,A0
000011E2  0318      
000011E4  1030 4800 2925          move.b    0(A0,D4.L),D0
000011E8  660E      2926          bne.s     OS_EventTaskWaitMulti_4
                    2927   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
000011EA  2052      2928          move.l    (A2),A0
000011EC  1028 0038 2929          move.b    56(A0),D0
000011F0  4600      2930          not.b     D0
000011F2  C139 0800 2931          and.b     D0,_OSRdyGrp.L
000011F6  0316      
                    2932   OS_EventTaskWaitMulti_4:
000011F8  4CDF 041C 2933          movem.l   (A7)+,D2/D3/D4/A2
000011FC  4E5E      2934          unlk      A6
000011FE  4E75      2935          rts
                    2936   ; }
                    2937   ; }
                    2938   ; #endif
                    2939   ; /*$PAGE*/
                    2940   ; /*
                    2941   ; *********************************************************************************************************
                    2942   ; *                                  REMOVE TASK FROM EVENT WAIT LIST
                    2943   ; *
                    2944   ; * Description: Remove a task from an event's wait list.
                    2945   ; *
                    2946   ; * Arguments  : ptcb     is a pointer to the task to remove.
                    2947   ; *
                    2948   ; *              pevent   is a pointer to the event control block.
                    2949   ; *
                    2950   ; * Returns    : none
                    2951   ; *
                    2952   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    2953   ; *********************************************************************************************************
                    2954   ; */
                    2955   ; #if (OS_EVENT_EN)
                    2956   ; void  OS_EventTaskRemove (OS_TCB   *ptcb,
                    2957   ; OS_EVENT *pevent)
                    2958   ; {
                    2959   _OS_EventTaskRemove:
00001200  4E56 0000 2960          link      A6,#0
00001204  48E7 3800 2961          movem.l   D2/D3/D4,-(A7)
00001208  242E 000C 2962          move.l    12(A6),D2
0000120C  262E 0008 2963          move.l    8(A6),D3
                    2964   ; INT8U  y;
                    2965   ; y                       =  ptcb->OSTCBY;
00001210  2043      2966          move.l    D3,A0
00001212  1828 0036 2967          move.b    54(A0),D4
                    2968   ; pevent->OSEventTbl[y]  &= (OS_PRIO)~ptcb->OSTCBBitX;    /* Remove task from wait list              */
00001216  2042      2969          move.l    D2,A0
00001218  C8BC 0000 2970          and.l     #255,D4
0000121C  00FF      
0000121E  D1C4      2971          add.l     D4,A0
00001220  2243      2972          move.l    D3,A1
00001222  1029 0037 2973          move.b    55(A1),D0
00001226  4600      2974          not.b     D0
00001228  C128 000A 2975          and.b     D0,10(A0)
                    2976   ; if (pevent->OSEventTbl[y] == 0u) {
0000122C  2042      2977          move.l    D2,A0
0000122E  C8BC 0000 2978          and.l     #255,D4
00001232  00FF      
00001234  D1C4      2979          add.l     D4,A0
00001236  1028 000A 2980          move.b    10(A0),D0
0000123A  660E      2981          bne.s     OS_EventTaskRemove_1
                    2982   ; pevent->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
0000123C  2042      2983          move.l    D2,A0
0000123E  2243      2984          move.l    D3,A1
00001240  1029 0038 2985          move.b    56(A1),D0
00001244  4600      2986          not.b     D0
00001246  C128 0008 2987          and.b     D0,8(A0)
                    2988   OS_EventTaskRemove_1:
0000124A  4CDF 001C 2989          movem.l   (A7)+,D2/D3/D4
0000124E  4E5E      2990          unlk      A6
00001250  4E75      2991          rts
                    2992   ; }
                    2993   ; }
                    2994   ; #endif
                    2995   ; /*$PAGE*/
                    2996   ; /*
                    2997   ; *********************************************************************************************************
                    2998   ; *                             REMOVE TASK FROM MULTIPLE EVENTS WAIT LISTS
                    2999   ; *
                    3000   ; * Description: Remove a task from multiple events' wait lists.
                    3001   ; *
                    3002   ; * Arguments  : ptcb             is a pointer to the task to remove.
                    3003   ; *
                    3004   ; *              pevents_multi    is a pointer to the array of event control blocks, NULL-terminated.
                    3005   ; *
                    3006   ; * Returns    : none
                    3007   ; *
                    3008   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3009   ; *********************************************************************************************************
                    3010   ; */
                    3011   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    3012   ; void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                    3013   ; OS_EVENT **pevents_multi)
                    3014   ; {
                    3015   _OS_EventTaskRemoveMulti:
00001252  4E56 FFFC 3016          link      A6,#-4
00001256  48E7 3C00 3017          movem.l   D2/D3/D4/D5,-(A7)
0000125A  282E 0008 3018          move.l    8(A6),D4
                    3019   ; OS_EVENT **pevents;
                    3020   ; OS_EVENT  *pevent;
                    3021   ; INT8U      y;
                    3022   ; OS_PRIO    bity;
                    3023   ; OS_PRIO    bitx;
                    3024   ; y       =  ptcb->OSTCBY;
0000125E  2044      3025          move.l    D4,A0
00001260  1A28 0036 3026          move.b    54(A0),D5
                    3027   ; bity    =  ptcb->OSTCBBitY;
00001264  2044      3028          move.l    D4,A0
00001266  1D68 0038 3029          move.b    56(A0),-2(A6)
0000126A  FFFE      
                    3030   ; bitx    =  ptcb->OSTCBBitX;
0000126C  2044      3031          move.l    D4,A0
0000126E  1D68 0037 3032          move.b    55(A0),-1(A6)
00001272  FFFF      
                    3033   ; pevents =  pevents_multi;
00001274  262E 000C 3034          move.l    12(A6),D3
                    3035   ; pevent  = *pevents;
00001278  2043      3036          move.l    D3,A0
0000127A  2410      3037          move.l    (A0),D2
                    3038   ; while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
                    3039   OS_EventTaskRemoveMulti_1:
0000127C  4A82      3040          tst.l     D2
0000127E  6700 003A 3041          beq       OS_EventTaskRemoveMulti_3
                    3042   ; pevent->OSEventTbl[y]  &= (OS_PRIO)~bitx;
00001282  2042      3043          move.l    D2,A0
00001284  CABC 0000 3044          and.l     #255,D5
00001288  00FF      
0000128A  D1C5      3045          add.l     D5,A0
0000128C  102E FFFF 3046          move.b    -1(A6),D0
00001290  4600      3047          not.b     D0
00001292  C128 000A 3048          and.b     D0,10(A0)
                    3049   ; if (pevent->OSEventTbl[y] == 0u) {
00001296  2042      3050          move.l    D2,A0
00001298  CABC 0000 3051          and.l     #255,D5
0000129C  00FF      
0000129E  D1C5      3052          add.l     D5,A0
000012A0  1028 000A 3053          move.b    10(A0),D0
000012A4  660C      3054          bne.s     OS_EventTaskRemoveMulti_4
                    3055   ; pevent->OSEventGrp &= (OS_PRIO)~bity;
000012A6  2042      3056          move.l    D2,A0
000012A8  102E FFFE 3057          move.b    -2(A6),D0
000012AC  4600      3058          not.b     D0
000012AE  C128 0008 3059          and.b     D0,8(A0)
                    3060   OS_EventTaskRemoveMulti_4:
                    3061   ; }
                    3062   ; pevents++;
000012B2  5883      3063          addq.l    #4,D3
                    3064   ; pevent = *pevents;
000012B4  2043      3065          move.l    D3,A0
000012B6  2410      3066          move.l    (A0),D2
000012B8  60C2      3067          bra       OS_EventTaskRemoveMulti_1
                    3068   OS_EventTaskRemoveMulti_3:
000012BA  4CDF 003C 3069          movem.l   (A7)+,D2/D3/D4/D5
000012BE  4E5E      3070          unlk      A6
000012C0  4E75      3071          rts
                    3072   ; }
                    3073   ; }
                    3074   ; #endif
                    3075   ; /*$PAGE*/
                    3076   ; /*
                    3077   ; *********************************************************************************************************
                    3078   ; *                             INITIALIZE EVENT CONTROL BLOCK'S WAIT LIST
                    3079   ; *
                    3080   ; * Description: This function is called by other uC/OS-II services to initialize the event wait list.
                    3081   ; *
                    3082   ; * Arguments  : pevent    is a pointer to the event control block allocated to the event.
                    3083   ; *
                    3084   ; * Returns    : none
                    3085   ; *
                    3086   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3087   ; *********************************************************************************************************
                    3088   ; */
                    3089   ; #if (OS_EVENT_EN)
                    3090   ; void  OS_EventWaitListInit (OS_EVENT *pevent)
                    3091   ; {
                    3092   _OS_EventWaitListInit:
000012C2  4E56 0000 3093          link      A6,#0
000012C6  2F02      3094          move.l    D2,-(A7)
                    3095   ; INT8U  i;
                    3096   ; pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
000012C8  206E 0008 3097          move.l    8(A6),A0
000012CC  4228 0008 3098          clr.b     8(A0)
                    3099   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
000012D0  4202      3100          clr.b     D2
                    3101   OS_EventWaitListInit_1:
000012D2  0C02 0008 3102          cmp.b     #8,D2
000012D6  6414      3103          bhs.s     OS_EventWaitListInit_3
                    3104   ; pevent->OSEventTbl[i] = 0u;
000012D8  206E 0008 3105          move.l    8(A6),A0
000012DC  C4BC 0000 3106          and.l     #255,D2
000012E0  00FF      
000012E2  D1C2      3107          add.l     D2,A0
000012E4  4228 000A 3108          clr.b     10(A0)
000012E8  5202      3109          addq.b    #1,D2
000012EA  60E6      3110          bra       OS_EventWaitListInit_1
                    3111   OS_EventWaitListInit_3:
000012EC  241F      3112          move.l    (A7)+,D2
000012EE  4E5E      3113          unlk      A6
000012F0  4E75      3114          rts
                    3115   ; }
                    3116   ; }
                    3117   ; #endif
                    3118   ; /*$PAGE*/
                    3119   ; /*
                    3120   ; *********************************************************************************************************
                    3121   ; *                                             INITIALIZATION
                    3122   ; *                           INITIALIZE THE FREE LIST OF EVENT CONTROL BLOCKS
                    3123   ; *
                    3124   ; * Description: This function is called by OSInit() to initialize the free list of event control blocks.
                    3125   ; *
                    3126   ; * Arguments  : none
                    3127   ; *
                    3128   ; * Returns    : none
                    3129   ; *********************************************************************************************************
                    3130   ; */
                    3131   ; static  void  OS_InitEventList (void)
                    3132   ; {
                    3133   @ucos_ii_OS_InitEventList:
000012F2  4E56 FFF8 3134          link      A6,#-8
000012F6  48E7 3020 3135          movem.l   D2/D3/A2,-(A7)
000012FA  45F9 0800 3136          lea       _OSEventTbl.L,A2
000012FE  00E6      
                    3137   ; #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
                    3138   ; #if (OS_MAX_EVENTS > 1u)
                    3139   ; INT16U     ix;
                    3140   ; INT16U     ix_next;
                    3141   ; OS_EVENT  *pevent1;
                    3142   ; OS_EVENT  *pevent2;
                    3143   ; OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
00001300  4878 00DC 3144          pea       220
00001304  2F0A      3145          move.l    A2,-(A7)
00001306  4EB9 0000 3146          jsr       _OS_MemClr
0000130A  158E      
0000130C  504F      3147          addq.w    #8,A7
                    3148   ; for (ix = 0u; ix < (OS_MAX_EVENTS - 1u); ix++) {        /* Init. list of free EVENT control blocks */
0000130E  4243      3149          clr.w     D3
                    3150   @ucos_ii_OS_InitEventList_1:
00001310  0C43 0009 3151          cmp.w     #9,D3
00001314  6400 004E 3152          bhs       @ucos_ii_OS_InitEventList_3
                    3153   ; ix_next = ix + 1u;
00001318  3003      3154          move.w    D3,D0
0000131A  5240      3155          addq.w    #1,D0
0000131C  3D40 FFFA 3156          move.w    D0,-6(A6)
                    3157   ; pevent1 = &OSEventTbl[ix];
00001320  200A      3158          move.l    A2,D0
00001322  C6BC 0000 3159          and.l     #65535,D3
00001326  FFFF      
00001328  2203      3160          move.l    D3,D1
0000132A  C3FC 0016 3161          muls      #22,D1
0000132E  D081      3162          add.l     D1,D0
00001330  2400      3163          move.l    D0,D2
                    3164   ; pevent2 = &OSEventTbl[ix_next];
00001332  200A      3165          move.l    A2,D0
00001334  322E FFFA 3166          move.w    -6(A6),D1
00001338  C2BC 0000 3167          and.l     #65535,D1
0000133C  FFFF      
0000133E  C3FC 0016 3168          muls      #22,D1
00001342  D081      3169          add.l     D1,D0
00001344  2D40 FFFC 3170          move.l    D0,-4(A6)
                    3171   ; pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
00001348  2042      3172          move.l    D2,A0
0000134A  4210      3173          clr.b     (A0)
                    3174   ; pevent1->OSEventPtr     = pevent2;
0000134C  2042      3175          move.l    D2,A0
0000134E  216E FFFC 3176          move.l    -4(A6),2(A0)
00001352  0002      
                    3177   ; #if OS_EVENT_NAME_EN > 0u
                    3178   ; pevent1->OSEventName    = (INT8U *)(void *)"?";     /* Unknown name                            */
00001354  41F9 0000 3179          lea       @ucos_ii_1.L,A0
00001358  708C      
0000135A  2242      3180          move.l    D2,A1
0000135C  2348 0012 3181          move.l    A0,18(A1)
00001360  5243      3182          addq.w    #1,D3
00001362  60AC      3183          bra       @ucos_ii_OS_InitEventList_1
                    3184   @ucos_ii_OS_InitEventList_3:
                    3185   ; #endif
                    3186   ; }
                    3187   ; pevent1                         = &OSEventTbl[ix];
00001364  200A      3188          move.l    A2,D0
00001366  C6BC 0000 3189          and.l     #65535,D3
0000136A  FFFF      
0000136C  2203      3190          move.l    D3,D1
0000136E  C3FC 0016 3191          muls      #22,D1
00001372  D081      3192          add.l     D1,D0
00001374  2400      3193          move.l    D0,D2
                    3194   ; pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
00001376  2042      3195          move.l    D2,A0
00001378  4210      3196          clr.b     (A0)
                    3197   ; pevent1->OSEventPtr             = (OS_EVENT *)0;
0000137A  2042      3198          move.l    D2,A0
0000137C  42A8 0002 3199          clr.l     2(A0)
                    3200   ; #if OS_EVENT_NAME_EN > 0u
                    3201   ; pevent1->OSEventName            = (INT8U *)(void *)"?"; /* Unknown name                            */
00001380  41F9 0000 3202          lea       @ucos_ii_1.L,A0
00001384  708C      
00001386  2242      3203          move.l    D2,A1
00001388  2348 0012 3204          move.l    A0,18(A1)
                    3205   ; #endif
                    3206   ; OSEventFreeList                 = &OSEventTbl[0];
0000138C  23CA 0800 3207          move.l    A2,_OSEventFreeList.L
00001390  00E2      
00001392  4CDF 040C 3208          movem.l   (A7)+,D2/D3/A2
00001396  4E5E      3209          unlk      A6
00001398  4E75      3210          rts
                    3211   ; #else
                    3212   ; OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
                    3213   ; OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
                    3214   ; OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
                    3215   ; #if OS_EVENT_NAME_EN > 0u
                    3216   ; OSEventFreeList->OSEventName    = (INT8U *)"?";         /* Unknown name                            */
                    3217   ; #endif
                    3218   ; #endif
                    3219   ; #endif
                    3220   ; }
                    3221   ; /*$PAGE*/
                    3222   ; /*
                    3223   ; *********************************************************************************************************
                    3224   ; *                                             INITIALIZATION
                    3225   ; *                                    INITIALIZE MISCELLANEOUS VARIABLES
                    3226   ; *
                    3227   ; * Description: This function is called by OSInit() to initialize miscellaneous variables.
                    3228   ; *
                    3229   ; * Arguments  : none
                    3230   ; *
                    3231   ; * Returns    : none
                    3232   ; *********************************************************************************************************
                    3233   ; */
                    3234   ; static  void  OS_InitMisc (void)
                    3235   ; {
                    3236   @ucos_ii_OS_InitMisc:
                    3237   ; #if OS_TIME_GET_SET_EN > 0u
                    3238   ; OSTime                    = 0uL;                       /* Clear the 32-bit system clock            */
0000139A  42B9 0800 3239          clr.l     _OSTime.L
0000139E  0D7E      
                    3240   ; #endif
                    3241   ; OSIntNesting              = 0u;                        /* Clear the interrupt nesting counter      */
000013A0  4239 0800 3242          clr.b     _OSIntNesting.L
000013A4  030E      
                    3243   ; OSLockNesting             = 0u;                        /* Clear the scheduling lock counter        */
000013A6  4239 0800 3244          clr.b     _OSLockNesting.L
000013AA  0310      
                    3245   ; OSTaskCtr                 = 0u;                        /* Clear the number of tasks                */
000013AC  4239 0800 3246          clr.b     _OSTaskCtr.L
000013B0  0322      
                    3247   ; OSRunning                 = OS_FALSE;                  /* Indicate that multitasking not started   */
000013B2  4239 0800 3248          clr.b     _OSRunning.L
000013B6  0320      
                    3249   ; OSCtxSwCtr                = 0u;                        /* Clear the context switch counter         */
000013B8  42B9 0800 3250          clr.l     _OSCtxSwCtr.L
000013BC  00DE      
                    3251   ; OSIdleCtr                 = 0uL;                       /* Clear the 32-bit idle counter            */
000013BE  42B9 0800 3252          clr.l     _OSIdleCtr.L
000013C2  0324      
                    3253   ; #if OS_TASK_STAT_EN > 0u
                    3254   ; OSIdleCtrRun              = 0uL;
000013C4  42B9 0800 3255          clr.l     _OSIdleCtrRun.L
000013C8  0208      
                    3256   ; OSIdleCtrMax              = 0uL;
000013CA  42B9 0800 3257          clr.l     _OSIdleCtrMax.L
000013CE  0204      
                    3258   ; OSStatRdy                 = OS_FALSE;                  /* Statistic task is not ready              */
000013D0  4239 0800 3259          clr.b     _OSStatRdy.L
000013D4  020C      
                    3260   ; #endif
                    3261   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    3262   ; OSSafetyCriticalStartFlag = OS_FALSE;                  /* Still allow creation of objects          */
                    3263   ; #endif
                    3264   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    3265   ; OSTaskRegNextAvailID      = 0u;                        /* Initialize the task register ID          */
000013D6  4239 0800 3266          clr.b     _OSTaskRegNextAvailID.L
000013DA  0D7C      
000013DC  4E75      3267          rts
                    3268   ; #endif
                    3269   ; }
                    3270   ; /*$PAGE*/
                    3271   ; /*
                    3272   ; *********************************************************************************************************
                    3273   ; *                                             INITIALIZATION
                    3274   ; *                                       INITIALIZE THE READY LIST
                    3275   ; *
                    3276   ; * Description: This function is called by OSInit() to initialize the Ready List.
                    3277   ; *
                    3278   ; * Arguments  : none
                    3279   ; *
                    3280   ; * Returns    : none
                    3281   ; *********************************************************************************************************
                    3282   ; */
                    3283   ; static  void  OS_InitRdyList (void)
                    3284   ; {
                    3285   @ucos_ii_OS_InitRdyList:
000013DE  2F02      3286          move.l    D2,-(A7)
                    3287   ; INT8U  i;
                    3288   ; OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
000013E0  4239 0800 3289          clr.b     _OSRdyGrp.L
000013E4  0316      
                    3290   ; for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
000013E6  4202      3291          clr.b     D2
                    3292   @ucos_ii_OS_InitRdyList_1:
000013E8  0C02 0008 3293          cmp.b     #8,D2
000013EC  6414      3294          bhs.s     @ucos_ii_OS_InitRdyList_3
                    3295   ; OSRdyTbl[i] = 0u;
000013EE  C4BC 0000 3296          and.l     #255,D2
000013F2  00FF      
000013F4  41F9 0800 3297          lea       _OSRdyTbl.L,A0
000013F8  0318      
000013FA  4230 2800 3298          clr.b     0(A0,D2.L)
000013FE  5202      3299          addq.b    #1,D2
00001400  60E6      3300          bra       @ucos_ii_OS_InitRdyList_1
                    3301   @ucos_ii_OS_InitRdyList_3:
                    3302   ; }
                    3303   ; OSPrioCur     = 0u;
00001402  4239 0800 3304          clr.b     _OSPrioCur.L
00001406  0312      
                    3305   ; OSPrioHighRdy = 0u;
00001408  4239 0800 3306          clr.b     _OSPrioHighRdy.L
0000140C  0314      
                    3307   ; OSTCBHighRdy  = (OS_TCB *)0;
0000140E  42B9 0800 3308          clr.l     _OSTCBHighRdy.L
00001412  0430      
                    3309   ; OSTCBCur      = (OS_TCB *)0;
00001414  42B9 0800 3310          clr.l     _OSTCBCur.L
00001418  0428      
0000141A  241F      3311          move.l    (A7)+,D2
0000141C  4E75      3312          rts
                    3313   ; }
                    3314   ; /*$PAGE*/
                    3315   ; /*
                    3316   ; *********************************************************************************************************
                    3317   ; *                                             INITIALIZATION
                    3318   ; *                                         CREATING THE IDLE TASK
                    3319   ; *
                    3320   ; * Description: This function creates the Idle Task.
                    3321   ; *
                    3322   ; * Arguments  : none
                    3323   ; *
                    3324   ; * Returns    : none
                    3325   ; *********************************************************************************************************
                    3326   ; */
                    3327   ; static  void  OS_InitTaskIdle (void)
                    3328   ; {
                    3329   @ucos_ii_OS_InitTaskIdle:
0000141E  4E56 FFFC 3330          link      A6,#-4
                    3331   ; #if OS_TASK_NAME_EN > 0u
                    3332   ; INT8U  err;
                    3333   ; #endif
                    3334   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    3335   ; #if OS_STK_GROWTH == 1u
                    3336   ; (void)OSTaskCreateExt(OS_TaskIdle,
00001422  4878 0003 3337          pea       3
00001426  42A7      3338          clr.l     -(A7)
00001428  4878 0080 3339          pea       128
0000142C  4879 0800 3340          pea       _OSTaskIdleStk.L
00001430  0328      
00001432  4878 FFFF 3341          pea       65535
00001436  4878 003F 3342          pea       63
0000143A  41F9 0800 3343          lea       _OSTaskIdleStk.L,A0
0000143E  0328      
00001440  D0FC 00FE 3344          add.w     #254,A0
00001444  2F08      3345          move.l    A0,-(A7)
00001446  42A7      3346          clr.l     -(A7)
00001448  4879 0000 3347          pea       _OS_TaskIdle.L
0000144C  16A4      
0000144E  4EB9 0000 3348          jsr       _OSTaskCreateExt
00001452  4544      
00001454  DEFC 0024 3349          add.w     #36,A7
00001458  C0BC 0000 3350          and.l     #255,D0
0000145C  00FF      
                    3351   ; (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
                    3352   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Top-Of-Stack                     */
                    3353   ; OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
                    3354   ; OS_TASK_IDLE_ID,
                    3355   ; &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
                    3356   ; OS_TASK_IDLE_STK_SIZE,
                    3357   ; (void *)0,                                 /* No TCB extension                     */
                    3358   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
                    3359   ; #else
                    3360   ; (void)OSTaskCreateExt(OS_TaskIdle,
                    3361   ; (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
                    3362   ; &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
                    3363   ; OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
                    3364   ; OS_TASK_IDLE_ID,
                    3365   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Bottom-Of-Stack                  */
                    3366   ; OS_TASK_IDLE_STK_SIZE,
                    3367   ; (void *)0,                                 /* No TCB extension                     */
                    3368   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
                    3369   ; #endif
                    3370   ; #else
                    3371   ; #if OS_STK_GROWTH == 1u
                    3372   ; (void)OSTaskCreate(OS_TaskIdle,
                    3373   ; (void *)0,
                    3374   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],
                    3375   ; OS_TASK_IDLE_PRIO);
                    3376   ; #else
                    3377   ; (void)OSTaskCreate(OS_TaskIdle,
                    3378   ; (void *)0,
                    3379   ; &OSTaskIdleStk[0],
                    3380   ; OS_TASK_IDLE_PRIO);
                    3381   ; #endif
                    3382   ; #endif
                    3383   ; #if OS_TASK_NAME_EN > 0u
                    3384   ; OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)(void *)"uC/OS-II Idle", &err);
0000145E  486E FFFF 3385          pea       -1(A6)
00001462  4879 0000 3386          pea       @ucos_ii_2.L
00001466  708E      
00001468  4878 003F 3387          pea       63
0000146C  4EB9 0000 3388          jsr       _OSTaskNameSet
00001470  4950      
00001472  DEFC 000C 3389          add.w     #12,A7
00001476  4E5E      3390          unlk      A6
00001478  4E75      3391          rts
                    3392   ; #endif
                    3393   ; }
                    3394   ; /*$PAGE*/
                    3395   ; /*
                    3396   ; *********************************************************************************************************
                    3397   ; *                                             INITIALIZATION
                    3398   ; *                                      CREATING THE STATISTIC TASK
                    3399   ; *
                    3400   ; * Description: This function creates the Statistic Task.
                    3401   ; *
                    3402   ; * Arguments  : none
                    3403   ; *
                    3404   ; * Returns    : none
                    3405   ; *********************************************************************************************************
                    3406   ; */
                    3407   ; #if OS_TASK_STAT_EN > 0u
                    3408   ; static  void  OS_InitTaskStat (void)
                    3409   ; {
                    3410   @ucos_ii_OS_InitTaskStat:
0000147A  4E56 FFFC 3411          link      A6,#-4
                    3412   ; #if OS_TASK_NAME_EN > 0u
                    3413   ; INT8U  err;
                    3414   ; #endif
                    3415   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    3416   ; #if OS_STK_GROWTH == 1u
                    3417   ; (void)OSTaskCreateExt(OS_TaskStat,
0000147E  4878 0003 3418          pea       3
00001482  42A7      3419          clr.l     -(A7)
00001484  4878 0080 3420          pea       128
00001488  4879 0800 3421          pea       _OSTaskStatStk.L
0000148C  020E      
0000148E  4878 FFFE 3422          pea       65534
00001492  4878 003E 3423          pea       62
00001496  41F9 0800 3424          lea       _OSTaskStatStk.L,A0
0000149A  020E      
0000149C  D0FC 00FE 3425          add.w     #254,A0
000014A0  2F08      3426          move.l    A0,-(A7)
000014A2  42A7      3427          clr.l     -(A7)
000014A4  4879 0000 3428          pea       _OS_TaskStat.L
000014A8  16BC      
000014AA  4EB9 0000 3429          jsr       _OSTaskCreateExt
000014AE  4544      
000014B0  DEFC 0024 3430          add.w     #36,A7
000014B4  C0BC 0000 3431          and.l     #255,D0
000014B8  00FF      
                    3432   ; (void *)0,                                   /* No args passed to OS_TaskStat()*/
                    3433   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Top-Of-Stack               */
                    3434   ; OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
                    3435   ; OS_TASK_STAT_ID,
                    3436   ; &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
                    3437   ; OS_TASK_STAT_STK_SIZE,
                    3438   ; (void *)0,                                   /* No TCB extension               */
                    3439   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
                    3440   ; #else
                    3441   ; (void)OSTaskCreateExt(OS_TaskStat,
                    3442   ; (void *)0,                                   /* No args passed to OS_TaskStat()*/
                    3443   ; &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
                    3444   ; OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
                    3445   ; OS_TASK_STAT_ID,
                    3446   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Bottom-Of-Stack            */
                    3447   ; OS_TASK_STAT_STK_SIZE,
                    3448   ; (void *)0,                                   /* No TCB extension               */
                    3449   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
                    3450   ; #endif
                    3451   ; #else
                    3452   ; #if OS_STK_GROWTH == 1u
                    3453   ; (void)OSTaskCreate(OS_TaskStat,
                    3454   ; (void *)0,                                      /* No args passed to OS_TaskStat()*/
                    3455   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],     /* Set Top-Of-Stack               */
                    3456   ; OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
                    3457   ; #else
                    3458   ; (void)OSTaskCreate(OS_TaskStat,
                    3459   ; (void *)0,                                      /* No args passed to OS_TaskStat()*/
                    3460   ; &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
                    3461   ; OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
                    3462   ; #endif
                    3463   ; #endif
                    3464   ; #if OS_TASK_NAME_EN > 0u
                    3465   ; OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)(void *)"uC/OS-II Stat", &err);
000014BA  486E FFFF 3466          pea       -1(A6)
000014BE  4879 0000 3467          pea       @ucos_ii_3.L
000014C2  709C      
000014C4  4878 003E 3468          pea       62
000014C8  4EB9 0000 3469          jsr       _OSTaskNameSet
000014CC  4950      
000014CE  DEFC 000C 3470          add.w     #12,A7
000014D2  4E5E      3471          unlk      A6
000014D4  4E75      3472          rts
                    3473   ; #endif
                    3474   ; }
                    3475   ; #endif
                    3476   ; /*$PAGE*/
                    3477   ; /*
                    3478   ; *********************************************************************************************************
                    3479   ; *                                             INITIALIZATION
                    3480   ; *                            INITIALIZE THE FREE LIST OF TASK CONTROL BLOCKS
                    3481   ; *
                    3482   ; * Description: This function is called by OSInit() to initialize the free list of OS_TCBs.
                    3483   ; *
                    3484   ; * Arguments  : none
                    3485   ; *
                    3486   ; * Returns    : none
                    3487   ; *********************************************************************************************************
                    3488   ; */
                    3489   ; static  void  OS_InitTCBList (void)
                    3490   ; {
                    3491   @ucos_ii_OS_InitTCBList:
000014D6  4E56 FFF8 3492          link      A6,#-8
000014DA  48E7 3020 3493          movem.l   D2/D3/A2,-(A7)
000014DE  45F9 0800 3494          lea       _OSTCBTbl.L,A2
000014E2  0538      
                    3495   ; INT8U    ix;
                    3496   ; INT8U    ix_next;
                    3497   ; OS_TCB  *ptcb1;
                    3498   ; OS_TCB  *ptcb2;
                    3499   ; OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
000014E4  4878 0764 3500          pea       1892
000014E8  2F0A      3501          move.l    A2,-(A7)
000014EA  4EB9 0000 3502          jsr       _OS_MemClr
000014EE  158E      
000014F0  504F      3503          addq.w    #8,A7
                    3504   ; OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
000014F2  4878 0100 3505          pea       256
000014F6  4879 0800 3506          pea       _OSTCBPrioTbl.L
000014FA  0438      
000014FC  4EB9 0000 3507          jsr       _OS_MemClr
00001500  158E      
00001502  504F      3508          addq.w    #8,A7
                    3509   ; for (ix = 0u; ix < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
00001504  4203      3510          clr.b     D3
                    3511   @ucos_ii_OS_InitTCBList_1:
00001506  0C03 0015 3512          cmp.b     #21,D3
0000150A  6400 004A 3513          bhs       @ucos_ii_OS_InitTCBList_3
                    3514   ; ix_next =  ix + 1u;
0000150E  7001      3515          moveq     #1,D0
00001510  D003      3516          add.b     D3,D0
00001512  1D40 FFFB 3517          move.b    D0,-5(A6)
                    3518   ; ptcb1   = &OSTCBTbl[ix];
00001516  200A      3519          move.l    A2,D0
00001518  C6BC 0000 3520          and.l     #255,D3
0000151C  00FF      
0000151E  2203      3521          move.l    D3,D1
00001520  C3FC 0056 3522          muls      #86,D1
00001524  D081      3523          add.l     D1,D0
00001526  2400      3524          move.l    D0,D2
                    3525   ; ptcb2   = &OSTCBTbl[ix_next];
00001528  200A      3526          move.l    A2,D0
0000152A  122E FFFB 3527          move.b    -5(A6),D1
0000152E  C2BC 0000 3528          and.l     #255,D1
00001532  00FF      
00001534  C3FC 0056 3529          muls      #86,D1
00001538  D081      3530          add.l     D1,D0
0000153A  2D40 FFFC 3531          move.l    D0,-4(A6)
                    3532   ; ptcb1->OSTCBNext = ptcb2;
0000153E  2042      3533          move.l    D2,A0
00001540  216E FFFC 3534          move.l    -4(A6),20(A0)
00001544  0014      
                    3535   ; #if OS_TASK_NAME_EN > 0u
                    3536   ; ptcb1->OSTCBTaskName = (INT8U *)(void *)"?";             /* Unknown name                       */
00001546  41F9 0000 3537          lea       @ucos_ii_1.L,A0
0000154A  708C      
0000154C  2242      3538          move.l    D2,A1
0000154E  2348 004E 3539          move.l    A0,78(A1)
00001552  5203      3540          addq.b    #1,D3
00001554  60B0      3541          bra       @ucos_ii_OS_InitTCBList_1
                    3542   @ucos_ii_OS_InitTCBList_3:
                    3543   ; #endif
                    3544   ; }
                    3545   ; ptcb1                   = &OSTCBTbl[ix];
00001556  200A      3546          move.l    A2,D0
00001558  C6BC 0000 3547          and.l     #255,D3
0000155C  00FF      
0000155E  2203      3548          move.l    D3,D1
00001560  C3FC 0056 3549          muls      #86,D1
00001564  D081      3550          add.l     D1,D0
00001566  2400      3551          move.l    D0,D2
                    3552   ; ptcb1->OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
00001568  2042      3553          move.l    D2,A0
0000156A  42A8 0014 3554          clr.l     20(A0)
                    3555   ; #if OS_TASK_NAME_EN > 0u
                    3556   ; ptcb1->OSTCBTaskName    = (INT8U *)(void *)"?";              /* Unknown name                       */
0000156E  41F9 0000 3557          lea       @ucos_ii_1.L,A0
00001572  708C      
00001574  2242      3558          move.l    D2,A1
00001576  2348 004E 3559          move.l    A0,78(A1)
                    3560   ; #endif
                    3561   ; OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
0000157A  42B9 0800 3562          clr.l     _OSTCBList.L
0000157E  0434      
                    3563   ; OSTCBFreeList           = &OSTCBTbl[0];
00001580  23CA 0800 3564          move.l    A2,_OSTCBFreeList.L
00001584  042C      
00001586  4CDF 040C 3565          movem.l   (A7)+,D2/D3/A2
0000158A  4E5E      3566          unlk      A6
0000158C  4E75      3567          rts
                    3568   ; }
                    3569   ; /*$PAGE*/
                    3570   ; /*
                    3571   ; *********************************************************************************************************
                    3572   ; *                                      CLEAR A SECTION OF MEMORY
                    3573   ; *
                    3574   ; * Description: This function is called by other uC/OS-II services to clear a contiguous block of RAM.
                    3575   ; *
                    3576   ; * Arguments  : pdest    is the start of the RAM to clear (i.e. write 0x00 to)
                    3577   ; *
                    3578   ; *              size     is the number of bytes to clear.
                    3579   ; *
                    3580   ; * Returns    : none
                    3581   ; *
                    3582   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    3583   ; *              2) Note that we can only clear up to 64K bytes of RAM.  This is not an issue because none
                    3584   ; *                 of the uses of this function gets close to this limit.
                    3585   ; *              3) The clear is done one byte at a time since this will work on any processor irrespective
                    3586   ; *                 of the alignment of the destination.
                    3587   ; *********************************************************************************************************
                    3588   ; */
                    3589   ; void  OS_MemClr (INT8U  *pdest,
                    3590   ; INT16U  size)
                    3591   ; {
                    3592   _OS_MemClr:
0000158E  4E56 0000 3593          link      A6,#0
                    3594   ; while (size > 0u) {
                    3595   OS_MemClr_1:
00001592  302E 000E 3596          move.w    14(A6),D0
00001596  0C40 0000 3597          cmp.w     #0,D0
0000159A  6310      3598          bls.s     OS_MemClr_3
                    3599   ; *pdest++ = (INT8U)0;
0000159C  206E 0008 3600          move.l    8(A6),A0
000015A0  52AE 0008 3601          addq.l    #1,8(A6)
000015A4  4210      3602          clr.b     (A0)
                    3603   ; size--;
000015A6  536E 000E 3604          subq.w    #1,14(A6)
000015AA  60E6      3605          bra       OS_MemClr_1
                    3606   OS_MemClr_3:
000015AC  4E5E      3607          unlk      A6
000015AE  4E75      3608          rts
                    3609   ; }
                    3610   ; }
                    3611   ; /*$PAGE*/
                    3612   ; /*
                    3613   ; *********************************************************************************************************
                    3614   ; *                                       COPY A BLOCK OF MEMORY
                    3615   ; *
                    3616   ; * Description: This function is called by other uC/OS-II services to copy a block of memory from one
                    3617   ; *              location to another.
                    3618   ; *
                    3619   ; * Arguments  : pdest    is a pointer to the 'destination' memory block
                    3620   ; *
                    3621   ; *              psrc     is a pointer to the 'source'      memory block
                    3622   ; *
                    3623   ; *              size     is the number of bytes to copy.
                    3624   ; *
                    3625   ; * Returns    : none
                    3626   ; *
                    3627   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.  There is
                    3628   ; *                 no provision to handle overlapping memory copy.  However, that's not a problem since this
                    3629   ; *                 is not a situation that will happen.
                    3630   ; *              2) Note that we can only copy up to 64K bytes of RAM
                    3631   ; *              3) The copy is done one byte at a time since this will work on any processor irrespective
                    3632   ; *                 of the alignment of the source and destination.
                    3633   ; *********************************************************************************************************
                    3634   ; */
                    3635   ; void  OS_MemCopy (INT8U  *pdest,
                    3636   ; INT8U  *psrc,
                    3637   ; INT16U  size)
                    3638   ; {
                    3639   _OS_MemCopy:
000015B0  4E56 0000 3640          link      A6,#0
                    3641   ; while (size > 0u) {
                    3642   OS_MemCopy_1:
000015B4  302E 0012 3643          move.w    18(A6),D0
000015B8  0C40 0000 3644          cmp.w     #0,D0
000015BC  6318      3645          bls.s     OS_MemCopy_3
                    3646   ; *pdest++ = *psrc++;
000015BE  206E 000C 3647          move.l    12(A6),A0
000015C2  52AE 000C 3648          addq.l    #1,12(A6)
000015C6  226E 0008 3649          move.l    8(A6),A1
000015CA  52AE 0008 3650          addq.l    #1,8(A6)
000015CE  1290      3651          move.b    (A0),(A1)
                    3652   ; size--;
000015D0  536E 0012 3653          subq.w    #1,18(A6)
000015D4  60DE      3654          bra       OS_MemCopy_1
                    3655   OS_MemCopy_3:
000015D6  4E5E      3656          unlk      A6
000015D8  4E75      3657          rts
                    3658   ; }
                    3659   ; }
                    3660   ; /*$PAGE*/
                    3661   ; /*
                    3662   ; *********************************************************************************************************
                    3663   ; *                                              SCHEDULER
                    3664   ; *
                    3665   ; * Description: This function is called by other uC/OS-II services to determine whether a new, high
                    3666   ; *              priority task has been made ready to run.  This function is invoked by TASK level code
                    3667   ; *              and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
                    3668   ; *
                    3669   ; * Arguments  : none
                    3670   ; *
                    3671   ; * Returns    : none
                    3672   ; *
                    3673   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    3674   ; *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
                    3675   ; *********************************************************************************************************
                    3676   ; */
                    3677   ; void  OS_Sched (void)
                    3678   ; {
                    3679   _OS_Sched:
                    3680   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    3681   ; OS_CPU_SR  cpu_sr = 0u;
                    3682   ; #endif
                    3683   ; OS_ENTER_CRITICAL();
000015DA  40E7      3684          dc.w      16615
000015DC  007C      3685          dc.w      124
000015DE  0700      3686          dc.w      1792
                    3687   ; if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
000015E0  1039 0800 3688          move.b    _OSIntNesting.L,D0
000015E4  030E      
000015E6  6600 0052 3689          bne       OS_Sched_5
                    3690   ; if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
000015EA  1039 0800 3691          move.b    _OSLockNesting.L,D0
000015EE  0310      
000015F0  6648      3692          bne.s     OS_Sched_5
                    3693   ; OS_SchedNew();
000015F2  4EB9 0000 3694          jsr       @ucos_ii_OS_SchedNew
000015F6  163E      
                    3695   ; OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
000015F8  1039 0800 3696          move.b    _OSPrioHighRdy.L,D0
000015FC  0314      
000015FE  C0BC 0000 3697          and.l     #255,D0
00001602  00FF      
00001604  E588      3698          lsl.l     #2,D0
00001606  41F9 0800 3699          lea       _OSTCBPrioTbl.L,A0
0000160A  0438      
0000160C  23F0 0800 3700          move.l    0(A0,D0.L),_OSTCBHighRdy.L
00001610  0800 0430 
                    3701   ; if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
00001614  1039 0800 3702          move.b    _OSPrioHighRdy.L,D0
00001618  0314      
0000161A  B039 0800 3703          cmp.b     _OSPrioCur.L,D0
0000161E  0312      
00001620  6718      3704          beq.s     OS_Sched_5
                    3705   ; #if OS_TASK_PROFILE_EN > 0u
                    3706   ; OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
00001622  2039 0800 3707          move.l    _OSTCBHighRdy.L,D0
00001626  0430      
00001628  0680 0000 3708          add.l     #58,D0
0000162C  003A      
0000162E  2040      3709          move.l    D0,A0
00001630  5290      3710          addq.l    #1,(A0)
                    3711   ; #endif
                    3712   ; OSCtxSwCtr++;                          /* Increment context switch counter             */
00001632  52B9 0800 3713          addq.l    #1,_OSCtxSwCtr.L
00001636  00DE      
                    3714   ; OS_TASK_SW();                          /* Perform a context switch                     */
00001638  4E40      3715          trap      #0
                    3716   OS_Sched_5:
                    3717   ; }
                    3718   ; }
                    3719   ; }
                    3720   ; OS_EXIT_CRITICAL();
0000163A  46DF      3721          dc.w      18143
0000163C  4E75      3722          rts
                    3723   ; }
                    3724   ; /*
                    3725   ; *********************************************************************************************************
                    3726   ; *                               FIND HIGHEST PRIORITY TASK READY TO RUN
                    3727   ; *
                    3728   ; * Description: This function is called by other uC/OS-II services to determine the highest priority task
                    3729   ; *              that is ready to run.  The global variable 'OSPrioHighRdy' is changed accordingly.
                    3730   ; *
                    3731   ; * Arguments  : none
                    3732   ; *
                    3733   ; * Returns    : none
                    3734   ; *
                    3735   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    3736   ; *              2) Interrupts are assumed to be disabled when this function is called.
                    3737   ; *********************************************************************************************************
                    3738   ; */
                    3739   ; static  void  OS_SchedNew (void)
                    3740   ; {
                    3741   @ucos_ii_OS_SchedNew:
0000163E  2F02      3742          move.l    D2,-(A7)
                    3743   ; #if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
                    3744   ; INT8U   y;
                    3745   ; y             = OSUnMapTbl[OSRdyGrp];
00001640  1039 0800 3746          move.b    _OSRdyGrp.L,D0
00001644  0316      
00001646  C0BC 0000 3747          and.l     #255,D0
0000164A  00FF      
0000164C  41F9 0000 3748          lea       _OSUnMapTbl.L,A0
00001650  70DE      
00001652  1430 0800 3749          move.b    0(A0,D0.L),D2
                    3750   ; OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
00001656  1002      3751          move.b    D2,D0
00001658  E708      3752          lsl.b     #3,D0
0000165A  C4BC 0000 3753          and.l     #255,D2
0000165E  00FF      
00001660  41F9 0800 3754          lea       _OSRdyTbl.L,A0
00001664  0318      
00001666  1230 2800 3755          move.b    0(A0,D2.L),D1
0000166A  C2BC 0000 3756          and.l     #255,D1
0000166E  00FF      
00001670  41F9 0000 3757          lea       _OSUnMapTbl.L,A0
00001674  70DE      
00001676  D030 1800 3758          add.b     0(A0,D1.L),D0
0000167A  13C0 0800 3759          move.b    D0,_OSPrioHighRdy.L
0000167E  0314      
00001680  241F      3760          move.l    (A7)+,D2
00001682  4E75      3761          rts
                    3762   ; #else                                            /* We support up to 256 tasks                         */
                    3763   ; INT8U     y;
                    3764   ; OS_PRIO  *ptbl;
                    3765   ; if ((OSRdyGrp & 0xFFu) != 0u) {
                    3766   ; y = OSUnMapTbl[OSRdyGrp & 0xFFu];
                    3767   ; } else {
                    3768   ; y = OSUnMapTbl[(OS_PRIO)(OSRdyGrp >> 8u) & 0xFFu] + 8u;
                    3769   ; }
                    3770   ; ptbl = &OSRdyTbl[y];
                    3771   ; if ((*ptbl & 0xFFu) != 0u) {
                    3772   ; OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
                    3773   ; } else {
                    3774   ; OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u);
                    3775   ; }
                    3776   ; #endif
                    3777   ; }
                    3778   ; /*$PAGE*/
                    3779   ; /*
                    3780   ; *********************************************************************************************************
                    3781   ; *                               DETERMINE THE LENGTH OF AN ASCII STRING
                    3782   ; *
                    3783   ; * Description: This function is called by other uC/OS-II services to determine the size of an ASCII string
                    3784   ; *              (excluding the NUL character).
                    3785   ; *
                    3786   ; * Arguments  : psrc     is a pointer to the string for which we need to know the size.
                    3787   ; *
                    3788   ; * Returns    : The size of the string (excluding the NUL terminating character)
                    3789   ; *
                    3790   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    3791   ; *              2) The string to check must be less than 255 characters long.
                    3792   ; *********************************************************************************************************
                    3793   ; */
                    3794   ; #if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)
                    3795   ; INT8U  OS_StrLen (INT8U *psrc)
                    3796   ; {
                    3797   _OS_StrLen:
00001684  4E56 0000 3798          link      A6,#0
00001688  2F02      3799          move.l    D2,-(A7)
                    3800   ; INT8U  len;
                    3801   ; #if OS_ARG_CHK_EN > 0u
                    3802   ; if (psrc == (INT8U *)0) {
                    3803   ; return (0u);
                    3804   ; }
                    3805   ; #endif
                    3806   ; len = 0u;
0000168A  4202      3807          clr.b     D2
                    3808   ; while (*psrc != OS_ASCII_NUL) {
                    3809   OS_StrLen_1:
0000168C  206E 0008 3810          move.l    8(A6),A0
00001690  1010      3811          move.b    (A0),D0
00001692  6708      3812          beq.s     OS_StrLen_3
                    3813   ; psrc++;
00001694  52AE 0008 3814          addq.l    #1,8(A6)
                    3815   ; len++;
00001698  5202      3816          addq.b    #1,D2
0000169A  60F0      3817          bra       OS_StrLen_1
                    3818   OS_StrLen_3:
                    3819   ; }
                    3820   ; return (len);
0000169C  1002      3821          move.b    D2,D0
0000169E  241F      3822          move.l    (A7)+,D2
000016A0  4E5E      3823          unlk      A6
000016A2  4E75      3824          rts
                    3825   ; }
                    3826   ; #endif
                    3827   ; /*$PAGE*/
                    3828   ; /*
                    3829   ; *********************************************************************************************************
                    3830   ; *                                              IDLE TASK
                    3831   ; *
                    3832   ; * Description: This task is internal to uC/OS-II and executes whenever no other higher priority tasks
                    3833   ; *              executes because they are ALL waiting for event(s) to occur.
                    3834   ; *
                    3835   ; * Arguments  : none
                    3836   ; *
                    3837   ; * Returns    : none
                    3838   ; *
                    3839   ; * Note(s)    : 1) OSTaskIdleHook() is called after the critical section to ensure that interrupts will be
                    3840   ; *                 enabled for at least a few instructions.  On some processors (ex. Philips XA), enabling
                    3841   ; *                 and then disabling interrupts didn't allow the processor enough time to have interrupts
                    3842   ; *                 enabled before they were disabled again.  uC/OS-II would thus never recognize
                    3843   ; *                 interrupts.
                    3844   ; *              2) This hook has been added to allow you to do such things as STOP the CPU to conserve
                    3845   ; *                 power.
                    3846   ; *********************************************************************************************************
                    3847   ; */
                    3848   ; void  OS_TaskIdle (void *p_arg)
                    3849   ; {
                    3850   _OS_TaskIdle:
000016A4  4E56 0000 3851          link      A6,#0
                    3852   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    3853   ; OS_CPU_SR  cpu_sr = 0u;
                    3854   ; #endif
                    3855   ; p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
                    3856   ; for (;;) {
                    3857   OS_TaskIdle_1:
                    3858   ; OS_ENTER_CRITICAL();
000016A8  40E7      3859          dc.w      16615
000016AA  007C      3860          dc.w      124
000016AC  0700      3861          dc.w      1792
                    3862   ; OSIdleCtr++;
000016AE  52B9 0800 3863          addq.l    #1,_OSIdleCtr.L
000016B2  0324      
                    3864   ; OS_EXIT_CRITICAL();
000016B4  46DF      3865          dc.w      18143
                    3866   ; OSTaskIdleHook();                        /* Call user definable HOOK                           */
000016B6  4EB8 08D0 3867          jsr       _OSTaskIdleHook
000016BA  60EC      3868          bra       OS_TaskIdle_1
                    3869   ; }
                    3870   ; }
                    3871   ; /*$PAGE*/
                    3872   ; /*
                    3873   ; *********************************************************************************************************
                    3874   ; *                                           STATISTICS TASK
                    3875   ; *
                    3876   ; * Description: This task is internal to uC/OS-II and is used to compute some statistics about the
                    3877   ; *              multitasking environment.  Specifically, OS_TaskStat() computes the CPU usage.
                    3878   ; *              CPU usage is determined by:
                    3879   ; *
                    3880   ; *                                          OSIdleCtr
                    3881   ; *                 OSCPUUsage = 100 * (1 - ------------)     (units are in %)
                    3882   ; *                                         OSIdleCtrMax
                    3883   ; *
                    3884   ; * Arguments  : parg     this pointer is not used at this time.
                    3885   ; *
                    3886   ; * Returns    : none
                    3887   ; *
                    3888   ; * Notes      : 1) This task runs at a priority level higher than the idle task.  In fact, it runs at the
                    3889   ; *                 next higher priority, OS_TASK_IDLE_PRIO-1.
                    3890   ; *              2) You can disable this task by setting the configuration #define OS_TASK_STAT_EN to 0.
                    3891   ; *              3) You MUST have at least a delay of 2/10 seconds to allow for the system to establish the
                    3892   ; *                 maximum value for the idle counter.
                    3893   ; *********************************************************************************************************
                    3894   ; */
                    3895   ; #if OS_TASK_STAT_EN > 0u
                    3896   ; void  OS_TaskStat (void *p_arg)
                    3897   ; {
                    3898   _OS_TaskStat:
000016BC  4E56 0000 3899          link      A6,#0
000016C0  2F0A      3900          move.l    A2,-(A7)
000016C2  45F9 0800 3901          lea       _OSIdleCtrMax.L,A2
000016C6  0204      
                    3902   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    3903   ; OS_CPU_SR  cpu_sr = 0u;
                    3904   ; #endif
                    3905   ; p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
                    3906   ; while (OSStatRdy == OS_FALSE) {
                    3907   OS_TaskStat_1:
000016C8  1039 0800 3908          move.b    _OSStatRdy.L,D0
000016CC  020C      
000016CE  660E      3909          bne.s     OS_TaskStat_3
                    3910   ; OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
000016D0  4878 0014 3911          pea       20
000016D4  4EB9 0000 3912          jsr       _OSTimeDly
000016D8  4DD6      
000016DA  584F      3913          addq.w    #4,A7
000016DC  60EA      3914          bra       OS_TaskStat_1
                    3915   OS_TaskStat_3:
                    3916   ; }
                    3917   ; OSIdleCtrMax /= 100uL;
000016DE  2F12      3918          move.l    (A2),-(A7)
000016E0  4878 0064 3919          pea       100
000016E4  4EB9 0000 3920          jsr       ULDIV
000016E8  66E0      
000016EA  2497      3921          move.l    (A7),(A2)
000016EC  504F      3922          addq.w    #8,A7
                    3923   ; if (OSIdleCtrMax == 0uL) {
000016EE  2012      3924          move.l    (A2),D0
000016F0  6618      3925          bne.s     OS_TaskStat_4
                    3926   ; OSCPUUsage = 0u;
000016F2  4239 0800 3927          clr.b     _OSCPUUsage.L
000016F6  0202      
                    3928   ; #if OS_TASK_SUSPEND_EN > 0u
                    3929   ; (void)OSTaskSuspend(OS_PRIO_SELF);
000016F8  4878 00FF 3930          pea       255
000016FC  4EB9 0000 3931          jsr       _OSTaskSuspend
00001700  4B4E      
00001702  584F      3932          addq.w    #4,A7
00001704  C0BC 0000 3933          and.l     #255,D0
00001708  00FF      
                    3934   OS_TaskStat_4:
                    3935   ; #else
                    3936   ; for (;;) {
                    3937   ; OSTimeDly(OS_TICKS_PER_SEC);
                    3938   ; }
                    3939   ; #endif
                    3940   ; }
                    3941   ; OS_ENTER_CRITICAL();
0000170A  40E7      3942          dc.w      16615
0000170C  007C      3943          dc.w      124
0000170E  0700      3944          dc.w      1792
                    3945   ; OSIdleCtr = OSIdleCtrMax * 100uL;            /* Set initial CPU usage as 0%                        */
00001710  2F12      3946          move.l    (A2),-(A7)
00001712  4878 0064 3947          pea       100
00001716  4EB9 0000 3948          jsr       ULMUL
0000171A  6640      
0000171C  2017      3949          move.l    (A7),D0
0000171E  504F      3950          addq.w    #8,A7
00001720  23C0 0800 3951          move.l    D0,_OSIdleCtr.L
00001724  0324      
                    3952   ; OS_EXIT_CRITICAL();
00001726  46DF      3953          dc.w      18143
                    3954   ; for (;;) {
                    3955   OS_TaskStat_6:
                    3956   ; OS_ENTER_CRITICAL();
00001728  40E7      3957          dc.w      16615
0000172A  007C      3958          dc.w      124
0000172C  0700      3959          dc.w      1792
                    3960   ; OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
0000172E  23F9 0800 3961          move.l    _OSIdleCtr.L,_OSIdleCtrRun.L
00001732  0324 0800 
00001736  0208      
                    3962   ; OSIdleCtr    = 0uL;                      /* Reset the idle counter for the next second         */
00001738  42B9 0800 3963          clr.l     _OSIdleCtr.L
0000173C  0324      
                    3964   ; OS_EXIT_CRITICAL();
0000173E  46DF      3965          dc.w      18143
                    3966   ; OSCPUUsage   = (INT8U)(100uL - OSIdleCtrRun / OSIdleCtrMax);
00001740  7064      3967          moveq     #100,D0
00001742  2F39 0800 3968          move.l    _OSIdleCtrRun.L,-(A7)
00001746  0208      
00001748  2F12      3969          move.l    (A2),-(A7)
0000174A  4EB9 0000 3970          jsr       ULDIV
0000174E  66E0      
00001750  2217      3971          move.l    (A7),D1
00001752  504F      3972          addq.w    #8,A7
00001754  9081      3973          sub.l     D1,D0
00001756  13C0 0800 3974          move.b    D0,_OSCPUUsage.L
0000175A  0202      
                    3975   ; OSTaskStatHook();                        /* Invoke user definable hook                         */
0000175C  4EB8 08DA 3976          jsr       _OSTaskStatHook
                    3977   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    3978   ; OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
00001760  4EB9 0000 3979          jsr       _OS_TaskStatStkChk
00001764  1774      
                    3980   ; #endif
                    3981   ; OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
00001766  4878 000A 3982          pea       10
0000176A  4EB9 0000 3983          jsr       _OSTimeDly
0000176E  4DD6      
00001770  584F      3984          addq.w    #4,A7
00001772  60B4      3985          bra       OS_TaskStat_6
                    3986   ; }
                    3987   ; }
                    3988   ; #endif
                    3989   ; /*$PAGE*/
                    3990   ; /*
                    3991   ; *********************************************************************************************************
                    3992   ; *                                        CHECK ALL TASK STACKS
                    3993   ; *
                    3994   ; * Description: This function is called by OS_TaskStat() to check the stacks of each active task.
                    3995   ; *
                    3996   ; * Arguments  : none
                    3997   ; *
                    3998   ; * Returns    : none
                    3999   ; *********************************************************************************************************
                    4000   ; */
                    4001   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    4002   ; void  OS_TaskStatStkChk (void)
                    4003   ; {
                    4004   _OS_TaskStatStkChk:
00001774  4E56 FFF4 4005          link      A6,#-12
00001778  48E7 3000 4006          movem.l   D2/D3,-(A7)
                    4007   ; OS_TCB      *ptcb;
                    4008   ; OS_STK_DATA  stk_data;
                    4009   ; INT8U        err;
                    4010   ; INT8U        prio;
                    4011   ; for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
0000177C  4203      4012          clr.b     D3
                    4013   OS_TaskStatStkChk_1:
0000177E  0C03 003F 4014          cmp.b     #63,D3
00001782  6200 0068 4015          bhi       OS_TaskStatStkChk_3
                    4016   ; err = OSTaskStkChk(prio, &stk_data);
00001786  486E FFF6 4017          pea       -10(A6)
0000178A  C6BC 0000 4018          and.l     #255,D3
0000178E  00FF      
00001790  2F03      4019          move.l    D3,-(A7)
00001792  4EB9 0000 4020          jsr       _OSTaskStkChk
00001796  4A96      
00001798  504F      4021          addq.w    #8,A7
0000179A  1D40 FFFF 4022          move.b    D0,-1(A6)
                    4023   ; if (err == OS_ERR_NONE) {
0000179E  102E FFFF 4024          move.b    -1(A6),D0
000017A2  6600 0044 4025          bne       OS_TaskStatStkChk_8
                    4026   ; ptcb = OSTCBPrioTbl[prio];
000017A6  C6BC 0000 4027          and.l     #255,D3
000017AA  00FF      
000017AC  2003      4028          move.l    D3,D0
000017AE  E588      4029          lsl.l     #2,D0
000017B0  41F9 0800 4030          lea       _OSTCBPrioTbl.L,A0
000017B4  0438      
000017B6  2430 0800 4031          move.l    0(A0,D0.L),D2
                    4032   ; if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
000017BA  4A82      4033          tst.l     D2
000017BC  672A      4034          beq.s     OS_TaskStatStkChk_8
                    4035   ; if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
000017BE  0C82 0000 4036          cmp.l     #1,D2
000017C2  0001      
000017C4  6722      4037          beq.s     OS_TaskStatStkChk_8
                    4038   ; #if OS_TASK_PROFILE_EN > 0u
                    4039   ; #if OS_STK_GROWTH == 1u
                    4040   ; ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
000017C6  2042      4041          move.l    D2,A0
000017C8  2028 0008 4042          move.l    8(A0),D0
000017CC  2042      4043          move.l    D2,A0
000017CE  2228 000C 4044          move.l    12(A0),D1
000017D2  E389      4045          lsl.l     #1,D1
000017D4  D081      4046          add.l     D1,D0
000017D6  2042      4047          move.l    D2,A0
000017D8  2140 0046 4048          move.l    D0,70(A0)
                    4049   ; #else
                    4050   ; ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    4051   ; #endif
                    4052   ; ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store number of entries used   */
000017DC  41EE FFF6 4053          lea       -10(A6),A0
000017E0  2242      4054          move.l    D2,A1
000017E2  2368 0004 4055          move.l    4(A0),74(A1)
000017E6  004A      
                    4056   OS_TaskStatStkChk_8:
000017E8  5203      4057          addq.b    #1,D3
000017EA  6092      4058          bra       OS_TaskStatStkChk_1
                    4059   OS_TaskStatStkChk_3:
000017EC  4CDF 000C 4060          movem.l   (A7)+,D2/D3
000017F0  4E5E      4061          unlk      A6
000017F2  4E75      4062          rts
                    4063   ; #endif
                    4064   ; }
                    4065   ; }
                    4066   ; }
                    4067   ; }
                    4068   ; }
                    4069   ; #endif
                    4070   ; /*$PAGE*/
                    4071   ; /*
                    4072   ; *********************************************************************************************************
                    4073   ; *                                           INITIALIZE TCB
                    4074   ; *
                    4075   ; * Description: This function is internal to uC/OS-II and is used to initialize a Task Control Block when
                    4076   ; *              a task is created (see OSTaskCreate() and OSTaskCreateExt()).
                    4077   ; *
                    4078   ; * Arguments  : prio          is the priority of the task being created
                    4079   ; *
                    4080   ; *              ptos          is a pointer to the task's top-of-stack assuming that the CPU registers
                    4081   ; *                            have been placed on the stack.  Note that the top-of-stack corresponds to a
                    4082   ; *                            'high' memory location is OS_STK_GROWTH is set to 1 and a 'low' memory
                    4083   ; *                            location if OS_STK_GROWTH is set to 0.  Note that stack growth is CPU
                    4084   ; *                            specific.
                    4085   ; *
                    4086   ; *              pbos          is a pointer to the bottom of stack.  A NULL pointer is passed if called by
                    4087   ; *                            'OSTaskCreate()'.
                    4088   ; *
                    4089   ; *              id            is the task's ID (0..65535)
                    4090   ; *
                    4091   ; *              stk_size      is the size of the stack (in 'stack units').  If the stack units are INT8Us
                    4092   ; *                            then, 'stk_size' contains the number of bytes for the stack.  If the stack
                    4093   ; *                            units are INT32Us then, the stack contains '4 * stk_size' bytes.  The stack
                    4094   ; *                            units are established by the #define constant OS_STK which is CPU
                    4095   ; *                            specific.  'stk_size' is 0 if called by 'OSTaskCreate()'.
                    4096   ; *
                    4097   ; *              pext          is a pointer to a user supplied memory area that is used to extend the task
                    4098   ; *                            control block.  This allows you to store the contents of floating-point
                    4099   ; *                            registers, MMU registers or anything else you could find useful during a
                    4100   ; *                            context switch.  You can even assign a name to each task and store this name
                    4101   ; *                            in this TCB extension.  A NULL pointer is passed if called by OSTaskCreate().
                    4102   ; *
                    4103   ; *              opt           options as passed to 'OSTaskCreateExt()' or,
                    4104   ; *                            0 if called from 'OSTaskCreate()'.
                    4105   ; *
                    4106   ; * Returns    : OS_ERR_NONE         if the call was successful
                    4107   ; *              OS_ERR_TASK_NO_MORE_TCB  if there are no more free TCBs to be allocated and thus, the task cannot
                    4108   ; *                                  be created.
                    4109   ; *
                    4110   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    4111   ; *********************************************************************************************************
                    4112   ; */
                    4113   ; INT8U  OS_TCBInit (INT8U    prio,
                    4114   ; OS_STK  *ptos,
                    4115   ; OS_STK  *pbos,
                    4116   ; INT16U   id,
                    4117   ; INT32U   stk_size,
                    4118   ; void    *pext,
                    4119   ; INT16U   opt)
                    4120   ; {
                    4121   _OS_TCBInit:
000017F4  4E56 0000 4122          link      A6,#0
000017F8  48E7 3820 4123          movem.l   D2/D3/D4/A2,-(A7)
000017FC  45F9 0800 4124          lea       _OSTCBList.L,A2
00001800  0434      
00001802  182E 000B 4125          move.b    11(A6),D4
00001806  C8BC 0000 4126          and.l     #255,D4
0000180A  00FF      
                    4127   ; OS_TCB    *ptcb;
                    4128   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    4129   ; OS_CPU_SR  cpu_sr = 0u;
                    4130   ; #endif
                    4131   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    4132   ; INT8U      i;
                    4133   ; #endif
                    4134   ; OS_ENTER_CRITICAL();
0000180C  40E7      4135          dc.w      16615
0000180E  007C      4136          dc.w      124
00001810  0700      4137          dc.w      1792
                    4138   ; ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
00001812  2439 0800 4139          move.l    _OSTCBFreeList.L,D2
00001816  042C      
                    4140   ; if (ptcb != (OS_TCB *)0) {
00001818  4A82      4141          tst.l     D2
0000181A  6700 017A 4142          beq       OS_TCBInit_1
                    4143   ; OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
0000181E  2042      4144          move.l    D2,A0
00001820  23E8 0014 4145          move.l    20(A0),_OSTCBFreeList.L
00001824  0800 042C 
                    4146   ; OS_EXIT_CRITICAL();
00001828  46DF      4147          dc.w      18143
                    4148   ; ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
0000182A  2042      4149          move.l    D2,A0
0000182C  20AE 000C 4150          move.l    12(A6),(A0)
                    4151   ; ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
00001830  2042      4152          move.l    D2,A0
00001832  1144 0034 4153          move.b    D4,52(A0)
                    4154   ; ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
00001836  2042      4155          move.l    D2,A0
00001838  4228 0032 4156          clr.b     50(A0)
                    4157   ; ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
0000183C  2042      4158          move.l    D2,A0
0000183E  4228 0033 4159          clr.b     51(A0)
                    4160   ; ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
00001842  2042      4161          move.l    D2,A0
00001844  42A8 002E 4162          clr.l     46(A0)
                    4163   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    4164   ; ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
00001848  2042      4165          move.l    D2,A0
0000184A  216E 001C 4166          move.l    28(A6),4(A0)
0000184E  0004      
                    4167   ; ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
00001850  2042      4168          move.l    D2,A0
00001852  216E 0018 4169          move.l    24(A6),12(A0)
00001856  000C      
                    4170   ; ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
00001858  2042      4171          move.l    D2,A0
0000185A  216E 0010 4172          move.l    16(A6),8(A0)
0000185E  0008      
                    4173   ; ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
00001860  2042      4174          move.l    D2,A0
00001862  316E 0022 4175          move.w    34(A6),16(A0)
00001866  0010      
                    4176   ; ptcb->OSTCBId            = id;                     /* Store task ID                            */
00001868  2042      4177          move.l    D2,A0
0000186A  316E 0016 4178          move.w    22(A6),18(A0)
0000186E  0012      
                    4179   ; #else
                    4180   ; pext                     = pext;                   /* Prevent compiler warning if not used     */
                    4181   ; stk_size                 = stk_size;
                    4182   ; pbos                     = pbos;
                    4183   ; opt                      = opt;
                    4184   ; id                       = id;
                    4185   ; #endif
                    4186   ; #if OS_TASK_DEL_EN > 0u
                    4187   ; ptcb->OSTCBDelReq        = OS_ERR_NONE;
00001870  2042      4188          move.l    D2,A0
00001872  4228 0039 4189          clr.b     57(A0)
                    4190   ; #endif
                    4191   ; #if OS_LOWEST_PRIO <= 63u                                         /* Pre-compute X, Y                  */
                    4192   ; ptcb->OSTCBY             = (INT8U)(prio >> 3u);
00001876  1004      4193          move.b    D4,D0
00001878  E608      4194          lsr.b     #3,D0
0000187A  2042      4195          move.l    D2,A0
0000187C  1140 0036 4196          move.b    D0,54(A0)
                    4197   ; ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
00001880  1004      4198          move.b    D4,D0
00001882  C03C 0007 4199          and.b     #7,D0
00001886  2042      4200          move.l    D2,A0
00001888  1140 0035 4201          move.b    D0,53(A0)
                    4202   ; #else                                                             /* Pre-compute X, Y                  */
                    4203   ; ptcb->OSTCBY             = (INT8U)((INT8U)(prio >> 4u) & 0xFFu);
                    4204   ; ptcb->OSTCBX             = (INT8U) (prio & 0x0Fu);
                    4205   ; #endif
                    4206   ; /* Pre-compute BitX and BitY         */
                    4207   ; ptcb->OSTCBBitY          = (OS_PRIO)(1uL << ptcb->OSTCBY);
0000188C  7001      4208          moveq     #1,D0
0000188E  2042      4209          move.l    D2,A0
00001890  1228 0036 4210          move.b    54(A0),D1
00001894  C2BC 0000 4211          and.l     #255,D1
00001898  00FF      
0000189A  E3A8      4212          lsl.l     D1,D0
0000189C  2042      4213          move.l    D2,A0
0000189E  1140 0038 4214          move.b    D0,56(A0)
                    4215   ; ptcb->OSTCBBitX          = (OS_PRIO)(1uL << ptcb->OSTCBX);
000018A2  7001      4216          moveq     #1,D0
000018A4  2042      4217          move.l    D2,A0
000018A6  1228 0035 4218          move.b    53(A0),D1
000018AA  C2BC 0000 4219          and.l     #255,D1
000018AE  00FF      
000018B0  E3A8      4220          lsl.l     D1,D0
000018B2  2042      4221          move.l    D2,A0
000018B4  1140 0037 4222          move.b    D0,55(A0)
                    4223   ; #if (OS_EVENT_EN)
                    4224   ; ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
000018B8  2042      4225          move.l    D2,A0
000018BA  42A8 001C 4226          clr.l     28(A0)
                    4227   ; #if (OS_EVENT_MULTI_EN > 0u)
                    4228   ; ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
000018BE  2042      4229          move.l    D2,A0
000018C0  42A8 0020 4230          clr.l     32(A0)
                    4231   ; #endif
                    4232   ; #endif
                    4233   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
                    4234   ; ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
000018C4  2042      4235          move.l    D2,A0
000018C6  42A8 0028 4236          clr.l     40(A0)
                    4237   ; #endif
                    4238   ; #if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    4239   ; ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
000018CA  2042      4240          move.l    D2,A0
000018CC  42A8 0024 4241          clr.l     36(A0)
                    4242   ; #endif
                    4243   ; #if OS_TASK_PROFILE_EN > 0u
                    4244   ; ptcb->OSTCBCtxSwCtr    = 0uL;                      /* Initialize profiling variables           */
000018D0  2042      4245          move.l    D2,A0
000018D2  42A8 003A 4246          clr.l     58(A0)
                    4247   ; ptcb->OSTCBCyclesStart = 0uL;
000018D6  2042      4248          move.l    D2,A0
000018D8  42A8 0042 4249          clr.l     66(A0)
                    4250   ; ptcb->OSTCBCyclesTot   = 0uL;
000018DC  2042      4251          move.l    D2,A0
000018DE  42A8 003E 4252          clr.l     62(A0)
                    4253   ; ptcb->OSTCBStkBase     = (OS_STK *)0;
000018E2  2042      4254          move.l    D2,A0
000018E4  42A8 0046 4255          clr.l     70(A0)
                    4256   ; ptcb->OSTCBStkUsed     = 0uL;
000018E8  2042      4257          move.l    D2,A0
000018EA  42A8 004A 4258          clr.l     74(A0)
                    4259   ; #endif
                    4260   ; #if OS_TASK_NAME_EN > 0u
                    4261   ; ptcb->OSTCBTaskName    = (INT8U *)(void *)"?";
000018EE  41F9 0000 4262          lea       @ucos_ii_1.L,A0
000018F2  708C      
000018F4  2242      4263          move.l    D2,A1
000018F6  2348 004E 4264          move.l    A0,78(A1)
                    4265   ; #endif
                    4266   ; #if OS_TASK_REG_TBL_SIZE > 0u                              /* Initialize the task variables            */
                    4267   ; for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
000018FA  4203      4268          clr.b     D3
                    4269   OS_TCBInit_3:
000018FC  0C03 0001 4270          cmp.b     #1,D3
00001900  6416      4271          bhs.s     OS_TCBInit_5
                    4272   ; ptcb->OSTCBRegTbl[i] = 0u;
00001902  2042      4273          move.l    D2,A0
00001904  C6BC 0000 4274          and.l     #255,D3
00001908  00FF      
0000190A  2003      4275          move.l    D3,D0
0000190C  E588      4276          lsl.l     #2,D0
0000190E  D1C0      4277          add.l     D0,A0
00001910  42A8 0052 4278          clr.l     82(A0)
00001914  5203      4279          addq.b    #1,D3
00001916  60E4      4280          bra       OS_TCBInit_3
                    4281   OS_TCBInit_5:
                    4282   ; }
                    4283   ; #endif
                    4284   ; OSTCBInitHook(ptcb);
00001918  2F02      4285          move.l    D2,-(A7)
0000191A  4EB8 0908 4286          jsr       _OSTCBInitHook
0000191E  584F      4287          addq.w    #4,A7
                    4288   ; OS_ENTER_CRITICAL();
00001920  40E7      4289          dc.w      16615
00001922  007C      4290          dc.w      124
00001924  0700      4291          dc.w      1792
                    4292   ; OSTCBPrioTbl[prio] = ptcb;
00001926  C8BC 0000 4293          and.l     #255,D4
0000192A  00FF      
0000192C  2004      4294          move.l    D4,D0
0000192E  E588      4295          lsl.l     #2,D0
00001930  41F9 0800 4296          lea       _OSTCBPrioTbl.L,A0
00001934  0438      
00001936  2182 0800 4297          move.l    D2,0(A0,D0.L)
                    4298   ; OS_EXIT_CRITICAL();
0000193A  46DF      4299          dc.w      18143
                    4300   ; OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
0000193C  2F02      4301          move.l    D2,-(A7)
0000193E  4EB8 08BE 4302          jsr       _OSTaskCreateHook
00001942  584F      4303          addq.w    #4,A7
                    4304   ; OS_ENTER_CRITICAL();
00001944  40E7      4305          dc.w      16615
00001946  007C      4306          dc.w      124
00001948  0700      4307          dc.w      1792
                    4308   ; ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
0000194A  2042      4309          move.l    D2,A0
0000194C  2152 0014 4310          move.l    (A2),20(A0)
                    4311   ; ptcb->OSTCBPrev    = (OS_TCB *)0;
00001950  2042      4312          move.l    D2,A0
00001952  42A8 0018 4313          clr.l     24(A0)
                    4314   ; if (OSTCBList != (OS_TCB *)0) {
00001956  2012      4315          move.l    (A2),D0
00001958  6706      4316          beq.s     OS_TCBInit_6
                    4317   ; OSTCBList->OSTCBPrev = ptcb;
0000195A  2052      4318          move.l    (A2),A0
0000195C  2142 0018 4319          move.l    D2,24(A0)
                    4320   OS_TCBInit_6:
                    4321   ; }
                    4322   ; OSTCBList               = ptcb;
00001960  2482      4323          move.l    D2,(A2)
                    4324   ; OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
00001962  2042      4325          move.l    D2,A0
00001964  1028 0038 4326          move.b    56(A0),D0
00001968  8139 0800 4327          or.b      D0,_OSRdyGrp.L
0000196C  0316      
                    4328   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0000196E  2042      4329          move.l    D2,A0
00001970  1028 0036 4330          move.b    54(A0),D0
00001974  C0BC 0000 4331          and.l     #255,D0
00001978  00FF      
0000197A  41F9 0800 4332          lea       _OSRdyTbl.L,A0
0000197E  0318      
00001980  2242      4333          move.l    D2,A1
00001982  1229 0037 4334          move.b    55(A1),D1
00001986  8330 0800 4335          or.b      D1,0(A0,D0.L)
                    4336   ; OSTaskCtr++;                                       /* Increment the #tasks counter             */
0000198A  5239 0800 4337          addq.b    #1,_OSTaskCtr.L
0000198E  0322      
                    4338   ; OS_EXIT_CRITICAL();
00001990  46DF      4339          dc.w      18143
                    4340   ; return (OS_ERR_NONE);
00001992  4200      4341          clr.b     D0
00001994  6004      4342          bra.s     OS_TCBInit_8
                    4343   OS_TCBInit_1:
                    4344   ; }
                    4345   ; OS_EXIT_CRITICAL();
00001996  46DF      4346          dc.w      18143
                    4347   ; return (OS_ERR_TASK_NO_MORE_TCB);
00001998  7042      4348          moveq     #66,D0
                    4349   OS_TCBInit_8:
0000199A  4CDF 041C 4350          movem.l   (A7)+,D2/D3/D4/A2
0000199E  4E5E      4351          unlk      A6
000019A0  4E75      4352          rts
                    4353   ; /*
                    4354   ; *********************************************************************************************************
                    4355   ; *                                                uC/OS-II
                    4356   ; *                                          The Real-Time Kernel
                    4357   ; *                                         EVENT FLAG  MANAGEMENT
                    4358   ; *
                    4359   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    4360   ; *                                           All Rights Reserved
                    4361   ; *
                    4362   ; * File    : OS_FLAG.C
                    4363   ; * By      : Jean J. Labrosse
                    4364   ; * Version : V2.92.07
                    4365   ; *
                    4366   ; * LICENSING TERMS:
                    4367   ; * ---------------
                    4368   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    4369   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    4370   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    4371   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    4372   ; * licensing fee.
                    4373   ; *********************************************************************************************************
                    4374   ; */
                    4375   ; #define  MICRIUM_SOURCE
                    4376   ; #ifndef  OS_MASTER_FILE
                    4377   ; #include <ucos_ii.h>
                    4378   ; #endif
                    4379   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    4380   ; /*
                    4381   ; *********************************************************************************************************
                    4382   ; *                                          LOCAL PROTOTYPES
                    4383   ; *********************************************************************************************************
                    4384   ; */
                    4385   ; static  void     OS_FlagBlock(OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT32U timeout);
                    4386   ; static  BOOLEAN  OS_FlagTaskRdy(OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy, INT8U pend_stat);
                    4387   ; /*$PAGE*/
                    4388   ; /*
                    4389   ; *********************************************************************************************************
                    4390   ; *                          CHECK THE STATUS OF FLAGS IN AN EVENT FLAG GROUP
                    4391   ; *
                    4392   ; * Description: This function is called to check the status of a combination of bits to be set or cleared
                    4393   ; *              in an event flag group.  Your application can check for ANY bit to be set/cleared or ALL
                    4394   ; *              bits to be set/cleared.
                    4395   ; *
                    4396   ; *              This call does not block if the desired flags are not present.
                    4397   ; *
                    4398   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    4399   ; *
                    4400   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
                    4401   ; *                            The bits you want are specified by setting the corresponding bits in
                    4402   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    4403   ; *                            'flags' would contain 0x03.
                    4404   ; *
                    4405   ; *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
                    4406   ; *                            to be set/cleared.
                    4407   ; *                            You can specify the following argument:
                    4408   ; *
                    4409   ; *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'flags' to be clear (0)
                    4410   ; *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'flags' to be clear (0)
                    4411   ; *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'flags' to be set   (1)
                    4412   ; *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'flags' to be set   (1)
                    4413   ; *
                    4414   ; *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
                    4415   ; *                                  the call.  Example, to wait for any flag in a group AND then clear
                    4416   ; *                                  the flags that are present, set 'wait_type' to:
                    4417   ; *
                    4418   ; *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
                    4419   ; *
                    4420   ; *              perr          is a pointer to an error code and can be:
                    4421   ; *                            OS_ERR_NONE               No error
                    4422   ; *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
                    4423   ; *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
                    4424   ; *                            OS_ERR_FLAG_INVALID_PGRP  You passed a NULL pointer instead of the event flag
                    4425   ; *                                                      group handle.
                    4426   ; *                            OS_ERR_FLAG_NOT_RDY       The desired flags you are waiting for are not
                    4427   ; *                                                      available.
                    4428   ; *
                    4429   ; * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
                    4430   ; *              occurred.
                    4431   ; *
                    4432   ; * Called from: Task or ISR
                    4433   ; *
                    4434   ; * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
                    4435   ; *                 function NOW returns the flags that were ready INSTEAD of the current state of the
                    4436   ; *                 event flags.
                    4437   ; *********************************************************************************************************
                    4438   ; */
                    4439   ; #if OS_FLAG_ACCEPT_EN > 0u
                    4440   ; OS_FLAGS  OSFlagAccept (OS_FLAG_GRP  *pgrp,
                    4441   ; OS_FLAGS      flags,
                    4442   ; INT8U         wait_type,
                    4443   ; INT8U        *perr)
                    4444   ; {
                    4445   _OSFlagAccept:
000019A2  4E56 FFFC 4446          link      A6,#-4
000019A6  48E7 3F00 4447          movem.l   D2/D3/D4/D5/D6/D7,-(A7)
000019AA  262E 0008 4448          move.l    8(A6),D3
000019AE  282E 0014 4449          move.l    20(A6),D4
000019B2  3A2E 000E 4450          move.w    14(A6),D5
000019B6  CABC 0000 4451          and.l     #65535,D5
000019BA  FFFF      
000019BC  1E2E 0013 4452          move.b    19(A6),D7
000019C0  CEBC 0000 4453          and.l     #255,D7
000019C4  00FF      
                    4454   ; OS_FLAGS      flags_rdy;
                    4455   ; INT8U         result;
                    4456   ; BOOLEAN       consume;
                    4457   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    4458   ; OS_CPU_SR     cpu_sr = 0u;
                    4459   ; #endif
                    4460   ; #ifdef OS_SAFETY_CRITICAL
                    4461   ; if (perr == (INT8U *)0) {
                    4462   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    4463   ; return ((OS_FLAGS)0);
                    4464   ; }
                    4465   ; #endif
                    4466   ; #if OS_ARG_CHK_EN > 0u
                    4467   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    4468   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    4469   ; return ((OS_FLAGS)0);
                    4470   ; }
                    4471   ; #endif
                    4472   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
000019C6  2043      4473          move.l    D3,A0
000019C8  1010      4474          move.b    (A0),D0
000019CA  0C00 0005 4475          cmp.b     #5,D0
000019CE  670C      4476          beq.s     OSFlagAccept_1
                    4477   ; *perr = OS_ERR_EVENT_TYPE;
000019D0  2044      4478          move.l    D4,A0
000019D2  10BC 0001 4479          move.b    #1,(A0)
                    4480   ; return ((OS_FLAGS)0);
000019D6  4240      4481          clr.w     D0
000019D8  6000 0100 4482          bra       OSFlagAccept_3
                    4483   OSFlagAccept_1:
                    4484   ; }
                    4485   ; result = (INT8U)(wait_type & OS_FLAG_CONSUME);
000019DC  1007      4486          move.b    D7,D0
000019DE  C03C 0080 4487          and.b     #128,D0
000019E2  1D40 FFFF 4488          move.b    D0,-1(A6)
                    4489   ; if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
000019E6  102E FFFF 4490          move.b    -1(A6),D0
000019EA  6708      4491          beq.s     OSFlagAccept_4
                    4492   ; wait_type &= (INT8U)~OS_FLAG_CONSUME;
000019EC  CE3C 007F 4493          and.b     #127,D7
                    4494   ; consume    = OS_TRUE;
000019F0  7C01      4495          moveq     #1,D6
000019F2  6002      4496          bra.s     OSFlagAccept_5
                    4497   OSFlagAccept_4:
                    4498   ; } else {
                    4499   ; consume    = OS_FALSE;
000019F4  4206      4500          clr.b     D6
                    4501   OSFlagAccept_5:
                    4502   ; }
                    4503   ; /*$PAGE*/
                    4504   ; *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
000019F6  2044      4505          move.l    D4,A0
000019F8  4210      4506          clr.b     (A0)
                    4507   ; OS_ENTER_CRITICAL();
000019FA  40E7      4508          dc.w      16615
000019FC  007C      4509          dc.w      124
000019FE  0700      4510          dc.w      1792
                    4511   ; switch (wait_type) {
00001A00  CEBC 0000 4512          and.l     #255,D7
00001A04  00FF      
00001A06  2007      4513          move.l    D7,D0
00001A08  0C80 0000 4514          cmp.l     #4,D0
00001A0C  0004      
00001A0E  6400 00BE 4515          bhs       OSFlagAccept_6
00001A12  E380      4516          asl.l     #1,D0
00001A14  303B 0806 4517          move.w    OSFlagAccept_8(PC,D0.L),D0
00001A18  4EFB 0002 4518          jmp       OSFlagAccept_8(PC,D0.W)
                    4519   OSFlagAccept_8:
00001A1C  0060      4520          dc.w      OSFlagAccept_11-OSFlagAccept_8
00001A1E  008A      4521          dc.w      OSFlagAccept_12-OSFlagAccept_8
00001A20  0008      4522          dc.w      OSFlagAccept_9-OSFlagAccept_8
00001A22  0034      4523          dc.w      OSFlagAccept_10-OSFlagAccept_8
                    4524   OSFlagAccept_9:
                    4525   ; case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
                    4526   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
00001A24  2043      4527          move.l    D3,A0
00001A26  3028 0006 4528          move.w    6(A0),D0
00001A2A  C045      4529          and.w     D5,D0
00001A2C  3400      4530          move.w    D0,D2
                    4531   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
00001A2E  B445      4532          cmp.w     D5,D2
00001A30  6612      4533          bne.s     OSFlagAccept_14
                    4534   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001A32  0C06 0001 4535          cmp.b     #1,D6
00001A36  660A      4536          bne.s     OSFlagAccept_16
                    4537   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we wanted  */
00001A38  2043      4538          move.l    D3,A0
00001A3A  3002      4539          move.w    D2,D0
00001A3C  4640      4540          not.w     D0
00001A3E  C168 0006 4541          and.w     D0,6(A0)
                    4542   OSFlagAccept_16:
00001A42  6006      4543          bra.s     OSFlagAccept_15
                    4544   OSFlagAccept_14:
                    4545   ; }
                    4546   ; } else {
                    4547   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001A44  2044      4548          move.l    D4,A0
00001A46  10BC 0070 4549          move.b    #112,(A0)
                    4550   OSFlagAccept_15:
                    4551   ; }
                    4552   ; OS_EXIT_CRITICAL();
00001A4A  46DF      4553          dc.w      18143
                    4554   ; break;
00001A4C  6000 008A 4555          bra       OSFlagAccept_7
                    4556   OSFlagAccept_10:
                    4557   ; case OS_FLAG_WAIT_SET_ANY:
                    4558   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
00001A50  2043      4559          move.l    D3,A0
00001A52  3028 0006 4560          move.w    6(A0),D0
00001A56  C045      4561          and.w     D5,D0
00001A58  3400      4562          move.w    D0,D2
                    4563   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
00001A5A  4A42      4564          tst.w     D2
00001A5C  6712      4565          beq.s     OSFlagAccept_18
                    4566   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001A5E  0C06 0001 4567          cmp.b     #1,D6
00001A62  660A      4568          bne.s     OSFlagAccept_20
                    4569   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we got     */
00001A64  2043      4570          move.l    D3,A0
00001A66  3002      4571          move.w    D2,D0
00001A68  4640      4572          not.w     D0
00001A6A  C168 0006 4573          and.w     D0,6(A0)
                    4574   OSFlagAccept_20:
00001A6E  6006      4575          bra.s     OSFlagAccept_19
                    4576   OSFlagAccept_18:
                    4577   ; }
                    4578   ; } else {
                    4579   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001A70  2044      4580          move.l    D4,A0
00001A72  10BC 0070 4581          move.b    #112,(A0)
                    4582   OSFlagAccept_19:
                    4583   ; }
                    4584   ; OS_EXIT_CRITICAL();
00001A76  46DF      4585          dc.w      18143
                    4586   ; break;
00001A78  6000 005E 4587          bra       OSFlagAccept_7
                    4588   OSFlagAccept_11:
                    4589   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    4590   ; case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
                    4591   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
00001A7C  2043      4592          move.l    D3,A0
00001A7E  3028 0006 4593          move.w    6(A0),D0
00001A82  4640      4594          not.w     D0
00001A84  C045      4595          and.w     D5,D0
00001A86  3400      4596          move.w    D0,D2
                    4597   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
00001A88  B445      4598          cmp.w     D5,D2
00001A8A  660E      4599          bne.s     OSFlagAccept_22
                    4600   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001A8C  0C06 0001 4601          cmp.b     #1,D6
00001A90  6606      4602          bne.s     OSFlagAccept_24
                    4603   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
00001A92  2043      4604          move.l    D3,A0
00001A94  8568 0006 4605          or.w      D2,6(A0)
                    4606   OSFlagAccept_24:
00001A98  6006      4607          bra.s     OSFlagAccept_23
                    4608   OSFlagAccept_22:
                    4609   ; }
                    4610   ; } else {
                    4611   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001A9A  2044      4612          move.l    D4,A0
00001A9C  10BC 0070 4613          move.b    #112,(A0)
                    4614   OSFlagAccept_23:
                    4615   ; }
                    4616   ; OS_EXIT_CRITICAL();
00001AA0  46DF      4617          dc.w      18143
                    4618   ; break;
00001AA2  6000 0034 4619          bra       OSFlagAccept_7
                    4620   OSFlagAccept_12:
                    4621   ; case OS_FLAG_WAIT_CLR_ANY:
                    4622   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
00001AA6  2043      4623          move.l    D3,A0
00001AA8  3028 0006 4624          move.w    6(A0),D0
00001AAC  4640      4625          not.w     D0
00001AAE  C045      4626          and.w     D5,D0
00001AB0  3400      4627          move.w    D0,D2
                    4628   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
00001AB2  4A42      4629          tst.w     D2
00001AB4  670E      4630          beq.s     OSFlagAccept_26
                    4631   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001AB6  0C06 0001 4632          cmp.b     #1,D6
00001ABA  6606      4633          bne.s     OSFlagAccept_28
                    4634   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
00001ABC  2043      4635          move.l    D3,A0
00001ABE  8568 0006 4636          or.w      D2,6(A0)
                    4637   OSFlagAccept_28:
00001AC2  6006      4638          bra.s     OSFlagAccept_27
                    4639   OSFlagAccept_26:
                    4640   ; }
                    4641   ; } else {
                    4642   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001AC4  2044      4643          move.l    D4,A0
00001AC6  10BC 0070 4644          move.b    #112,(A0)
                    4645   OSFlagAccept_27:
                    4646   ; }
                    4647   ; OS_EXIT_CRITICAL();
00001ACA  46DF      4648          dc.w      18143
                    4649   ; break;
00001ACC  600A      4650          bra.s     OSFlagAccept_7
                    4651   OSFlagAccept_6:
                    4652   ; #endif
                    4653   ; default:
                    4654   ; OS_EXIT_CRITICAL();
00001ACE  46DF      4655          dc.w      18143
                    4656   ; flags_rdy = (OS_FLAGS)0;
00001AD0  4242      4657          clr.w     D2
                    4658   ; *perr     = OS_ERR_FLAG_WAIT_TYPE;
00001AD2  2044      4659          move.l    D4,A0
00001AD4  10BC 006F 4660          move.b    #111,(A0)
                    4661   ; break;
                    4662   OSFlagAccept_7:
                    4663   ; }
                    4664   ; return (flags_rdy);
00001AD8  3002      4665          move.w    D2,D0
                    4666   OSFlagAccept_3:
00001ADA  4CDF 00FC 4667          movem.l   (A7)+,D2/D3/D4/D5/D6/D7
00001ADE  4E5E      4668          unlk      A6
00001AE0  4E75      4669          rts
                    4670   ; }
                    4671   ; #endif
                    4672   ; /*$PAGE*/
                    4673   ; /*
                    4674   ; *********************************************************************************************************
                    4675   ; *                                        CREATE AN EVENT FLAG
                    4676   ; *
                    4677   ; * Description: This function is called to create an event flag group.
                    4678   ; *
                    4679   ; * Arguments  : flags         Contains the initial value to store in the event flag group.
                    4680   ; *
                    4681   ; *              perr          is a pointer to an error code which will be returned to your application:
                    4682   ; *                               OS_ERR_NONE               if the call was successful.
                    4683   ; *                               OS_ERR_CREATE_ISR         if you attempted to create an Event Flag from an
                    4684   ; *                                                         ISR.
                    4685   ; *                               OS_ERR_FLAG_GRP_DEPLETED  if there are no more event flag groups
                    4686   ; *
                    4687   ; * Returns    : A pointer to an event flag group or a NULL pointer if no more groups are available.
                    4688   ; *
                    4689   ; * Called from: Task ONLY
                    4690   ; *********************************************************************************************************
                    4691   ; */
                    4692   ; OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS  flags,
                    4693   ; INT8U    *perr)
                    4694   ; {
                    4695   _OSFlagCreate:
00001AE2  4E56 0000 4696          link      A6,#0
00001AE6  48E7 3020 4697          movem.l   D2/D3/A2,-(A7)
00001AEA  45F9 0800 4698          lea       _OSFlagFreeList.L,A2
00001AEE  01FE      
00001AF0  262E 000C 4699          move.l    12(A6),D3
                    4700   ; OS_FLAG_GRP *pgrp;
                    4701   ; #if OS_CRITICAL_METHOD == 3u                        /* Allocate storage for CPU status register        */
                    4702   ; OS_CPU_SR    cpu_sr = 0u;
                    4703   ; #endif
                    4704   ; #ifdef OS_SAFETY_CRITICAL
                    4705   ; if (perr == (INT8U *)0) {
                    4706   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    4707   ; return ((OS_FLAG_GRP *)0);
                    4708   ; }
                    4709   ; #endif
                    4710   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    4711   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    4712   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    4713   ; return ((OS_FLAG_GRP *)0);
                    4714   ; }
                    4715   ; #endif
                    4716   ; if (OSIntNesting > 0u) {                        /* See if called from ISR ...                      */
00001AF4  1039 0800 4717          move.b    _OSIntNesting.L,D0
00001AF8  030E      
00001AFA  0C00 0000 4718          cmp.b     #0,D0
00001AFE  630C      4719          bls.s     OSFlagCreate_1
                    4720   ; *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
00001B00  2043      4721          move.l    D3,A0
00001B02  10BC 0010 4722          move.b    #16,(A0)
                    4723   ; return ((OS_FLAG_GRP *)0);
00001B06  4280      4724          clr.l     D0
00001B08  6000 0046 4725          bra       OSFlagCreate_3
                    4726   OSFlagCreate_1:
                    4727   ; }
                    4728   ; OS_ENTER_CRITICAL();
00001B0C  40E7      4729          dc.w      16615
00001B0E  007C      4730          dc.w      124
00001B10  0700      4731          dc.w      1792
                    4732   ; pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
00001B12  2412      4733          move.l    (A2),D2
                    4734   ; if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
00001B14  4A82      4735          tst.l     D2
00001B16  672E      4736          beq.s     OSFlagCreate_4
                    4737   ; /* Adjust free list                                */
                    4738   ; OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
00001B18  2052      4739          move.l    (A2),A0
00001B1A  24A8 0002 4740          move.l    2(A0),(A2)
                    4741   ; pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
00001B1E  2042      4742          move.l    D2,A0
00001B20  10BC 0005 4743          move.b    #5,(A0)
                    4744   ; pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
00001B24  2042      4745          move.l    D2,A0
00001B26  316E 000A 4746          move.w    10(A6),6(A0)
00001B2A  0006      
                    4747   ; pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
00001B2C  2042      4748          move.l    D2,A0
00001B2E  42A8 0002 4749          clr.l     2(A0)
                    4750   ; #if OS_FLAG_NAME_EN > 0u
                    4751   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
00001B32  41F9 0000 4752          lea       @ucos_ii_1.L,A0
00001B36  708C      
00001B38  2242      4753          move.l    D2,A1
00001B3A  2348 0008 4754          move.l    A0,8(A1)
                    4755   ; #endif
                    4756   ; OS_EXIT_CRITICAL();
00001B3E  46DF      4757          dc.w      18143
                    4758   ; *perr                = OS_ERR_NONE;
00001B40  2043      4759          move.l    D3,A0
00001B42  4210      4760          clr.b     (A0)
00001B44  6008      4761          bra.s     OSFlagCreate_5
                    4762   OSFlagCreate_4:
                    4763   ; } else {
                    4764   ; OS_EXIT_CRITICAL();
00001B46  46DF      4765          dc.w      18143
                    4766   ; *perr                = OS_ERR_FLAG_GRP_DEPLETED;
00001B48  2043      4767          move.l    D3,A0
00001B4A  10BC 0072 4768          move.b    #114,(A0)
                    4769   OSFlagCreate_5:
                    4770   ; }
                    4771   ; return (pgrp);                                  /* Return pointer to event flag group              */
00001B4E  2002      4772          move.l    D2,D0
                    4773   OSFlagCreate_3:
00001B50  4CDF 040C 4774          movem.l   (A7)+,D2/D3/A2
00001B54  4E5E      4775          unlk      A6
00001B56  4E75      4776          rts
                    4777   ; }
                    4778   ; /*$PAGE*/
                    4779   ; /*
                    4780   ; *********************************************************************************************************
                    4781   ; *                                     DELETE AN EVENT FLAG GROUP
                    4782   ; *
                    4783   ; * Description: This function deletes an event flag group and readies all tasks pending on the event flag
                    4784   ; *              group.
                    4785   ; *
                    4786   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    4787   ; *
                    4788   ; *              opt           determines delete options as follows:
                    4789   ; *                            opt == OS_DEL_NO_PEND   Deletes the event flag group ONLY if no task pending
                    4790   ; *                            opt == OS_DEL_ALWAYS    Deletes the event flag group even if tasks are
                    4791   ; *                                                    waiting.  In this case, all the tasks pending will be
                    4792   ; *                                                    readied.
                    4793   ; *
                    4794   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    4795   ; *                            OS_ERR_NONE               The call was successful and the event flag group was
                    4796   ; *                                                      deleted
                    4797   ; *                            OS_ERR_DEL_ISR            If you attempted to delete the event flag group from
                    4798   ; *                                                      an ISR
                    4799   ; *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
                    4800   ; *                            OS_ERR_EVENT_TYPE         If you didn't pass a pointer to an event flag group
                    4801   ; *                            OS_ERR_INVALID_OPT        An invalid option was specified
                    4802   ; *                            OS_ERR_TASK_WAITING       One or more tasks were waiting on the event flag
                    4803   ; *                                                      group.
                    4804   ; *
                    4805   ; * Returns    : pgrp          upon error
                    4806   ; *              (OS_EVENT *)0 if the event flag group was successfully deleted.
                    4807   ; *
                    4808   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    4809   ; *                 the event flag group MUST check the return code of OSFlagAccept() and OSFlagPend().
                    4810   ; *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
                    4811   ; *                 time is directly proportional to the number of tasks waiting on the event flag group.
                    4812   ; *              3) All tasks that were waiting for the event flag will be readied and returned an
                    4813   ; *                 OS_ERR_PEND_ABORT if OSFlagDel() was called with OS_DEL_ALWAYS
                    4814   ; *********************************************************************************************************
                    4815   ; */
                    4816   ; #if OS_FLAG_DEL_EN > 0u
                    4817   ; OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP  *pgrp,
                    4818   ; INT8U         opt,
                    4819   ; INT8U        *perr)
                    4820   ; {
                    4821   _OSFlagDel:
00001B58  4E56 0000 4822          link      A6,#0
00001B5C  48E7 3E20 4823          movem.l   D2/D3/D4/D5/D6/A2,-(A7)
00001B60  242E 0008 4824          move.l    8(A6),D2
00001B64  262E 0010 4825          move.l    16(A6),D3
00001B68  45F9 0800 4826          lea       _OSFlagFreeList.L,A2
00001B6C  01FE      
                    4827   ; BOOLEAN       tasks_waiting;
                    4828   ; OS_FLAG_NODE *pnode;
                    4829   ; OS_FLAG_GRP  *pgrp_return;
                    4830   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    4831   ; OS_CPU_SR     cpu_sr = 0u;
                    4832   ; #endif
                    4833   ; #ifdef OS_SAFETY_CRITICAL
                    4834   ; if (perr == (INT8U *)0) {
                    4835   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    4836   ; return ((OS_FLAG_GRP *)0);
                    4837   ; }
                    4838   ; #endif
                    4839   ; #if OS_ARG_CHK_EN > 0u
                    4840   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    4841   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    4842   ; return (pgrp);
                    4843   ; }
                    4844   ; #endif
                    4845   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00001B6E  1039 0800 4846          move.b    _OSIntNesting.L,D0
00001B72  030E      
00001B74  0C00 0000 4847          cmp.b     #0,D0
00001B78  630C      4848          bls.s     OSFlagDel_1
                    4849   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
00001B7A  2043      4850          move.l    D3,A0
00001B7C  10BC 000F 4851          move.b    #15,(A0)
                    4852   ; return (pgrp);
00001B80  2002      4853          move.l    D2,D0
00001B82  6000 00EC 4854          bra       OSFlagDel_3
                    4855   OSFlagDel_1:
                    4856   ; }
                    4857   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
00001B86  2042      4858          move.l    D2,A0
00001B88  1010      4859          move.b    (A0),D0
00001B8A  0C00 0005 4860          cmp.b     #5,D0
00001B8E  670C      4861          beq.s     OSFlagDel_4
                    4862   ; *perr = OS_ERR_EVENT_TYPE;
00001B90  2043      4863          move.l    D3,A0
00001B92  10BC 0001 4864          move.b    #1,(A0)
                    4865   ; return (pgrp);
00001B96  2002      4866          move.l    D2,D0
00001B98  6000 00D6 4867          bra       OSFlagDel_3
                    4868   OSFlagDel_4:
                    4869   ; }
                    4870   ; OS_ENTER_CRITICAL();
00001B9C  40E7      4871          dc.w      16615
00001B9E  007C      4872          dc.w      124
00001BA0  0700      4873          dc.w      1792
                    4874   ; if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
00001BA2  2042      4875          move.l    D2,A0
00001BA4  2028 0002 4876          move.l    2(A0),D0
00001BA8  6704      4877          beq.s     OSFlagDel_6
                    4878   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
00001BAA  7C01      4879          moveq     #1,D6
00001BAC  6002      4880          bra.s     OSFlagDel_7
                    4881   OSFlagDel_6:
                    4882   ; } else {
                    4883   ; tasks_waiting = OS_FALSE;                          /* No                                       */
00001BAE  4206      4884          clr.b     D6
                    4885   OSFlagDel_7:
                    4886   ; }
                    4887   ; switch (opt) {
00001BB0  102E 000F 4888          move.b    15(A6),D0
00001BB4  C0BC 0000 4889          and.l     #255,D0
00001BB8  00FF      
00001BBA  0C80 0000 4890          cmp.l     #1,D0
00001BBE  0001      
00001BC0  6700 0048 4891          beq       OSFlagDel_11
00001BC4  6200 009E 4892          bhi       OSFlagDel_8
00001BC8  4A80      4893          tst.l     D0
00001BCA  6704      4894          beq.s     OSFlagDel_10
00001BCC  6000 0096 4895          bra       OSFlagDel_8
                    4896   OSFlagDel_10:
                    4897   ; case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
                    4898   ; if (tasks_waiting == OS_FALSE) {
00001BD0  4A06      4899          tst.b     D6
00001BD2  6628      4900          bne.s     OSFlagDel_13
                    4901   ; #if OS_FLAG_NAME_EN > 0u
                    4902   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
00001BD4  41F9 0000 4903          lea       @ucos_ii_1.L,A0
00001BD8  708C      
00001BDA  2242      4904          move.l    D2,A1
00001BDC  2348 0008 4905          move.l    A0,8(A1)
                    4906   ; #endif
                    4907   ; pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00001BE0  2042      4908          move.l    D2,A0
00001BE2  4210      4909          clr.b     (A0)
                    4910   ; pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
00001BE4  2042      4911          move.l    D2,A0
00001BE6  2152 0002 4912          move.l    (A2),2(A0)
                    4913   ; pgrp->OSFlagFlags    = (OS_FLAGS)0;
00001BEA  2042      4914          move.l    D2,A0
00001BEC  4268 0006 4915          clr.w     6(A0)
                    4916   ; OSFlagFreeList       = pgrp;
00001BF0  2482      4917          move.l    D2,(A2)
                    4918   ; OS_EXIT_CRITICAL();
00001BF2  46DF      4919          dc.w      18143
                    4920   ; *perr                = OS_ERR_NONE;
00001BF4  2043      4921          move.l    D3,A0
00001BF6  4210      4922          clr.b     (A0)
                    4923   ; pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
00001BF8  4285      4924          clr.l     D5
00001BFA  600A      4925          bra.s     OSFlagDel_14
                    4926   OSFlagDel_13:
                    4927   ; } else {
                    4928   ; OS_EXIT_CRITICAL();
00001BFC  46DF      4929          dc.w      18143
                    4930   ; *perr                = OS_ERR_TASK_WAITING;
00001BFE  2043      4931          move.l    D3,A0
00001C00  10BC 0049 4932          move.b    #73,(A0)
                    4933   ; pgrp_return          = pgrp;
00001C04  2A02      4934          move.l    D2,D5
                    4935   OSFlagDel_14:
                    4936   ; }
                    4937   ; break;
00001C06  6000 0066 4938          bra       OSFlagDel_9
                    4939   OSFlagDel_11:
                    4940   ; case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
                    4941   ; pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
00001C0A  2042      4942          move.l    D2,A0
00001C0C  2828 0002 4943          move.l    2(A0),D4
                    4944   ; while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
                    4945   OSFlagDel_15:
00001C10  4A84      4946          tst.l     D4
00001C12  671E      4947          beq.s     OSFlagDel_17
                    4948   ; (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0, OS_STAT_PEND_ABORT);
00001C14  4878 0002 4949          pea       2
00001C18  42A7      4950          clr.l     -(A7)
00001C1A  2F04      4951          move.l    D4,-(A7)
00001C1C  4EB9 0000 4952          jsr       @ucos_ii_OS_FlagTaskRdy
00001C20  238E      
00001C22  DEFC 000C 4953          add.w     #12,A7
00001C26  C0BC 0000 4954          and.l     #255,D0
00001C2A  00FF      
                    4955   ; pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
00001C2C  2044      4956          move.l    D4,A0
00001C2E  2810      4957          move.l    (A0),D4
00001C30  60DE      4958          bra       OSFlagDel_15
                    4959   OSFlagDel_17:
                    4960   ; }
                    4961   ; #if OS_FLAG_NAME_EN > 0u
                    4962   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
00001C32  41F9 0000 4963          lea       @ucos_ii_1.L,A0
00001C36  708C      
00001C38  2242      4964          move.l    D2,A1
00001C3A  2348 0008 4965          move.l    A0,8(A1)
                    4966   ; #endif
                    4967   ; pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00001C3E  2042      4968          move.l    D2,A0
00001C40  4210      4969          clr.b     (A0)
                    4970   ; pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
00001C42  2042      4971          move.l    D2,A0
00001C44  2152 0002 4972          move.l    (A2),2(A0)
                    4973   ; pgrp->OSFlagFlags    = (OS_FLAGS)0;
00001C48  2042      4974          move.l    D2,A0
00001C4A  4268 0006 4975          clr.w     6(A0)
                    4976   ; OSFlagFreeList       = pgrp;
00001C4E  2482      4977          move.l    D2,(A2)
                    4978   ; OS_EXIT_CRITICAL();
00001C50  46DF      4979          dc.w      18143
                    4980   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00001C52  0C06 0001 4981          cmp.b     #1,D6
00001C56  6604      4982          bne.s     OSFlagDel_18
                    4983   ; OS_Sched();                               /* Find highest priority task ready to run  */
00001C58  4EB8 15DA 4984          jsr       _OS_Sched
                    4985   OSFlagDel_18:
                    4986   ; }
                    4987   ; *perr = OS_ERR_NONE;
00001C5C  2043      4988          move.l    D3,A0
00001C5E  4210      4989          clr.b     (A0)
                    4990   ; pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
00001C60  4285      4991          clr.l     D5
                    4992   ; break;
00001C62  600A      4993          bra.s     OSFlagDel_9
                    4994   OSFlagDel_8:
                    4995   ; default:
                    4996   ; OS_EXIT_CRITICAL();
00001C64  46DF      4997          dc.w      18143
                    4998   ; *perr                = OS_ERR_INVALID_OPT;
00001C66  2043      4999          move.l    D3,A0
00001C68  10BC 0007 5000          move.b    #7,(A0)
                    5001   ; pgrp_return          = pgrp;
00001C6C  2A02      5002          move.l    D2,D5
                    5003   ; break;
                    5004   OSFlagDel_9:
                    5005   ; }
                    5006   ; return (pgrp_return);
00001C6E  2005      5007          move.l    D5,D0
                    5008   OSFlagDel_3:
00001C70  4CDF 047C 5009          movem.l   (A7)+,D2/D3/D4/D5/D6/A2
00001C74  4E5E      5010          unlk      A6
00001C76  4E75      5011          rts
                    5012   ; }
                    5013   ; #endif
                    5014   ; /*$PAGE*/
                    5015   ; /*
                    5016   ; *********************************************************************************************************
                    5017   ; *                                 GET THE NAME OF AN EVENT FLAG GROUP
                    5018   ; *
                    5019   ; * Description: This function is used to obtain the name assigned to an event flag group
                    5020   ; *
                    5021   ; * Arguments  : pgrp      is a pointer to the event flag group.
                    5022   ; *
                    5023   ; *              pname     is pointer to a pointer to an ASCII string that will receive the name of the event flag
                    5024   ; *                        group.
                    5025   ; *
                    5026   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    5027   ; *
                    5028   ; *                        OS_ERR_NONE                if the requested task is resumed
                    5029   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
                    5030   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    5031   ; *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
                    5032   ; *                        OS_ERR_NAME_GET_ISR        if you called this function from an ISR
                    5033   ; *
                    5034   ; * Returns    : The length of the string or 0 if the 'pgrp' is a NULL pointer.
                    5035   ; *********************************************************************************************************
                    5036   ; */
                    5037   ; #if OS_FLAG_NAME_EN > 0u
                    5038   ; INT8U  OSFlagNameGet (OS_FLAG_GRP   *pgrp,
                    5039   ; INT8U        **pname,
                    5040   ; INT8U         *perr)
                    5041   ; {
                    5042   _OSFlagNameGet:
00001C78  4E56 FFFC 5043          link      A6,#-4
00001C7C  2F02      5044          move.l    D2,-(A7)
00001C7E  242E 0010 5045          move.l    16(A6),D2
                    5046   ; INT8U      len;
                    5047   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    5048   ; OS_CPU_SR  cpu_sr = 0u;
                    5049   ; #endif
                    5050   ; #ifdef OS_SAFETY_CRITICAL
                    5051   ; if (perr == (INT8U *)0) {
                    5052   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5053   ; return (0u);
                    5054   ; }
                    5055   ; #endif
                    5056   ; #if OS_ARG_CHK_EN > 0u
                    5057   ; if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
                    5058   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5059   ; return (0u);
                    5060   ; }
                    5061   ; if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
                    5062   ; *perr = OS_ERR_PNAME_NULL;
                    5063   ; return (0u);
                    5064   ; }
                    5065   ; #endif
                    5066   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00001C82  1039 0800 5067          move.b    _OSIntNesting.L,D0
00001C86  030E      
00001C88  0C00 0000 5068          cmp.b     #0,D0
00001C8C  630C      5069          bls.s     OSFlagNameGet_1
                    5070   ; *perr = OS_ERR_NAME_GET_ISR;
00001C8E  2042      5071          move.l    D2,A0
00001C90  10BC 0011 5072          move.b    #17,(A0)
                    5073   ; return (0u);
00001C94  4200      5074          clr.b     D0
00001C96  6000 0046 5075          bra       OSFlagNameGet_3
                    5076   OSFlagNameGet_1:
                    5077   ; }
                    5078   ; OS_ENTER_CRITICAL();
00001C9A  40E7      5079          dc.w      16615
00001C9C  007C      5080          dc.w      124
00001C9E  0700      5081          dc.w      1792
                    5082   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
00001CA0  206E 0008 5083          move.l    8(A6),A0
00001CA4  1010      5084          move.b    (A0),D0
00001CA6  0C00 0005 5085          cmp.b     #5,D0
00001CAA  670C      5086          beq.s     OSFlagNameGet_4
                    5087   ; OS_EXIT_CRITICAL();
00001CAC  46DF      5088          dc.w      18143
                    5089   ; *perr = OS_ERR_EVENT_TYPE;
00001CAE  2042      5090          move.l    D2,A0
00001CB0  10BC 0001 5091          move.b    #1,(A0)
                    5092   ; return (0u);
00001CB4  4200      5093          clr.b     D0
00001CB6  6026      5094          bra.s     OSFlagNameGet_3
                    5095   OSFlagNameGet_4:
                    5096   ; }
                    5097   ; *pname = pgrp->OSFlagName;
00001CB8  206E 0008 5098          move.l    8(A6),A0
00001CBC  226E 000C 5099          move.l    12(A6),A1
00001CC0  22A8 0008 5100          move.l    8(A0),(A1)
                    5101   ; len    = OS_StrLen(*pname);
00001CC4  206E 000C 5102          move.l    12(A6),A0
00001CC8  2F10      5103          move.l    (A0),-(A7)
00001CCA  4EB8 1684 5104          jsr       _OS_StrLen
00001CCE  584F      5105          addq.w    #4,A7
00001CD0  1D40 FFFF 5106          move.b    D0,-1(A6)
                    5107   ; OS_EXIT_CRITICAL();
00001CD4  46DF      5108          dc.w      18143
                    5109   ; *perr  = OS_ERR_NONE;
00001CD6  2042      5110          move.l    D2,A0
00001CD8  4210      5111          clr.b     (A0)
                    5112   ; return (len);
00001CDA  102E FFFF 5113          move.b    -1(A6),D0
                    5114   OSFlagNameGet_3:
00001CDE  241F      5115          move.l    (A7)+,D2
00001CE0  4E5E      5116          unlk      A6
00001CE2  4E75      5117          rts
                    5118   ; }
                    5119   ; #endif
                    5120   ; /*$PAGE*/
                    5121   ; /*
                    5122   ; *********************************************************************************************************
                    5123   ; *                                ASSIGN A NAME TO AN EVENT FLAG GROUP
                    5124   ; *
                    5125   ; * Description: This function assigns a name to an event flag group.
                    5126   ; *
                    5127   ; * Arguments  : pgrp      is a pointer to the event flag group.
                    5128   ; *
                    5129   ; *              pname     is a pointer to an ASCII string that will be used as the name of the event flag
                    5130   ; *                        group.
                    5131   ; *
                    5132   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    5133   ; *
                    5134   ; *                        OS_ERR_NONE                if the requested task is resumed
                    5135   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
                    5136   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    5137   ; *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
                    5138   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    5139   ; *
                    5140   ; * Returns    : None
                    5141   ; *********************************************************************************************************
                    5142   ; */
                    5143   ; #if OS_FLAG_NAME_EN > 0u
                    5144   ; void  OSFlagNameSet (OS_FLAG_GRP  *pgrp,
                    5145   ; INT8U        *pname,
                    5146   ; INT8U        *perr)
                    5147   ; {
                    5148   _OSFlagNameSet:
00001CE4  4E56 0000 5149          link      A6,#0
00001CE8  2F02      5150          move.l    D2,-(A7)
00001CEA  242E 0010 5151          move.l    16(A6),D2
                    5152   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    5153   ; OS_CPU_SR  cpu_sr = 0u;
                    5154   ; #endif
                    5155   ; #ifdef OS_SAFETY_CRITICAL
                    5156   ; if (perr == (INT8U *)0) {
                    5157   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5158   ; return;
                    5159   ; }
                    5160   ; #endif
                    5161   ; #if OS_ARG_CHK_EN > 0u
                    5162   ; if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
                    5163   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5164   ; return;
                    5165   ; }
                    5166   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    5167   ; *perr = OS_ERR_PNAME_NULL;
                    5168   ; return;
                    5169   ; }
                    5170   ; #endif
                    5171   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00001CEE  1039 0800 5172          move.b    _OSIntNesting.L,D0
00001CF2  030E      
00001CF4  0C00 0000 5173          cmp.b     #0,D0
00001CF8  630A      5174          bls.s     OSFlagNameSet_1
                    5175   ; *perr = OS_ERR_NAME_SET_ISR;
00001CFA  2042      5176          move.l    D2,A0
00001CFC  10BC 0012 5177          move.b    #18,(A0)
                    5178   ; return;
00001D00  6000 002E 5179          bra       OSFlagNameSet_3
                    5180   OSFlagNameSet_1:
                    5181   ; }
                    5182   ; OS_ENTER_CRITICAL();
00001D04  40E7      5183          dc.w      16615
00001D06  007C      5184          dc.w      124
00001D08  0700      5185          dc.w      1792
                    5186   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
00001D0A  206E 0008 5187          move.l    8(A6),A0
00001D0E  1010      5188          move.b    (A0),D0
00001D10  0C00 0005 5189          cmp.b     #5,D0
00001D14  670A      5190          beq.s     OSFlagNameSet_4
                    5191   ; OS_EXIT_CRITICAL();
00001D16  46DF      5192          dc.w      18143
                    5193   ; *perr = OS_ERR_EVENT_TYPE;
00001D18  2042      5194          move.l    D2,A0
00001D1A  10BC 0001 5195          move.b    #1,(A0)
                    5196   ; return;
00001D1E  6010      5197          bra.s     OSFlagNameSet_3
                    5198   OSFlagNameSet_4:
                    5199   ; }
                    5200   ; pgrp->OSFlagName = pname;
00001D20  206E 0008 5201          move.l    8(A6),A0
00001D24  216E 000C 5202          move.l    12(A6),8(A0)
00001D28  0008      
                    5203   ; OS_EXIT_CRITICAL();
00001D2A  46DF      5204          dc.w      18143
                    5205   ; *perr            = OS_ERR_NONE;
00001D2C  2042      5206          move.l    D2,A0
00001D2E  4210      5207          clr.b     (A0)
                    5208   ; return;
                    5209   OSFlagNameSet_3:
00001D30  241F      5210          move.l    (A7)+,D2
00001D32  4E5E      5211          unlk      A6
00001D34  4E75      5212          rts
                    5213   ; }
                    5214   ; #endif
                    5215   ; /*$PAGE*/
                    5216   ; /*
                    5217   ; *********************************************************************************************************
                    5218   ; *                                     WAIT ON AN EVENT FLAG GROUP
                    5219   ; *
                    5220   ; * Description: This function is called to wait for a combination of bits to be set in an event flag
                    5221   ; *              group.  Your application can wait for ANY bit to be set or ALL bits to be set.
                    5222   ; *
                    5223   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    5224   ; *
                    5225   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to wait for.
                    5226   ; *                            The bits you want are specified by setting the corresponding bits in
                    5227   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    5228   ; *                            'flags' would contain 0x03.
                    5229   ; *
                    5230   ; *              wait_type     specifies whether you want ALL bits to be set or ANY of the bits to be set.
                    5231   ; *                            You can specify the following argument:
                    5232   ; *
                    5233   ; *                            OS_FLAG_WAIT_CLR_ALL   You will wait for ALL bits in 'mask' to be clear (0)
                    5234   ; *                            OS_FLAG_WAIT_SET_ALL   You will wait for ALL bits in 'mask' to be set   (1)
                    5235   ; *                            OS_FLAG_WAIT_CLR_ANY   You will wait for ANY bit  in 'mask' to be clear (0)
                    5236   ; *                            OS_FLAG_WAIT_SET_ANY   You will wait for ANY bit  in 'mask' to be set   (1)
                    5237   ; *
                    5238   ; *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
                    5239   ; *                                  the call.  Example, to wait for any flag in a group AND then clear
                    5240   ; *                                  the flags that are present, set 'wait_type' to:
                    5241   ; *
                    5242   ; *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
                    5243   ; *
                    5244   ; *              timeout       is an optional timeout (in clock ticks) that your task will wait for the
                    5245   ; *                            desired bit combination.  If you specify 0, however, your task will wait
                    5246   ; *                            forever at the specified event flag group or, until a message arrives.
                    5247   ; *
                    5248   ; *              perr          is a pointer to an error code and can be:
                    5249   ; *                            OS_ERR_NONE               The desired bits have been set within the specified
                    5250   ; *                                                      'timeout'.
                    5251   ; *                            OS_ERR_PEND_ISR           If you tried to PEND from an ISR
                    5252   ; *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
                    5253   ; *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
                    5254   ; *                            OS_ERR_TIMEOUT            The bit(s) have not been set in the specified
                    5255   ; *                                                      'timeout'.
                    5256   ; *                            OS_ERR_PEND_ABORT         The wait on the flag was aborted.
                    5257   ; *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
                    5258   ; *
                    5259   ; * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
                    5260   ; *              occurred.
                    5261   ; *
                    5262   ; * Called from: Task ONLY
                    5263   ; *
                    5264   ; * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
                    5265   ; *                 function NOW returns the flags that were ready INSTEAD of the current state of the
                    5266   ; *                 event flags.
                    5267   ; *********************************************************************************************************
                    5268   ; */
                    5269   ; OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *pgrp,
                    5270   ; OS_FLAGS      flags,
                    5271   ; INT8U         wait_type,
                    5272   ; INT32U        timeout,
                    5273   ; INT8U        *perr)
                    5274   ; {
                    5275   _OSFlagPend:
00001D36  4E56 FFE8 5276          link      A6,#-24
00001D3A  48E7 3F3C 5277          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00001D3E  262E 0008 5278          move.l    8(A6),D3
00001D42  282E 0018 5279          move.l    24(A6),D4
00001D46  3A2E 000E 5280          move.w    14(A6),D5
00001D4A  CABC 0000 5281          and.l     #65535,D5
00001D4E  FFFF      
00001D50  45F9 0800 5282          lea       _OSTCBCur.L,A2
00001D54  0428      
00001D56  1C2E 0013 5283          move.b    19(A6),D6
00001D5A  CCBC 0000 5284          and.l     #255,D6
00001D5E  00FF      
00001D60  47EE FFEA 5285          lea       -22(A6),A3
00001D64  286E 0014 5286          move.l    20(A6),A4
00001D68  4BF9 0000 5287          lea       @ucos_ii_OS_FlagBlock.L,A5
00001D6C  2230      
                    5288   ; OS_FLAG_NODE  node;
                    5289   ; OS_FLAGS      flags_rdy;
                    5290   ; INT8U         result;
                    5291   ; INT8U         pend_stat;
                    5292   ; BOOLEAN       consume;
                    5293   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    5294   ; OS_CPU_SR     cpu_sr = 0u;
                    5295   ; #endif
                    5296   ; #ifdef OS_SAFETY_CRITICAL
                    5297   ; if (perr == (INT8U *)0) {
                    5298   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5299   ; return ((OS_FLAGS)0);
                    5300   ; }
                    5301   ; #endif
                    5302   ; #if OS_ARG_CHK_EN > 0u
                    5303   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    5304   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5305   ; return ((OS_FLAGS)0);
                    5306   ; }
                    5307   ; #endif
                    5308   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00001D6E  1039 0800 5309          move.b    _OSIntNesting.L,D0
00001D72  030E      
00001D74  0C00 0000 5310          cmp.b     #0,D0
00001D78  630C      5311          bls.s     OSFlagPend_1
                    5312   ; *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
00001D7A  2044      5313          move.l    D4,A0
00001D7C  10BC 0002 5314          move.b    #2,(A0)
                    5315   ; return ((OS_FLAGS)0);
00001D80  4240      5316          clr.w     D0
00001D82  6000 028A 5317          bra       OSFlagPend_3
                    5318   OSFlagPend_1:
                    5319   ; }
                    5320   ; if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
00001D86  1039 0800 5321          move.b    _OSLockNesting.L,D0
00001D8A  0310      
00001D8C  0C00 0000 5322          cmp.b     #0,D0
00001D90  630C      5323          bls.s     OSFlagPend_4
                    5324   ; *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
00001D92  2044      5325          move.l    D4,A0
00001D94  10BC 000D 5326          move.b    #13,(A0)
                    5327   ; return ((OS_FLAGS)0);
00001D98  4240      5328          clr.w     D0
00001D9A  6000 0272 5329          bra       OSFlagPend_3
                    5330   OSFlagPend_4:
                    5331   ; }
                    5332   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
00001D9E  2043      5333          move.l    D3,A0
00001DA0  1010      5334          move.b    (A0),D0
00001DA2  0C00 0005 5335          cmp.b     #5,D0
00001DA6  670C      5336          beq.s     OSFlagPend_6
                    5337   ; *perr = OS_ERR_EVENT_TYPE;
00001DA8  2044      5338          move.l    D4,A0
00001DAA  10BC 0001 5339          move.b    #1,(A0)
                    5340   ; return ((OS_FLAGS)0);
00001DAE  4240      5341          clr.w     D0
00001DB0  6000 025C 5342          bra       OSFlagPend_3
                    5343   OSFlagPend_6:
                    5344   ; }
                    5345   ; result = (INT8U)(wait_type & OS_FLAG_CONSUME);
00001DB4  1006      5346          move.b    D6,D0
00001DB6  C03C 0080 5347          and.b     #128,D0
00001DBA  1D40 FFFE 5348          move.b    D0,-2(A6)
                    5349   ; if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
00001DBE  102E FFFE 5350          move.b    -2(A6),D0
00001DC2  670C      5351          beq.s     OSFlagPend_8
                    5352   ; wait_type &= (INT8U)~(INT8U)OS_FLAG_CONSUME;
00001DC4  103C 0080 5353          move.b    #128,D0
00001DC8  4600      5354          not.b     D0
00001DCA  CC00      5355          and.b     D0,D6
                    5356   ; consume    = OS_TRUE;
00001DCC  7E01      5357          moveq     #1,D7
00001DCE  6002      5358          bra.s     OSFlagPend_9
                    5359   OSFlagPend_8:
                    5360   ; } else {
                    5361   ; consume    = OS_FALSE;
00001DD0  7E00      5362          moveq     #0,D7
                    5363   OSFlagPend_9:
                    5364   ; }
                    5365   ; /*$PAGE*/
                    5366   ; OS_ENTER_CRITICAL();
00001DD2  40E7      5367          dc.w      16615
00001DD4  007C      5368          dc.w      124
00001DD6  0700      5369          dc.w      1792
                    5370   ; switch (wait_type) {
00001DD8  CCBC 0000 5371          and.l     #255,D6
00001DDC  00FF      
00001DDE  2006      5372          move.l    D6,D0
00001DE0  0C80 0000 5373          cmp.l     #4,D0
00001DE4  0004      
00001DE6  6400 0156 5374          bhs       OSFlagPend_10
00001DEA  E380      5375          asl.l     #1,D0
00001DEC  303B 0806 5376          move.w    OSFlagPend_12(PC,D0.L),D0
00001DF0  4EFB 0002 5377          jmp       OSFlagPend_12(PC,D0.W)
                    5378   OSFlagPend_12:
00001DF4  00AC      5379          dc.w      OSFlagPend_15-OSFlagPend_12
00001DF6  00FC      5380          dc.w      OSFlagPend_16-OSFlagPend_12
00001DF8  0008      5381          dc.w      OSFlagPend_13-OSFlagPend_12
00001DFA  005A      5382          dc.w      OSFlagPend_14-OSFlagPend_12
                    5383   OSFlagPend_13:
                    5384   ; case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
                    5385   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
00001DFC  2043      5386          move.l    D3,A0
00001DFE  3028 0006 5387          move.w    6(A0),D0
00001E02  C045      5388          and.w     D5,D0
00001E04  3400      5389          move.w    D0,D2
                    5390   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
00001E06  B445      5391          cmp.w     D5,D2
00001E08  6622      5392          bne.s     OSFlagPend_18
                    5393   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001E0A  0C07 0001 5394          cmp.b     #1,D7
00001E0E  660A      5395          bne.s     OSFlagPend_20
                    5396   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;   /* Clear ONLY the flags we wanted    */
00001E10  2043      5397          move.l    D3,A0
00001E12  3002      5398          move.w    D2,D0
00001E14  4640      5399          not.w     D0
00001E16  C168 0006 5400          and.w     D0,6(A0)
                    5401   OSFlagPend_20:
                    5402   ; }
                    5403   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
00001E1A  2052      5404          move.l    (A2),A0
00001E1C  3142 002C 5405          move.w    D2,44(A0)
                    5406   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
00001E20  46DF      5407          dc.w      18143
                    5408   ; *perr                   = OS_ERR_NONE;
00001E22  2044      5409          move.l    D4,A0
00001E24  4210      5410          clr.b     (A0)
                    5411   ; return (flags_rdy);
00001E26  3002      5412          move.w    D2,D0
00001E28  6000 01E4 5413          bra       OSFlagPend_3
                    5414   OSFlagPend_18:
                    5415   ; } else {                                      /* Block task until events occur or timeout */
                    5416   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00001E2C  2F0C      5417          move.l    A4,-(A7)
00001E2E  CCBC 0000 5418          and.l     #255,D6
00001E32  00FF      
00001E34  2F06      5419          move.l    D6,-(A7)
00001E36  CABC 0000 5420          and.l     #65535,D5
00001E3A  FFFF      
00001E3C  2F05      5421          move.l    D5,-(A7)
00001E3E  2F0B      5422          move.l    A3,-(A7)
00001E40  2F03      5423          move.l    D3,-(A7)
00001E42  4E95      5424          jsr       (A5)
00001E44  DEFC 0014 5425          add.w     #20,A7
                    5426   ; OS_EXIT_CRITICAL();
00001E48  46DF      5427          dc.w      18143
                    5428   ; }
                    5429   ; break;
00001E4A  6000 0102 5430          bra       OSFlagPend_11
                    5431   OSFlagPend_14:
                    5432   ; case OS_FLAG_WAIT_SET_ANY:
                    5433   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
00001E4E  2043      5434          move.l    D3,A0
00001E50  3028 0006 5435          move.w    6(A0),D0
00001E54  C045      5436          and.w     D5,D0
00001E56  3400      5437          move.w    D0,D2
                    5438   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
00001E58  4A42      5439          tst.w     D2
00001E5A  6722      5440          beq.s     OSFlagPend_22
                    5441   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001E5C  0C07 0001 5442          cmp.b     #1,D7
00001E60  660A      5443          bne.s     OSFlagPend_24
                    5444   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;    /* Clear ONLY the flags that we got */
00001E62  2043      5445          move.l    D3,A0
00001E64  3002      5446          move.w    D2,D0
00001E66  4640      5447          not.w     D0
00001E68  C168 0006 5448          and.w     D0,6(A0)
                    5449   OSFlagPend_24:
                    5450   ; }
                    5451   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
00001E6C  2052      5452          move.l    (A2),A0
00001E6E  3142 002C 5453          move.w    D2,44(A0)
                    5454   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
00001E72  46DF      5455          dc.w      18143
                    5456   ; *perr                   = OS_ERR_NONE;
00001E74  2044      5457          move.l    D4,A0
00001E76  4210      5458          clr.b     (A0)
                    5459   ; return (flags_rdy);
00001E78  3002      5460          move.w    D2,D0
00001E7A  6000 0192 5461          bra       OSFlagPend_3
                    5462   OSFlagPend_22:
                    5463   ; } else {                                      /* Block task until events occur or timeout */
                    5464   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00001E7E  2F0C      5465          move.l    A4,-(A7)
00001E80  CCBC 0000 5466          and.l     #255,D6
00001E84  00FF      
00001E86  2F06      5467          move.l    D6,-(A7)
00001E88  CABC 0000 5468          and.l     #65535,D5
00001E8C  FFFF      
00001E8E  2F05      5469          move.l    D5,-(A7)
00001E90  2F0B      5470          move.l    A3,-(A7)
00001E92  2F03      5471          move.l    D3,-(A7)
00001E94  4E95      5472          jsr       (A5)
00001E96  DEFC 0014 5473          add.w     #20,A7
                    5474   ; OS_EXIT_CRITICAL();
00001E9A  46DF      5475          dc.w      18143
                    5476   ; }
                    5477   ; break;
00001E9C  6000 00B0 5478          bra       OSFlagPend_11
                    5479   OSFlagPend_15:
                    5480   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    5481   ; case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
                    5482   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
00001EA0  2043      5483          move.l    D3,A0
00001EA2  3028 0006 5484          move.w    6(A0),D0
00001EA6  4640      5485          not.w     D0
00001EA8  C045      5486          and.w     D5,D0
00001EAA  3400      5487          move.w    D0,D2
                    5488   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
00001EAC  B445      5489          cmp.w     D5,D2
00001EAE  661E      5490          bne.s     OSFlagPend_26
                    5491   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001EB0  0C07 0001 5492          cmp.b     #1,D7
00001EB4  6606      5493          bne.s     OSFlagPend_28
                    5494   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
00001EB6  2043      5495          move.l    D3,A0
00001EB8  8568 0006 5496          or.w      D2,6(A0)
                    5497   OSFlagPend_28:
                    5498   ; }
                    5499   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
00001EBC  2052      5500          move.l    (A2),A0
00001EBE  3142 002C 5501          move.w    D2,44(A0)
                    5502   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
00001EC2  46DF      5503          dc.w      18143
                    5504   ; *perr                   = OS_ERR_NONE;
00001EC4  2044      5505          move.l    D4,A0
00001EC6  4210      5506          clr.b     (A0)
                    5507   ; return (flags_rdy);
00001EC8  3002      5508          move.w    D2,D0
00001ECA  6000 0142 5509          bra       OSFlagPend_3
                    5510   OSFlagPend_26:
                    5511   ; } else {                                      /* Block task until events occur or timeout */
                    5512   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00001ECE  2F0C      5513          move.l    A4,-(A7)
00001ED0  CCBC 0000 5514          and.l     #255,D6
00001ED4  00FF      
00001ED6  2F06      5515          move.l    D6,-(A7)
00001ED8  CABC 0000 5516          and.l     #65535,D5
00001EDC  FFFF      
00001EDE  2F05      5517          move.l    D5,-(A7)
00001EE0  2F0B      5518          move.l    A3,-(A7)
00001EE2  2F03      5519          move.l    D3,-(A7)
00001EE4  4E95      5520          jsr       (A5)
00001EE6  DEFC 0014 5521          add.w     #20,A7
                    5522   ; OS_EXIT_CRITICAL();
00001EEA  46DF      5523          dc.w      18143
                    5524   ; }
                    5525   ; break;
00001EEC  6000 0060 5526          bra       OSFlagPend_11
                    5527   OSFlagPend_16:
                    5528   ; case OS_FLAG_WAIT_CLR_ANY:
                    5529   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
00001EF0  2043      5530          move.l    D3,A0
00001EF2  3028 0006 5531          move.w    6(A0),D0
00001EF6  4640      5532          not.w     D0
00001EF8  C045      5533          and.w     D5,D0
00001EFA  3400      5534          move.w    D0,D2
                    5535   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
00001EFC  4A42      5536          tst.w     D2
00001EFE  671E      5537          beq.s     OSFlagPend_30
                    5538   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001F00  0C07 0001 5539          cmp.b     #1,D7
00001F04  6606      5540          bne.s     OSFlagPend_32
                    5541   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
00001F06  2043      5542          move.l    D3,A0
00001F08  8568 0006 5543          or.w      D2,6(A0)
                    5544   OSFlagPend_32:
                    5545   ; }
                    5546   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
00001F0C  2052      5547          move.l    (A2),A0
00001F0E  3142 002C 5548          move.w    D2,44(A0)
                    5549   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
00001F12  46DF      5550          dc.w      18143
                    5551   ; *perr                   = OS_ERR_NONE;
00001F14  2044      5552          move.l    D4,A0
00001F16  4210      5553          clr.b     (A0)
                    5554   ; return (flags_rdy);
00001F18  3002      5555          move.w    D2,D0
00001F1A  6000 00F2 5556          bra       OSFlagPend_3
                    5557   OSFlagPend_30:
                    5558   ; } else {                                      /* Block task until events occur or timeout */
                    5559   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00001F1E  2F0C      5560          move.l    A4,-(A7)
00001F20  CCBC 0000 5561          and.l     #255,D6
00001F24  00FF      
00001F26  2F06      5562          move.l    D6,-(A7)
00001F28  CABC 0000 5563          and.l     #65535,D5
00001F2C  FFFF      
00001F2E  2F05      5564          move.l    D5,-(A7)
00001F30  2F0B      5565          move.l    A3,-(A7)
00001F32  2F03      5566          move.l    D3,-(A7)
00001F34  4E95      5567          jsr       (A5)
00001F36  DEFC 0014 5568          add.w     #20,A7
                    5569   ; OS_EXIT_CRITICAL();
00001F3A  46DF      5570          dc.w      18143
                    5571   ; }
                    5572   ; break;
00001F3C  6010      5573          bra.s     OSFlagPend_11
                    5574   OSFlagPend_10:
                    5575   ; #endif
                    5576   ; default:
                    5577   ; OS_EXIT_CRITICAL();
00001F3E  46DF      5578          dc.w      18143
                    5579   ; flags_rdy = (OS_FLAGS)0;
00001F40  4242      5580          clr.w     D2
                    5581   ; *perr      = OS_ERR_FLAG_WAIT_TYPE;
00001F42  2044      5582          move.l    D4,A0
00001F44  10BC 006F 5583          move.b    #111,(A0)
                    5584   ; return (flags_rdy);
00001F48  3002      5585          move.w    D2,D0
00001F4A  6000 00C2 5586          bra       OSFlagPend_3
                    5587   OSFlagPend_11:
                    5588   ; }
                    5589   ; /*$PAGE*/
                    5590   ; OS_Sched();                                            /* Find next HPT ready to run               */
00001F4E  4EB8 15DA 5591          jsr       _OS_Sched
                    5592   ; OS_ENTER_CRITICAL();
00001F52  40E7      5593          dc.w      16615
00001F54  007C      5594          dc.w      124
00001F56  0700      5595          dc.w      1792
                    5596   ; if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
00001F58  2052      5597          move.l    (A2),A0
00001F5A  1028 0033 5598          move.b    51(A0),D0
00001F5E  6700 0056 5599          beq       OSFlagPend_34
                    5600   ; pend_stat                = OSTCBCur->OSTCBStatPend;
00001F62  2052      5601          move.l    (A2),A0
00001F64  1D68 0033 5602          move.b    51(A0),-1(A6)
00001F68  FFFF      
                    5603   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00001F6A  2052      5604          move.l    (A2),A0
00001F6C  4228 0033 5605          clr.b     51(A0)
                    5606   ; OS_FlagUnlink(&node);
00001F70  2F0B      5607          move.l    A3,-(A7)
00001F72  4EB9 0000 5608          jsr       _OS_FlagUnlink
00001F76  240A      
00001F78  584F      5609          addq.w    #4,A7
                    5610   ; OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
00001F7A  2052      5611          move.l    (A2),A0
00001F7C  4228 0032 5612          clr.b     50(A0)
                    5613   ; OS_EXIT_CRITICAL();
00001F80  46DF      5614          dc.w      18143
                    5615   ; flags_rdy                = (OS_FLAGS)0;
00001F82  4242      5616          clr.w     D2
                    5617   ; switch (pend_stat) {
00001F84  102E FFFF 5618          move.b    -1(A6),D0
00001F88  C0BC 0000 5619          and.l     #255,D0
00001F8C  00FF      
00001F8E  0C80 0000 5620          cmp.l     #2,D0
00001F92  0002      
00001F94  670C      5621          beq.s     OSFlagPend_38
00001F96  6212      5622          bhi.s     OSFlagPend_39
00001F98  0C80 0000 5623          cmp.l     #1,D0
00001F9C  0001      
00001F9E  670A      5624          beq.s     OSFlagPend_39
00001FA0  6008      5625          bra.s     OSFlagPend_39
                    5626   OSFlagPend_38:
                    5627   ; case OS_STAT_PEND_ABORT:
                    5628   ; *perr = OS_ERR_PEND_ABORT;                /* Indicate that we aborted   waiting       */
00001FA2  2044      5629          move.l    D4,A0
00001FA4  10BC 000E 5630          move.b    #14,(A0)
                    5631   ; break;
00001FA8  6006      5632          bra.s     OSFlagPend_37
                    5633   OSFlagPend_39:
                    5634   ; case OS_STAT_PEND_TO:
                    5635   ; default:
                    5636   ; *perr = OS_ERR_TIMEOUT;                   /* Indicate that we timed-out waiting       */
00001FAA  2044      5637          move.l    D4,A0
00001FAC  10BC 000A 5638          move.b    #10,(A0)
                    5639   ; break;
                    5640   OSFlagPend_37:
                    5641   ; }
                    5642   ; return (flags_rdy);
00001FB0  3002      5643          move.w    D2,D0
00001FB2  6000 005A 5644          bra       OSFlagPend_3
                    5645   OSFlagPend_34:
                    5646   ; }
                    5647   ; flags_rdy = OSTCBCur->OSTCBFlagsRdy;
00001FB6  2052      5648          move.l    (A2),A0
00001FB8  3428 002C 5649          move.w    44(A0),D2
                    5650   ; if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
00001FBC  0C07 0001 5651          cmp.b     #1,D7
00001FC0  6600 0044 5652          bne       OSFlagPend_44
                    5653   ; switch (wait_type) {
00001FC4  CCBC 0000 5654          and.l     #255,D6
00001FC8  00FF      
00001FCA  2006      5655          move.l    D6,D0
00001FCC  0C80 0000 5656          cmp.l     #4,D0
00001FD0  0004      
00001FD2  6426      5657          bhs.s     OSFlagPend_43
00001FD4  E380      5658          asl.l     #1,D0
00001FD6  303B 0806 5659          move.w    OSFlagPend_45(PC,D0.L),D0
00001FDA  4EFB 0002 5660          jmp       OSFlagPend_45(PC,D0.W)
                    5661   OSFlagPend_45:
00001FDE  0014      5662          dc.w      OSFlagPend_48-OSFlagPend_45
00001FE0  0014      5663          dc.w      OSFlagPend_48-OSFlagPend_45
00001FE2  0008      5664          dc.w      OSFlagPend_46-OSFlagPend_45
00001FE4  0008      5665          dc.w      OSFlagPend_46-OSFlagPend_45
                    5666   OSFlagPend_46:
                    5667   ; case OS_FLAG_WAIT_SET_ALL:
                    5668   ; case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                    5669   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;
00001FE6  2043      5670          move.l    D3,A0
00001FE8  3002      5671          move.w    D2,D0
00001FEA  4640      5672          not.w     D0
00001FEC  C168 0006 5673          and.w     D0,6(A0)
                    5674   ; break;
00001FF0  6014      5675          bra.s     OSFlagPend_44
                    5676   OSFlagPend_48:
                    5677   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    5678   ; case OS_FLAG_WAIT_CLR_ALL:
                    5679   ; case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                    5680   ; pgrp->OSFlagFlags |=  flags_rdy;
00001FF2  2043      5681          move.l    D3,A0
00001FF4  8568 0006 5682          or.w      D2,6(A0)
                    5683   ; break;
00001FF8  600C      5684          bra.s     OSFlagPend_44
                    5685   OSFlagPend_43:
                    5686   ; #endif
                    5687   ; default:
                    5688   ; OS_EXIT_CRITICAL();
00001FFA  46DF      5689          dc.w      18143
                    5690   ; *perr = OS_ERR_FLAG_WAIT_TYPE;
00001FFC  2044      5691          move.l    D4,A0
00001FFE  10BC 006F 5692          move.b    #111,(A0)
                    5693   ; return ((OS_FLAGS)0);
00002002  4240      5694          clr.w     D0
00002004  6008      5695          bra.s     OSFlagPend_3
                    5696   OSFlagPend_44:
                    5697   ; }
                    5698   ; }
                    5699   ; OS_EXIT_CRITICAL();
00002006  46DF      5700          dc.w      18143
                    5701   ; *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
00002008  2044      5702          move.l    D4,A0
0000200A  4210      5703          clr.b     (A0)
                    5704   ; return (flags_rdy);
0000200C  3002      5705          move.w    D2,D0
                    5706   OSFlagPend_3:
0000200E  4CDF 3CFC 5707          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00002012  4E5E      5708          unlk      A6
00002014  4E75      5709          rts
                    5710   ; }
                    5711   ; /*$PAGE*/
                    5712   ; /*
                    5713   ; *********************************************************************************************************
                    5714   ; *                              GET FLAGS WHO CAUSED TASK TO BECOME READY
                    5715   ; *
                    5716   ; * Description: This function is called to obtain the flags that caused the task to become ready to run.
                    5717   ; *              In other words, this function allows you to tell "Who done it!".
                    5718   ; *
                    5719   ; * Arguments  : None
                    5720   ; *
                    5721   ; * Returns    : The flags that caused the task to be ready.
                    5722   ; *
                    5723   ; * Called from: Task ONLY
                    5724   ; *********************************************************************************************************
                    5725   ; */
                    5726   ; OS_FLAGS  OSFlagPendGetFlagsRdy (void)
                    5727   ; {
                    5728   _OSFlagPendGetFlagsRdy:
00002016  4E56 FFFC 5729          link      A6,#-4
                    5730   ; OS_FLAGS      flags;
                    5731   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    5732   ; OS_CPU_SR     cpu_sr = 0u;
                    5733   ; #endif
                    5734   ; OS_ENTER_CRITICAL();
0000201A  40E7      5735          dc.w      16615
0000201C  007C      5736          dc.w      124
0000201E  0700      5737          dc.w      1792
                    5738   ; flags = OSTCBCur->OSTCBFlagsRdy;
00002020  2079 0800 5739          move.l    _OSTCBCur.L,A0
00002024  0428      
00002026  3D68 002C 5740          move.w    44(A0),-2(A6)
0000202A  FFFE      
                    5741   ; OS_EXIT_CRITICAL();
0000202C  46DF      5742          dc.w      18143
                    5743   ; return (flags);
0000202E  302E FFFE 5744          move.w    -2(A6),D0
00002032  4E5E      5745          unlk      A6
00002034  4E75      5746          rts
                    5747   ; }
                    5748   ; /*$PAGE*/
                    5749   ; /*
                    5750   ; *********************************************************************************************************
                    5751   ; *                                       POST EVENT FLAG BIT(S)
                    5752   ; *
                    5753   ; * Description: This function is called to set or clear some bits in an event flag group.  The bits to
                    5754   ; *              set or clear are specified by a 'bit mask'.
                    5755   ; *
                    5756   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    5757   ; *
                    5758   ; *              flags         If 'opt' (see below) is OS_FLAG_SET, each bit that is set in 'flags' will
                    5759   ; *                            set the corresponding bit in the event flag group.  e.g. to set bits 0, 4
                    5760   ; *                            and 5 you would set 'flags' to:
                    5761   ; *
                    5762   ; *                                0x31     (note, bit 0 is least significant bit)
                    5763   ; *
                    5764   ; *                            If 'opt' (see below) is OS_FLAG_CLR, each bit that is set in 'flags' will
                    5765   ; *                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bits 0,
                    5766   ; *                            4 and 5 you would specify 'flags' as:
                    5767   ; *
                    5768   ; *                                0x31     (note, bit 0 is least significant bit)
                    5769   ; *
                    5770   ; *              opt           indicates whether the flags will be:
                    5771   ; *                                set     (OS_FLAG_SET) or
                    5772   ; *                                cleared (OS_FLAG_CLR)
                    5773   ; *
                    5774   ; *              perr          is a pointer to an error code and can be:
                    5775   ; *                            OS_ERR_NONE                The call was successfull
                    5776   ; *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
                    5777   ; *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
                    5778   ; *                            OS_ERR_FLAG_INVALID_OPT    You specified an invalid option
                    5779   ; *
                    5780   ; * Returns    : the new value of the event flags bits that are still set.
                    5781   ; *
                    5782   ; * Called From: Task or ISR
                    5783   ; *
                    5784   ; * WARNING(s) : 1) The execution time of this function depends on the number of tasks waiting on the event
                    5785   ; *                 flag group.
                    5786   ; *              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
                    5787   ; *                 the event flag group.
                    5788   ; *********************************************************************************************************
                    5789   ; */
                    5790   ; OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *pgrp,
                    5791   ; OS_FLAGS      flags,
                    5792   ; INT8U         opt,
                    5793   ; INT8U        *perr)
                    5794   ; {
                    5795   _OSFlagPost:
00002036  4E56 FFFC 5796          link      A6,#-4
0000203A  48E7 3F20 5797          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
0000203E  282E 0008 5798          move.l    8(A6),D4
00002042  45F9 0000 5799          lea       @ucos_ii_OS_FlagTaskRdy.L,A2
00002046  238E      
00002048  2E2E 0014 5800          move.l    20(A6),D7
                    5801   ; OS_FLAG_NODE *pnode;
                    5802   ; BOOLEAN       sched;
                    5803   ; OS_FLAGS      flags_cur;
                    5804   ; OS_FLAGS      flags_rdy;
                    5805   ; BOOLEAN       rdy;
                    5806   ; #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
                    5807   ; OS_CPU_SR     cpu_sr = 0u;
                    5808   ; #endif
                    5809   ; #ifdef OS_SAFETY_CRITICAL
                    5810   ; if (perr == (INT8U *)0) {
                    5811   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5812   ; return ((OS_FLAGS)0);
                    5813   ; }
                    5814   ; #endif
                    5815   ; #if OS_ARG_CHK_EN > 0u
                    5816   ; if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
                    5817   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5818   ; return ((OS_FLAGS)0);
                    5819   ; }
                    5820   ; #endif
                    5821   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
0000204C  2044      5822          move.l    D4,A0
0000204E  1010      5823          move.b    (A0),D0
00002050  0C00 0005 5824          cmp.b     #5,D0
00002054  670C      5825          beq.s     OSFlagPost_1
                    5826   ; *perr = OS_ERR_EVENT_TYPE;
00002056  2047      5827          move.l    D7,A0
00002058  10BC 0001 5828          move.b    #1,(A0)
                    5829   ; return ((OS_FLAGS)0);
0000205C  4240      5830          clr.w     D0
0000205E  6000 018C 5831          bra       OSFlagPost_3
                    5832   OSFlagPost_1:
                    5833   ; }
                    5834   ; /*$PAGE*/
                    5835   ; OS_ENTER_CRITICAL();
00002062  40E7      5836          dc.w      16615
00002064  007C      5837          dc.w      124
00002066  0700      5838          dc.w      1792
                    5839   ; switch (opt) {
00002068  102E 0013 5840          move.b    19(A6),D0
0000206C  C0BC 0000 5841          and.l     #255,D0
00002070  00FF      
00002072  0C80 0000 5842          cmp.l     #1,D0
00002076  0001      
00002078  6716      5843          beq.s     OSFlagPost_7
0000207A  6220      5844          bhi.s     OSFlagPost_4
0000207C  4A80      5845          tst.l     D0
0000207E  6702      5846          beq.s     OSFlagPost_6
00002080  601A      5847          bra.s     OSFlagPost_4
                    5848   OSFlagPost_6:
                    5849   ; case OS_FLAG_CLR:
                    5850   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags;  /* Clear the flags specified in the group         */
00002082  2044      5851          move.l    D4,A0
00002084  302E 000E 5852          move.w    14(A6),D0
00002088  4640      5853          not.w     D0
0000208A  C168 0006 5854          and.w     D0,6(A0)
                    5855   ; break;
0000208E  601A      5856          bra.s     OSFlagPost_5
                    5857   OSFlagPost_7:
                    5858   ; case OS_FLAG_SET:
                    5859   ; pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
00002090  2044      5860          move.l    D4,A0
00002092  302E 000E 5861          move.w    14(A6),D0
00002096  8168 0006 5862          or.w      D0,6(A0)
                    5863   ; break;
0000209A  600E      5864          bra.s     OSFlagPost_5
                    5865   OSFlagPost_4:
                    5866   ; default:
                    5867   ; OS_EXIT_CRITICAL();                     /* INVALID option                                 */
0000209C  46DF      5868          dc.w      18143
                    5869   ; *perr = OS_ERR_FLAG_INVALID_OPT;
0000209E  2047      5870          move.l    D7,A0
000020A0  10BC 0071 5871          move.b    #113,(A0)
                    5872   ; return ((OS_FLAGS)0);
000020A4  4240      5873          clr.w     D0
000020A6  6000 0144 5874          bra       OSFlagPost_3
                    5875   OSFlagPost_5:
                    5876   ; }
                    5877   ; sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
000020AA  4206      5878          clr.b     D6
                    5879   ; pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
000020AC  2044      5880          move.l    D4,A0
000020AE  2428 0002 5881          move.l    2(A0),D2
                    5882   ; while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
                    5883   OSFlagPost_9:
000020B2  4A82      5884          tst.l     D2
000020B4  6700 0112 5885          beq       OSFlagPost_11
                    5886   ; switch (pnode->OSFlagNodeWaitType) {
000020B8  2042      5887          move.l    D2,A0
000020BA  1028 0012 5888          move.b    18(A0),D0
000020BE  C0BC 0000 5889          and.l     #255,D0
000020C2  00FF      
000020C4  0C80 0000 5890          cmp.l     #4,D0
000020C8  0004      
000020CA  6400 00E6 5891          bhs       OSFlagPost_12
000020CE  E380      5892          asl.l     #1,D0
000020D0  303B 0806 5893          move.w    OSFlagPost_14(PC,D0.L),D0
000020D4  4EFB 0002 5894          jmp       OSFlagPost_14(PC,D0.W)
                    5895   OSFlagPost_14:
000020D8  0070      5896          dc.w      OSFlagPost_17-OSFlagPost_14
000020DA  00A8      5897          dc.w      OSFlagPost_18-OSFlagPost_14
000020DC  0008      5898          dc.w      OSFlagPost_15-OSFlagPost_14
000020DE  003E      5899          dc.w      OSFlagPost_16-OSFlagPost_14
                    5900   OSFlagPost_15:
                    5901   ; case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                    5902   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
000020E0  2044      5903          move.l    D4,A0
000020E2  3028 0006 5904          move.w    6(A0),D0
000020E6  2042      5905          move.l    D2,A0
000020E8  C068 0010 5906          and.w     16(A0),D0
000020EC  3600      5907          move.w    D0,D3
                    5908   ; if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
000020EE  2042      5909          move.l    D2,A0
000020F0  B668 0010 5910          cmp.w     16(A0),D3
000020F4  661C      5911          bne.s     OSFlagPost_22
                    5912   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
000020F6  42A7      5913          clr.l     -(A7)
000020F8  C6BC 0000 5914          and.l     #65535,D3
000020FC  FFFF      
000020FE  2F03      5915          move.l    D3,-(A7)
00002100  2F02      5916          move.l    D2,-(A7)
00002102  4E92      5917          jsr       (A2)
00002104  DEFC 000C 5918          add.w     #12,A7
00002108  1A00      5919          move.b    D0,D5
                    5920   ; if (rdy == OS_TRUE) {
0000210A  0C05 0001 5921          cmp.b     #1,D5
0000210E  6602      5922          bne.s     OSFlagPost_22
                    5923   ; sched = OS_TRUE;                     /* When done we will reschedule          */
00002110  7C01      5924          moveq     #1,D6
                    5925   OSFlagPost_22:
                    5926   ; }
                    5927   ; }
                    5928   ; break;
00002112  6000 00AC 5929          bra       OSFlagPost_13
                    5930   OSFlagPost_16:
                    5931   ; case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                    5932   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
00002116  2044      5933          move.l    D4,A0
00002118  3028 0006 5934          move.w    6(A0),D0
0000211C  2042      5935          move.l    D2,A0
0000211E  C068 0010 5936          and.w     16(A0),D0
00002122  3600      5937          move.w    D0,D3
                    5938   ; if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
00002124  4A43      5939          tst.w     D3
00002126  671C      5940          beq.s     OSFlagPost_26
                    5941   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
00002128  42A7      5942          clr.l     -(A7)
0000212A  C6BC 0000 5943          and.l     #65535,D3
0000212E  FFFF      
00002130  2F03      5944          move.l    D3,-(A7)
00002132  2F02      5945          move.l    D2,-(A7)
00002134  4E92      5946          jsr       (A2)
00002136  DEFC 000C 5947          add.w     #12,A7
0000213A  1A00      5948          move.b    D0,D5
                    5949   ; if (rdy == OS_TRUE) {
0000213C  0C05 0001 5950          cmp.b     #1,D5
00002140  6602      5951          bne.s     OSFlagPost_26
                    5952   ; sched = OS_TRUE;                     /* When done we will reschedule          */
00002142  7C01      5953          moveq     #1,D6
                    5954   OSFlagPost_26:
                    5955   ; }
                    5956   ; }
                    5957   ; break;
00002144  6000 007A 5958          bra       OSFlagPost_13
                    5959   OSFlagPost_17:
                    5960   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    5961   ; case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                    5962   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
00002148  2044      5963          move.l    D4,A0
0000214A  3028 0006 5964          move.w    6(A0),D0
0000214E  4640      5965          not.w     D0
00002150  2042      5966          move.l    D2,A0
00002152  C068 0010 5967          and.w     16(A0),D0
00002156  3600      5968          move.w    D0,D3
                    5969   ; if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
00002158  2042      5970          move.l    D2,A0
0000215A  B668 0010 5971          cmp.w     16(A0),D3
0000215E  661C      5972          bne.s     OSFlagPost_30
                    5973   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
00002160  42A7      5974          clr.l     -(A7)
00002162  C6BC 0000 5975          and.l     #65535,D3
00002166  FFFF      
00002168  2F03      5976          move.l    D3,-(A7)
0000216A  2F02      5977          move.l    D2,-(A7)
0000216C  4E92      5978          jsr       (A2)
0000216E  DEFC 000C 5979          add.w     #12,A7
00002172  1A00      5980          move.b    D0,D5
                    5981   ; if (rdy == OS_TRUE) {
00002174  0C05 0001 5982          cmp.b     #1,D5
00002178  6602      5983          bne.s     OSFlagPost_30
                    5984   ; sched = OS_TRUE;                     /* When done we will reschedule          */
0000217A  7C01      5985          moveq     #1,D6
                    5986   OSFlagPost_30:
                    5987   ; }
                    5988   ; }
                    5989   ; break;
0000217C  6000 0042 5990          bra       OSFlagPost_13
                    5991   OSFlagPost_18:
                    5992   ; case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                    5993   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
00002180  2044      5994          move.l    D4,A0
00002182  3028 0006 5995          move.w    6(A0),D0
00002186  4640      5996          not.w     D0
00002188  2042      5997          move.l    D2,A0
0000218A  C068 0010 5998          and.w     16(A0),D0
0000218E  3600      5999          move.w    D0,D3
                    6000   ; if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
00002190  4A43      6001          tst.w     D3
00002192  671C      6002          beq.s     OSFlagPost_34
                    6003   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
00002194  42A7      6004          clr.l     -(A7)
00002196  C6BC 0000 6005          and.l     #65535,D3
0000219A  FFFF      
0000219C  2F03      6006          move.l    D3,-(A7)
0000219E  2F02      6007          move.l    D2,-(A7)
000021A0  4E92      6008          jsr       (A2)
000021A2  DEFC 000C 6009          add.w     #12,A7
000021A6  1A00      6010          move.b    D0,D5
                    6011   ; if (rdy == OS_TRUE) {
000021A8  0C05 0001 6012          cmp.b     #1,D5
000021AC  6602      6013          bne.s     OSFlagPost_34
                    6014   ; sched = OS_TRUE;                     /* When done we will reschedule          */
000021AE  7C01      6015          moveq     #1,D6
                    6016   OSFlagPost_34:
                    6017   ; }
                    6018   ; }
                    6019   ; break;
000021B0  600E      6020          bra.s     OSFlagPost_13
                    6021   OSFlagPost_12:
                    6022   ; #endif
                    6023   ; default:
                    6024   ; OS_EXIT_CRITICAL();
000021B2  46DF      6025          dc.w      18143
                    6026   ; *perr = OS_ERR_FLAG_WAIT_TYPE;
000021B4  2047      6027          move.l    D7,A0
000021B6  10BC 006F 6028          move.b    #111,(A0)
                    6029   ; return ((OS_FLAGS)0);
000021BA  4240      6030          clr.w     D0
000021BC  6000 002E 6031          bra       OSFlagPost_3
                    6032   OSFlagPost_13:
                    6033   ; }
                    6034   ; pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
000021C0  2042      6035          move.l    D2,A0
000021C2  2410      6036          move.l    (A0),D2
000021C4  6000 FEEC 6037          bra       OSFlagPost_9
                    6038   OSFlagPost_11:
                    6039   ; }
                    6040   ; OS_EXIT_CRITICAL();
000021C8  46DF      6041          dc.w      18143
                    6042   ; if (sched == OS_TRUE) {
000021CA  0C06 0001 6043          cmp.b     #1,D6
000021CE  6604      6044          bne.s     OSFlagPost_36
                    6045   ; OS_Sched();
000021D0  4EB8 15DA 6046          jsr       _OS_Sched
                    6047   OSFlagPost_36:
                    6048   ; }
                    6049   ; OS_ENTER_CRITICAL();
000021D4  40E7      6050          dc.w      16615
000021D6  007C      6051          dc.w      124
000021D8  0700      6052          dc.w      1792
                    6053   ; flags_cur = pgrp->OSFlagFlags;
000021DA  2044      6054          move.l    D4,A0
000021DC  3D68 0006 6055          move.w    6(A0),-2(A6)
000021E0  FFFE      
                    6056   ; OS_EXIT_CRITICAL();
000021E2  46DF      6057          dc.w      18143
                    6058   ; *perr     = OS_ERR_NONE;
000021E4  2047      6059          move.l    D7,A0
000021E6  4210      6060          clr.b     (A0)
                    6061   ; return (flags_cur);
000021E8  302E FFFE 6062          move.w    -2(A6),D0
                    6063   OSFlagPost_3:
000021EC  4CDF 04FC 6064          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
000021F0  4E5E      6065          unlk      A6
000021F2  4E75      6066          rts
                    6067   ; }
                    6068   ; /*$PAGE*/
                    6069   ; /*
                    6070   ; *********************************************************************************************************
                    6071   ; *                                          QUERY EVENT FLAG
                    6072   ; *
                    6073   ; * Description: This function is used to check the value of the event flag group.
                    6074   ; *
                    6075   ; * Arguments  : pgrp         is a pointer to the desired event flag group.
                    6076   ; *
                    6077   ; *              perr          is a pointer to an error code returned to the called:
                    6078   ; *                            OS_ERR_NONE                The call was successfull
                    6079   ; *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
                    6080   ; *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
                    6081   ; *
                    6082   ; * Returns    : The current value of the event flag group.
                    6083   ; *
                    6084   ; * Called From: Task or ISR
                    6085   ; *********************************************************************************************************
                    6086   ; */
                    6087   ; #if OS_FLAG_QUERY_EN > 0u
                    6088   ; OS_FLAGS  OSFlagQuery (OS_FLAG_GRP  *pgrp,
                    6089   ; INT8U        *perr)
                    6090   ; {
                    6091   _OSFlagQuery:
000021F4  4E56 FFFC 6092          link      A6,#-4
                    6093   ; OS_FLAGS   flags;
                    6094   ; #if OS_CRITICAL_METHOD == 3u                      /* Allocate storage for CPU status register          */
                    6095   ; OS_CPU_SR  cpu_sr = 0u;
                    6096   ; #endif
                    6097   ; #ifdef OS_SAFETY_CRITICAL
                    6098   ; if (perr == (INT8U *)0) {
                    6099   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6100   ; return ((OS_FLAGS)0);
                    6101   ; }
                    6102   ; #endif
                    6103   ; #if OS_ARG_CHK_EN > 0u
                    6104   ; if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
                    6105   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    6106   ; return ((OS_FLAGS)0);
                    6107   ; }
                    6108   ; #endif
                    6109   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
000021F8  206E 0008 6110          move.l    8(A6),A0
000021FC  1010      6111          move.b    (A0),D0
000021FE  0C00 0005 6112          cmp.b     #5,D0
00002202  670C      6113          beq.s     OSFlagQuery_1
                    6114   ; *perr = OS_ERR_EVENT_TYPE;
00002204  206E 000C 6115          move.l    12(A6),A0
00002208  10BC 0001 6116          move.b    #1,(A0)
                    6117   ; return ((OS_FLAGS)0);
0000220C  4240      6118          clr.w     D0
0000220E  601C      6119          bra.s     OSFlagQuery_3
                    6120   OSFlagQuery_1:
                    6121   ; }
                    6122   ; OS_ENTER_CRITICAL();
00002210  40E7      6123          dc.w      16615
00002212  007C      6124          dc.w      124
00002214  0700      6125          dc.w      1792
                    6126   ; flags = pgrp->OSFlagFlags;
00002216  206E 0008 6127          move.l    8(A6),A0
0000221A  3D68 0006 6128          move.w    6(A0),-2(A6)
0000221E  FFFE      
                    6129   ; OS_EXIT_CRITICAL();
00002220  46DF      6130          dc.w      18143
                    6131   ; *perr = OS_ERR_NONE;
00002222  206E 000C 6132          move.l    12(A6),A0
00002226  4210      6133          clr.b     (A0)
                    6134   ; return (flags);                               /* Return the current value of the event flags       */
00002228  302E FFFE 6135          move.w    -2(A6),D0
                    6136   OSFlagQuery_3:
0000222C  4E5E      6137          unlk      A6
0000222E  4E75      6138          rts
                    6139   ; }
                    6140   ; #endif
                    6141   ; /*$PAGE*/
                    6142   ; /*
                    6143   ; *********************************************************************************************************
                    6144   ; *                     SUSPEND TASK UNTIL EVENT FLAG(s) RECEIVED OR TIMEOUT OCCURS
                    6145   ; *
                    6146   ; * Description: This function is internal to uC/OS-II and is used to put a task to sleep until the desired
                    6147   ; *              event flag bit(s) are set.
                    6148   ; *
                    6149   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    6150   ; *
                    6151   ; *              pnode         is a pointer to a structure which contains data about the task waiting for
                    6152   ; *                            event flag bit(s) to be set.
                    6153   ; *
                    6154   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
                    6155   ; *                            The bits you want are specified by setting the corresponding bits in
                    6156   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    6157   ; *                            'flags' would contain 0x03.
                    6158   ; *
                    6159   ; *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
                    6160   ; *                            to be set/cleared.
                    6161   ; *                            You can specify the following argument:
                    6162   ; *
                    6163   ; *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'mask' to be clear (0)
                    6164   ; *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'mask' to be clear (0)
                    6165   ; *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'mask' to be set   (1)
                    6166   ; *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'mask' to be set   (1)
                    6167   ; *
                    6168   ; *              timeout       is the desired amount of time that the task will wait for the event flag
                    6169   ; *                            bit(s) to be set.
                    6170   ; *
                    6171   ; * Returns    : none
                    6172   ; *
                    6173   ; * Called by  : OSFlagPend()  OS_FLAG.C
                    6174   ; *
                    6175   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    6176   ; *********************************************************************************************************
                    6177   ; */
                    6178   ; static  void  OS_FlagBlock (OS_FLAG_GRP  *pgrp,
                    6179   ; OS_FLAG_NODE *pnode,
                    6180   ; OS_FLAGS      flags,
                    6181   ; INT8U         wait_type,
                    6182   ; INT32U        timeout)
                    6183   ; {
                    6184   @ucos_ii_OS_FlagBlock:
00002230  4E56 0000 6185          link      A6,#0
00002234  48E7 3C20 6186          movem.l   D2/D3/D4/D5/A2,-(A7)
00002238  242E 000C 6187          move.l    12(A6),D2
0000223C  45F9 0800 6188          lea       _OSTCBCur.L,A2
00002240  0428      
00002242  262E 0008 6189          move.l    8(A6),D3
                    6190   ; OS_FLAG_NODE  *pnode_next;
                    6191   ; INT8U          y;
                    6192   ; OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
00002246  2052      6193          move.l    (A2),A0
00002248  0028 0020 6194          or.b      #32,50(A0)
0000224C  0032      
                    6195   ; OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
0000224E  2052      6196          move.l    (A2),A0
00002250  4228 0033 6197          clr.b     51(A0)
                    6198   ; OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
00002254  2052      6199          move.l    (A2),A0
00002256  216E 0018 6200          move.l    24(A6),46(A0)
0000225A  002E      
                    6201   ; #if OS_TASK_DEL_EN > 0u
                    6202   ; OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
0000225C  2052      6203          move.l    (A2),A0
0000225E  2142 0028 6204          move.l    D2,40(A0)
                    6205   ; #endif
                    6206   ; pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
00002262  2042      6207          move.l    D2,A0
00002264  316E 0012 6208          move.w    18(A6),16(A0)
00002268  0010      
                    6209   ; pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
0000226A  2042      6210          move.l    D2,A0
0000226C  116E 0017 6211          move.b    23(A6),18(A0)
00002270  0012      
                    6212   ; pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
00002272  2042      6213          move.l    D2,A0
00002274  2152 0008 6214          move.l    (A2),8(A0)
                    6215   ; pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
00002278  2043      6216          move.l    D3,A0
0000227A  2242      6217          move.l    D2,A1
0000227C  22A8 0002 6218          move.l    2(A0),(A1)
                    6219   ; pnode->OSFlagNodePrev     = (void *)0;
00002280  2042      6220          move.l    D2,A0
00002282  42A8 0004 6221          clr.l     4(A0)
                    6222   ; pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
00002286  2042      6223          move.l    D2,A0
00002288  2143 000C 6224          move.l    D3,12(A0)
                    6225   ; pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
0000228C  2043      6226          move.l    D3,A0
0000228E  2A28 0002 6227          move.l    2(A0),D5
                    6228   ; if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
00002292  4A85      6229          tst.l     D5
00002294  6706      6230          beq.s     @ucos_ii_OS_FlagBlock_1
                    6231   ; pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
00002296  2045      6232          move.l    D5,A0
00002298  2142 0004 6233          move.l    D2,4(A0)
                    6234   @ucos_ii_OS_FlagBlock_1:
                    6235   ; }
                    6236   ; pgrp->OSFlagWaitList = (void *)pnode;
0000229C  2043      6237          move.l    D3,A0
0000229E  2142 0002 6238          move.l    D2,2(A0)
                    6239   ; y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
000022A2  2052      6240          move.l    (A2),A0
000022A4  1828 0036 6241          move.b    54(A0),D4
                    6242   ; OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
000022A8  C8BC 0000 6243          and.l     #255,D4
000022AC  00FF      
000022AE  41F9 0800 6244          lea       _OSRdyTbl.L,A0
000022B2  0318      
000022B4  2252      6245          move.l    (A2),A1
000022B6  1029 0037 6246          move.b    55(A1),D0
000022BA  4600      6247          not.b     D0
000022BC  C130 4800 6248          and.b     D0,0(A0,D4.L)
                    6249   ; if (OSRdyTbl[y] == 0x00u) {
000022C0  C8BC 0000 6250          and.l     #255,D4
000022C4  00FF      
000022C6  41F9 0800 6251          lea       _OSRdyTbl.L,A0
000022CA  0318      
000022CC  1030 4800 6252          move.b    0(A0,D4.L),D0
000022D0  660E      6253          bne.s     @ucos_ii_OS_FlagBlock_3
                    6254   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
000022D2  2052      6255          move.l    (A2),A0
000022D4  1028 0038 6256          move.b    56(A0),D0
000022D8  4600      6257          not.b     D0
000022DA  C139 0800 6258          and.b     D0,_OSRdyGrp.L
000022DE  0316      
                    6259   @ucos_ii_OS_FlagBlock_3:
000022E0  4CDF 043C 6260          movem.l   (A7)+,D2/D3/D4/D5/A2
000022E4  4E5E      6261          unlk      A6
000022E6  4E75      6262          rts
                    6263   ; }
                    6264   ; }
                    6265   ; /*$PAGE*/
                    6266   ; /*
                    6267   ; *********************************************************************************************************
                    6268   ; *                                  INITIALIZE THE EVENT FLAG MODULE
                    6269   ; *
                    6270   ; * Description: This function is called by uC/OS-II to initialize the event flag module.  Your application
                    6271   ; *              MUST NOT call this function.  In other words, this function is internal to uC/OS-II.
                    6272   ; *
                    6273   ; * Arguments  : none
                    6274   ; *
                    6275   ; * Returns    : none
                    6276   ; *
                    6277   ; * WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
                    6278   ; *********************************************************************************************************
                    6279   ; */
                    6280   ; void  OS_FlagInit (void)
                    6281   ; {
                    6282   _OS_FlagInit:
000022E8  4E56 FFF8 6283          link      A6,#-8
000022EC  48E7 3020 6284          movem.l   D2/D3/A2,-(A7)
000022F0  45F9 0800 6285          lea       _OSFlagTbl.L,A2
000022F4  01C2      
                    6286   ; #if OS_MAX_FLAGS == 1u
                    6287   ; OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
                    6288   ; OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
                    6289   ; OSFlagFreeList->OSFlagWaitList = (void *)0;
                    6290   ; OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
                    6291   ; #if OS_FLAG_NAME_EN > 0u
                    6292   ; OSFlagFreeList->OSFlagName     = (INT8U *)"?";
                    6293   ; #endif
                    6294   ; #endif
                    6295   ; #if OS_MAX_FLAGS >= 2u
                    6296   ; INT16U        ix;
                    6297   ; INT16U        ix_next;
                    6298   ; OS_FLAG_GRP  *pgrp1;
                    6299   ; OS_FLAG_GRP  *pgrp2;
                    6300   ; OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
000022F6  4878 003C 6301          pea       60
000022FA  2F0A      6302          move.l    A2,-(A7)
000022FC  4EB8 158E 6303          jsr       _OS_MemClr
00002300  504F      6304          addq.w    #8,A7
                    6305   ; for (ix = 0u; ix < (OS_MAX_FLAGS - 1u); ix++) {                 /* Init. list of free EVENT FLAGS  */
00002302  4243      6306          clr.w     D3
                    6307   OS_FlagInit_1:
00002304  0C43 0004 6308          cmp.w     #4,D3
00002308  6400 004E 6309          bhs       OS_FlagInit_3
                    6310   ; ix_next = ix + 1u;
0000230C  3003      6311          move.w    D3,D0
0000230E  5240      6312          addq.w    #1,D0
00002310  3D40 FFFA 6313          move.w    D0,-6(A6)
                    6314   ; pgrp1 = &OSFlagTbl[ix];
00002314  200A      6315          move.l    A2,D0
00002316  C6BC 0000 6316          and.l     #65535,D3
0000231A  FFFF      
0000231C  2203      6317          move.l    D3,D1
0000231E  C3FC 000C 6318          muls      #12,D1
00002322  D081      6319          add.l     D1,D0
00002324  2400      6320          move.l    D0,D2
                    6321   ; pgrp2 = &OSFlagTbl[ix_next];
00002326  200A      6322          move.l    A2,D0
00002328  322E FFFA 6323          move.w    -6(A6),D1
0000232C  C2BC 0000 6324          and.l     #65535,D1
00002330  FFFF      
00002332  C3FC 000C 6325          muls      #12,D1
00002336  D081      6326          add.l     D1,D0
00002338  2D40 FFFC 6327          move.l    D0,-4(A6)
                    6328   ; pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
0000233C  2042      6329          move.l    D2,A0
0000233E  4210      6330          clr.b     (A0)
                    6331   ; pgrp1->OSFlagWaitList = (void *)pgrp2;
00002340  2042      6332          move.l    D2,A0
00002342  216E FFFC 6333          move.l    -4(A6),2(A0)
00002346  0002      
                    6334   ; #if OS_FLAG_NAME_EN > 0u
                    6335   ; pgrp1->OSFlagName     = (INT8U *)(void *)"?";               /* Unknown name                    */
00002348  41F9 0000 6336          lea       @ucos_ii_1.L,A0
0000234C  708C      
0000234E  2242      6337          move.l    D2,A1
00002350  2348 0008 6338          move.l    A0,8(A1)
00002354  5243      6339          addq.w    #1,D3
00002356  60AC      6340          bra       OS_FlagInit_1
                    6341   OS_FlagInit_3:
                    6342   ; #endif
                    6343   ; }
                    6344   ; pgrp1                 = &OSFlagTbl[ix];
00002358  200A      6345          move.l    A2,D0
0000235A  C6BC 0000 6346          and.l     #65535,D3
0000235E  FFFF      
00002360  2203      6347          move.l    D3,D1
00002362  C3FC 000C 6348          muls      #12,D1
00002366  D081      6349          add.l     D1,D0
00002368  2400      6350          move.l    D0,D2
                    6351   ; pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
0000236A  2042      6352          move.l    D2,A0
0000236C  4210      6353          clr.b     (A0)
                    6354   ; pgrp1->OSFlagWaitList = (void *)0;
0000236E  2042      6355          move.l    D2,A0
00002370  42A8 0002 6356          clr.l     2(A0)
                    6357   ; #if OS_FLAG_NAME_EN > 0u
                    6358   ; pgrp1->OSFlagName     = (INT8U *)(void *)"?";                   /* Unknown name                    */
00002374  41F9 0000 6359          lea       @ucos_ii_1.L,A0
00002378  708C      
0000237A  2242      6360          move.l    D2,A1
0000237C  2348 0008 6361          move.l    A0,8(A1)
                    6362   ; #endif
                    6363   ; OSFlagFreeList        = &OSFlagTbl[0];
00002380  23CA 0800 6364          move.l    A2,_OSFlagFreeList.L
00002384  01FE      
00002386  4CDF 040C 6365          movem.l   (A7)+,D2/D3/A2
0000238A  4E5E      6366          unlk      A6
0000238C  4E75      6367          rts
                    6368   ; #endif
                    6369   ; }
                    6370   ; /*$PAGE*/
                    6371   ; /*
                    6372   ; *********************************************************************************************************
                    6373   ; *                              MAKE TASK READY-TO-RUN, EVENT(s) OCCURRED
                    6374   ; *
                    6375   ; * Description: This function is internal to uC/OS-II and is used to make a task ready-to-run because the
                    6376   ; *              desired event flag bits have been set.
                    6377   ; *
                    6378   ; * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
                    6379   ; *                            event flag bit(s) to be set.
                    6380   ; *
                    6381   ; *              flags_rdy     contains the bit pattern of the event flags that cause the task to become
                    6382   ; *                            ready-to-run.
                    6383   ; *
                    6384   ; *              pend_stat   is used to indicate the readied task's pending status:
                    6385   ; *
                    6386   ; *
                    6387   ; * Returns    : OS_TRUE       If the task has been placed in the ready list and thus needs scheduling
                    6388   ; *              OS_FALSE      The task is still not ready to run and thus scheduling is not necessary
                    6389   ; *
                    6390   ; * Called by  : OSFlagsPost() OS_FLAG.C
                    6391   ; *
                    6392   ; * Note(s)    : 1) This function assumes that interrupts are disabled.
                    6393   ; *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
                    6394   ; *********************************************************************************************************
                    6395   ; */
                    6396   ; static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode,
                    6397   ; OS_FLAGS      flags_rdy,
                    6398   ; INT8U         pend_stat)
                    6399   ; {
                    6400   @ucos_ii_OS_FlagTaskRdy:
0000238E  4E56 0000 6401          link      A6,#0
00002392  48E7 3000 6402          movem.l   D2/D3,-(A7)
                    6403   ; OS_TCB   *ptcb;
                    6404   ; BOOLEAN   sched;
                    6405   ; ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
00002396  206E 0008 6406          move.l    8(A6),A0
0000239A  2428 0008 6407          move.l    8(A0),D2
                    6408   ; ptcb->OSTCBDly       = 0u;
0000239E  2042      6409          move.l    D2,A0
000023A0  42A8 002E 6410          clr.l     46(A0)
                    6411   ; ptcb->OSTCBFlagsRdy  = flags_rdy;
000023A4  2042      6412          move.l    D2,A0
000023A6  316E 000E 6413          move.w    14(A6),44(A0)
000023AA  002C      
                    6414   ; ptcb->OSTCBStat     &= (INT8U)~(INT8U)OS_STAT_FLAG;
000023AC  2042      6415          move.l    D2,A0
000023AE  7020      6416          moveq     #32,D0
000023B0  4600      6417          not.b     D0
000023B2  C128 0032 6418          and.b     D0,50(A0)
                    6419   ; ptcb->OSTCBStatPend  = pend_stat;
000023B6  2042      6420          move.l    D2,A0
000023B8  116E 0013 6421          move.b    19(A6),51(A0)
000023BC  0033      
                    6422   ; if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
000023BE  2042      6423          move.l    D2,A0
000023C0  1028 0032 6424          move.b    50(A0),D0
000023C4  662C      6425          bne.s     @ucos_ii_OS_FlagTaskRdy_1
                    6426   ; OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
000023C6  2042      6427          move.l    D2,A0
000023C8  1028 0038 6428          move.b    56(A0),D0
000023CC  8139 0800 6429          or.b      D0,_OSRdyGrp.L
000023D0  0316      
                    6430   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000023D2  2042      6431          move.l    D2,A0
000023D4  1028 0036 6432          move.b    54(A0),D0
000023D8  C0BC 0000 6433          and.l     #255,D0
000023DC  00FF      
000023DE  41F9 0800 6434          lea       _OSRdyTbl.L,A0
000023E2  0318      
000023E4  2242      6435          move.l    D2,A1
000023E6  1229 0037 6436          move.b    55(A1),D1
000023EA  8330 0800 6437          or.b      D1,0(A0,D0.L)
                    6438   ; sched                   = OS_TRUE;
000023EE  7601      6439          moveq     #1,D3
000023F0  6002      6440          bra.s     @ucos_ii_OS_FlagTaskRdy_2
                    6441   @ucos_ii_OS_FlagTaskRdy_1:
                    6442   ; } else {
                    6443   ; sched                   = OS_FALSE;
000023F2  4203      6444          clr.b     D3
                    6445   @ucos_ii_OS_FlagTaskRdy_2:
                    6446   ; }
                    6447   ; OS_FlagUnlink(pnode);
000023F4  2F2E 0008 6448          move.l    8(A6),-(A7)
000023F8  4EB9 0000 6449          jsr       _OS_FlagUnlink
000023FC  240A      
000023FE  584F      6450          addq.w    #4,A7
                    6451   ; return (sched);
00002400  1003      6452          move.b    D3,D0
00002402  4CDF 000C 6453          movem.l   (A7)+,D2/D3
00002406  4E5E      6454          unlk      A6
00002408  4E75      6455          rts
                    6456   ; }
                    6457   ; /*$PAGE*/
                    6458   ; /*
                    6459   ; *********************************************************************************************************
                    6460   ; *                              UNLINK EVENT FLAG NODE FROM WAITING LIST
                    6461   ; *
                    6462   ; * Description: This function is internal to uC/OS-II and is used to unlink an event flag node from a
                    6463   ; *              list of tasks waiting for the event flag.
                    6464   ; *
                    6465   ; * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
                    6466   ; *                            event flag bit(s) to be set.
                    6467   ; *
                    6468   ; * Returns    : none
                    6469   ; *
                    6470   ; * Called by  : OS_FlagTaskRdy() OS_FLAG.C
                    6471   ; *              OSFlagPend()     OS_FLAG.C
                    6472   ; *              OSTaskDel()      OS_TASK.C
                    6473   ; *
                    6474   ; * Note(s)    : 1) This function assumes that interrupts are disabled.
                    6475   ; *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
                    6476   ; *********************************************************************************************************
                    6477   ; */
                    6478   ; void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
                    6479   ; {
                    6480   _OS_FlagUnlink:
0000240A  4E56 FFF8 6481          link      A6,#-8
0000240E  48E7 3800 6482          movem.l   D2/D3/D4,-(A7)
00002412  262E 0008 6483          move.l    8(A6),D3
                    6484   ; #if OS_TASK_DEL_EN > 0u
                    6485   ; OS_TCB       *ptcb;
                    6486   ; #endif
                    6487   ; OS_FLAG_GRP  *pgrp;
                    6488   ; OS_FLAG_NODE *pnode_prev;
                    6489   ; OS_FLAG_NODE *pnode_next;
                    6490   ; pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
00002416  2043      6491          move.l    D3,A0
00002418  2828 0004 6492          move.l    4(A0),D4
                    6493   ; pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
0000241C  2043      6494          move.l    D3,A0
0000241E  2410      6495          move.l    (A0),D2
                    6496   ; if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
00002420  4A84      6497          tst.l     D4
00002422  661C      6498          bne.s     OS_FlagUnlink_1
                    6499   ; pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
00002424  2043      6500          move.l    D3,A0
00002426  2D68 000C 6501          move.l    12(A0),-4(A6)
0000242A  FFFC      
                    6502   ; pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
0000242C  206E FFFC 6503          move.l    -4(A6),A0
00002430  2142 0002 6504          move.l    D2,2(A0)
                    6505   ; if (pnode_next != (OS_FLAG_NODE *)0) {
00002434  4A82      6506          tst.l     D2
00002436  6706      6507          beq.s     OS_FlagUnlink_3
                    6508   ; pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
00002438  2042      6509          move.l    D2,A0
0000243A  42A8 0004 6510          clr.l     4(A0)
                    6511   OS_FlagUnlink_3:
0000243E  600E      6512          bra.s     OS_FlagUnlink_5
                    6513   OS_FlagUnlink_1:
                    6514   ; }
                    6515   ; } else {                                                    /* No,  A node somewhere in the list   */
                    6516   ; pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
00002440  2044      6517          move.l    D4,A0
00002442  2082      6518          move.l    D2,(A0)
                    6519   ; if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
00002444  4A82      6520          tst.l     D2
00002446  6706      6521          beq.s     OS_FlagUnlink_5
                    6522   ; pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
00002448  2042      6523          move.l    D2,A0
0000244A  2144 0004 6524          move.l    D4,4(A0)
                    6525   OS_FlagUnlink_5:
                    6526   ; }
                    6527   ; }
                    6528   ; #if OS_TASK_DEL_EN > 0u
                    6529   ; ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
0000244E  2043      6530          move.l    D3,A0
00002450  2D68 0008 6531          move.l    8(A0),-8(A6)
00002454  FFF8      
                    6532   ; ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
00002456  206E FFF8 6533          move.l    -8(A6),A0
0000245A  42A8 0028 6534          clr.l     40(A0)
0000245E  4CDF 001C 6535          movem.l   (A7)+,D2/D3/D4
00002462  4E5E      6536          unlk      A6
00002464  4E75      6537          rts
                    6538   ; /*
                    6539   ; *********************************************************************************************************
                    6540   ; *                                                uC/OS-II
                    6541   ; *                                          The Real-Time Kernel
                    6542   ; *                                       MESSAGE MAILBOX MANAGEMENT
                    6543   ; *
                    6544   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    6545   ; *                                           All Rights Reserved
                    6546   ; *
                    6547   ; * File    : OS_MBOX.C
                    6548   ; * By      : Jean J. Labrosse
                    6549   ; * Version : V2.92.07
                    6550   ; *
                    6551   ; * LICENSING TERMS:
                    6552   ; * ---------------
                    6553   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    6554   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    6555   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    6556   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    6557   ; * licensing fee.
                    6558   ; *********************************************************************************************************
                    6559   ; */
                    6560   ; #define  MICRIUM_SOURCE
                    6561   ; #ifndef  OS_MASTER_FILE
                    6562   ; #include <ucos_ii.h>
                    6563   ; #endif
                    6564   ; #if OS_MBOX_EN > 0u
                    6565   ; /*
                    6566   ; *********************************************************************************************************
                    6567   ; *                                        ACCEPT MESSAGE FROM MAILBOX
                    6568   ; *
                    6569   ; * Description: This function checks the mailbox to see if a message is available.  Unlike OSMboxPend(),
                    6570   ; *              OSMboxAccept() does not suspend the calling task if a message is not available.
                    6571   ; *
                    6572   ; * Arguments  : pevent        is a pointer to the event control block
                    6573   ; *
                    6574   ; * Returns    : != (void *)0  is the message in the mailbox if one is available.  The mailbox is cleared
                    6575   ; *                            so the next time OSMboxAccept() is called, the mailbox will be empty.
                    6576   ; *              == (void *)0  if the mailbox is empty or,
                    6577   ; *                            if 'pevent' is a NULL pointer or,
                    6578   ; *                            if you didn't pass the proper event pointer.
                    6579   ; *********************************************************************************************************
                    6580   ; */
                    6581   ; #if OS_MBOX_ACCEPT_EN > 0u
                    6582   ; void  *OSMboxAccept (OS_EVENT *pevent)
                    6583   ; {
                    6584   _OSMboxAccept:
00002466  4E56 FFFC 6585          link      A6,#-4
0000246A  2F02      6586          move.l    D2,-(A7)
0000246C  242E 0008 6587          move.l    8(A6),D2
                    6588   ; void      *pmsg;
                    6589   ; #if OS_CRITICAL_METHOD == 3u                              /* Allocate storage for CPU status register  */
                    6590   ; OS_CPU_SR  cpu_sr = 0u;
                    6591   ; #endif
                    6592   ; #if OS_ARG_CHK_EN > 0u
                    6593   ; if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
                    6594   ; return ((void *)0);
                    6595   ; }
                    6596   ; #endif
                    6597   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
00002470  2042      6598          move.l    D2,A0
00002472  1010      6599          move.b    (A0),D0
00002474  0C00 0001 6600          cmp.b     #1,D0
00002478  6704      6601          beq.s     OSMboxAccept_1
                    6602   ; return ((void *)0);
0000247A  4280      6603          clr.l     D0
0000247C  601A      6604          bra.s     OSMboxAccept_3
                    6605   OSMboxAccept_1:
                    6606   ; }
                    6607   ; OS_ENTER_CRITICAL();
0000247E  40E7      6608          dc.w      16615
00002480  007C      6609          dc.w      124
00002482  0700      6610          dc.w      1792
                    6611   ; pmsg               = pevent->OSEventPtr;
00002484  2042      6612          move.l    D2,A0
00002486  2D68 0002 6613          move.l    2(A0),-4(A6)
0000248A  FFFC      
                    6614   ; pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
0000248C  2042      6615          move.l    D2,A0
0000248E  42A8 0002 6616          clr.l     2(A0)
                    6617   ; OS_EXIT_CRITICAL();
00002492  46DF      6618          dc.w      18143
                    6619   ; return (pmsg);                                        /* Return the message received (or NULL)     */
00002494  202E FFFC 6620          move.l    -4(A6),D0
                    6621   OSMboxAccept_3:
00002498  241F      6622          move.l    (A7)+,D2
0000249A  4E5E      6623          unlk      A6
0000249C  4E75      6624          rts
                    6625   ; }
                    6626   ; #endif
                    6627   ; /*$PAGE*/
                    6628   ; /*
                    6629   ; *********************************************************************************************************
                    6630   ; *                                          CREATE A MESSAGE MAILBOX
                    6631   ; *
                    6632   ; * Description: This function creates a message mailbox if free event control blocks are available.
                    6633   ; *
                    6634   ; * Arguments  : pmsg          is a pointer to a message that you wish to deposit in the mailbox.  If
                    6635   ; *                            you set this value to the NULL pointer (i.e. (void *)0) then the mailbox
                    6636   ; *                            will be considered empty.
                    6637   ; *
                    6638   ; * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    6639   ; *                                created mailbox
                    6640   ; *              == (OS_EVENT *)0  if no event control blocks were available
                    6641   ; *********************************************************************************************************
                    6642   ; */
                    6643   ; OS_EVENT  *OSMboxCreate (void *pmsg)
                    6644   ; {
                    6645   _OSMboxCreate:
0000249E  4E56 0000 6646          link      A6,#0
000024A2  48E7 2020 6647          movem.l   D2/A2,-(A7)
000024A6  45F9 0800 6648          lea       _OSEventFreeList.L,A2
000024AA  00E2      
                    6649   ; OS_EVENT  *pevent;
                    6650   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    6651   ; OS_CPU_SR  cpu_sr = 0u;
                    6652   ; #endif
                    6653   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    6654   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    6655   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6656   ; return ((OS_EVENT *)0);
                    6657   ; }
                    6658   ; #endif
                    6659   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
000024AC  1039 0800 6660          move.b    _OSIntNesting.L,D0
000024B0  030E      
000024B2  0C00 0000 6661          cmp.b     #0,D0
000024B6  6306      6662          bls.s     OSMboxCreate_1
                    6663   ; return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
000024B8  4280      6664          clr.l     D0
000024BA  6000 0044 6665          bra       OSMboxCreate_3
                    6666   OSMboxCreate_1:
                    6667   ; }
                    6668   ; OS_ENTER_CRITICAL();
000024BE  40E7      6669          dc.w      16615
000024C0  007C      6670          dc.w      124
000024C2  0700      6671          dc.w      1792
                    6672   ; pevent = OSEventFreeList;                    /* Get next free event control block                  */
000024C4  2412      6673          move.l    (A2),D2
                    6674   ; if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
000024C6  2012      6675          move.l    (A2),D0
000024C8  6706      6676          beq.s     OSMboxCreate_4
                    6677   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
000024CA  2052      6678          move.l    (A2),A0
000024CC  24A8 0002 6679          move.l    2(A0),(A2)
                    6680   OSMboxCreate_4:
                    6681   ; }
                    6682   ; OS_EXIT_CRITICAL();
000024D0  46DF      6683          dc.w      18143
                    6684   ; if (pevent != (OS_EVENT *)0) {
000024D2  4A82      6685          tst.l     D2
000024D4  6728      6686          beq.s     OSMboxCreate_6
                    6687   ; pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
000024D6  2042      6688          move.l    D2,A0
000024D8  10BC 0001 6689          move.b    #1,(A0)
                    6690   ; pevent->OSEventCnt     = 0u;
000024DC  2042      6691          move.l    D2,A0
000024DE  4268 0006 6692          clr.w     6(A0)
                    6693   ; pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
000024E2  2042      6694          move.l    D2,A0
000024E4  216E 0008 6695          move.l    8(A6),2(A0)
000024E8  0002      
                    6696   ; #if OS_EVENT_NAME_EN > 0u
                    6697   ; pevent->OSEventName    = (INT8U *)(void *)"?";
000024EA  41F9 0000 6698          lea       @ucos_ii_1.L,A0
000024EE  708C      
000024F0  2242      6699          move.l    D2,A1
000024F2  2348 0012 6700          move.l    A0,18(A1)
                    6701   ; #endif
                    6702   ; OS_EventWaitListInit(pevent);
000024F6  2F02      6703          move.l    D2,-(A7)
000024F8  4EB8 12C2 6704          jsr       _OS_EventWaitListInit
000024FC  584F      6705          addq.w    #4,A7
                    6706   OSMboxCreate_6:
                    6707   ; }
                    6708   ; return (pevent);                             /* Return pointer to event control block              */
000024FE  2002      6709          move.l    D2,D0
                    6710   OSMboxCreate_3:
00002500  4CDF 0404 6711          movem.l   (A7)+,D2/A2
00002504  4E5E      6712          unlk      A6
00002506  4E75      6713          rts
                    6714   ; }
                    6715   ; /*$PAGE*/
                    6716   ; /*
                    6717   ; *********************************************************************************************************
                    6718   ; *                                           DELETE A MAIBOX
                    6719   ; *
                    6720   ; * Description: This function deletes a mailbox and readies all tasks pending on the mailbox.
                    6721   ; *
                    6722   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    6723   ; *                            mailbox.
                    6724   ; *
                    6725   ; *              opt           determines delete options as follows:
                    6726   ; *                            opt == OS_DEL_NO_PEND   Delete the mailbox ONLY if no task pending
                    6727   ; *                            opt == OS_DEL_ALWAYS    Deletes the mailbox even if tasks are waiting.
                    6728   ; *                                                    In this case, all the tasks pending will be readied.
                    6729   ; *
                    6730   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    6731   ; *                            OS_ERR_NONE             The call was successful and the mailbox was deleted
                    6732   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the mailbox from an ISR
                    6733   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    6734   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mailbox
                    6735   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mailbox
                    6736   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    6737   ; *
                    6738   ; * Returns    : pevent        upon error
                    6739   ; *              (OS_EVENT *)0 if the mailbox was successfully deleted.
                    6740   ; *
                    6741   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    6742   ; *                 the mailbox MUST check the return code of OSMboxPend().
                    6743   ; *              2) OSMboxAccept() callers will not know that the intended mailbox has been deleted!
                    6744   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    6745   ; *                 time is directly proportional to the number of tasks waiting on the mailbox.
                    6746   ; *              4) Because ALL tasks pending on the mailbox will be readied, you MUST be careful in
                    6747   ; *                 applications where the mailbox is used for mutual exclusion because the resource(s)
                    6748   ; *                 will no longer be guarded by the mailbox.
                    6749   ; *              5) All tasks that were waiting for the mailbox will be readied and returned an 
                    6750   ; *                 OS_ERR_PEND_ABORT if OSMboxDel() was called with OS_DEL_ALWAYS
                    6751   ; *********************************************************************************************************
                    6752   ; */
                    6753   ; #if OS_MBOX_DEL_EN > 0u
                    6754   ; OS_EVENT  *OSMboxDel (OS_EVENT  *pevent,
                    6755   ; INT8U      opt,
                    6756   ; INT8U     *perr)
                    6757   ; {
                    6758   _OSMboxDel:
00002508  4E56 0000 6759          link      A6,#0
0000250C  48E7 3C20 6760          movem.l   D2/D3/D4/D5/A2,-(A7)
00002510  242E 0008 6761          move.l    8(A6),D2
00002514  262E 0010 6762          move.l    16(A6),D3
00002518  45F9 0800 6763          lea       _OSEventFreeList.L,A2
0000251C  00E2      
                    6764   ; BOOLEAN    tasks_waiting;
                    6765   ; OS_EVENT  *pevent_return;
                    6766   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    6767   ; OS_CPU_SR  cpu_sr = 0u;
                    6768   ; #endif
                    6769   ; #ifdef OS_SAFETY_CRITICAL
                    6770   ; if (perr == (INT8U *)0) {
                    6771   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6772   ; return ((OS_EVENT *)0);
                    6773   ; }
                    6774   ; #endif
                    6775   ; #if OS_ARG_CHK_EN > 0u
                    6776   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    6777   ; *perr = OS_ERR_PEVENT_NULL;
                    6778   ; return (pevent);
                    6779   ; }
                    6780   ; #endif
                    6781   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
0000251E  2042      6782          move.l    D2,A0
00002520  1010      6783          move.b    (A0),D0
00002522  0C00 0001 6784          cmp.b     #1,D0
00002526  670C      6785          beq.s     OSMboxDel_1
                    6786   ; *perr = OS_ERR_EVENT_TYPE;
00002528  2043      6787          move.l    D3,A0
0000252A  10BC 0001 6788          move.b    #1,(A0)
                    6789   ; return (pevent);
0000252E  2002      6790          move.l    D2,D0
00002530  6000 00EA 6791          bra       OSMboxDel_3
                    6792   OSMboxDel_1:
                    6793   ; }
                    6794   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00002534  1039 0800 6795          move.b    _OSIntNesting.L,D0
00002538  030E      
0000253A  0C00 0000 6796          cmp.b     #0,D0
0000253E  630C      6797          bls.s     OSMboxDel_4
                    6798   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
00002540  2043      6799          move.l    D3,A0
00002542  10BC 000F 6800          move.b    #15,(A0)
                    6801   ; return (pevent);
00002546  2002      6802          move.l    D2,D0
00002548  6000 00D2 6803          bra       OSMboxDel_3
                    6804   OSMboxDel_4:
                    6805   ; }
                    6806   ; OS_ENTER_CRITICAL();
0000254C  40E7      6807          dc.w      16615
0000254E  007C      6808          dc.w      124
00002550  0700      6809          dc.w      1792
                    6810   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mailbox      */
00002552  2042      6811          move.l    D2,A0
00002554  1028 0008 6812          move.b    8(A0),D0
00002558  6704      6813          beq.s     OSMboxDel_6
                    6814   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
0000255A  7A01      6815          moveq     #1,D5
0000255C  6002      6816          bra.s     OSMboxDel_7
                    6817   OSMboxDel_6:
                    6818   ; } else {
                    6819   ; tasks_waiting = OS_FALSE;                          /* No                                       */
0000255E  4205      6820          clr.b     D5
                    6821   OSMboxDel_7:
                    6822   ; }
                    6823   ; switch (opt) {
00002560  102E 000F 6824          move.b    15(A6),D0
00002564  C0BC 0000 6825          and.l     #255,D0
00002568  00FF      
0000256A  0C80 0000 6826          cmp.l     #1,D0
0000256E  0001      
00002570  6700 0048 6827          beq       OSMboxDel_11
00002574  6200 009A 6828          bhi       OSMboxDel_8
00002578  4A80      6829          tst.l     D0
0000257A  6704      6830          beq.s     OSMboxDel_10
0000257C  6000 0092 6831          bra       OSMboxDel_8
                    6832   OSMboxDel_10:
                    6833   ; case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
                    6834   ; if (tasks_waiting == OS_FALSE) {
00002580  4A05      6835          tst.b     D5
00002582  6628      6836          bne.s     OSMboxDel_13
                    6837   ; #if OS_EVENT_NAME_EN > 0u
                    6838   ; pevent->OSEventName = (INT8U *)(void *)"?";
00002584  41F9 0000 6839          lea       @ucos_ii_1.L,A0
00002588  708C      
0000258A  2242      6840          move.l    D2,A1
0000258C  2348 0012 6841          move.l    A0,18(A1)
                    6842   ; #endif
                    6843   ; pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
00002590  2042      6844          move.l    D2,A0
00002592  4210      6845          clr.b     (A0)
                    6846   ; pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
00002594  2042      6847          move.l    D2,A0
00002596  2152 0002 6848          move.l    (A2),2(A0)
                    6849   ; pevent->OSEventCnt  = 0u;
0000259A  2042      6850          move.l    D2,A0
0000259C  4268 0006 6851          clr.w     6(A0)
                    6852   ; OSEventFreeList     = pevent;             /* Get next free event control block        */
000025A0  2482      6853          move.l    D2,(A2)
                    6854   ; OS_EXIT_CRITICAL();
000025A2  46DF      6855          dc.w      18143
                    6856   ; *perr               = OS_ERR_NONE;
000025A4  2043      6857          move.l    D3,A0
000025A6  4210      6858          clr.b     (A0)
                    6859   ; pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
000025A8  4284      6860          clr.l     D4
000025AA  600A      6861          bra.s     OSMboxDel_14
                    6862   OSMboxDel_13:
                    6863   ; } else {
                    6864   ; OS_EXIT_CRITICAL();
000025AC  46DF      6865          dc.w      18143
                    6866   ; *perr               = OS_ERR_TASK_WAITING;
000025AE  2043      6867          move.l    D3,A0
000025B0  10BC 0049 6868          move.b    #73,(A0)
                    6869   ; pevent_return       = pevent;
000025B4  2802      6870          move.l    D2,D4
                    6871   OSMboxDel_14:
                    6872   ; }
                    6873   ; break;
000025B6  6000 0062 6874          bra       OSMboxDel_9
                    6875   OSMboxDel_11:
                    6876   ; case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
                    6877   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mailbox      */
                    6878   OSMboxDel_15:
000025BA  2042      6879          move.l    D2,A0
000025BC  1028 0008 6880          move.b    8(A0),D0
000025C0  671C      6881          beq.s     OSMboxDel_17
                    6882   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
000025C2  4878 0002 6883          pea       2
000025C6  4878 0002 6884          pea       2
000025CA  42A7      6885          clr.l     -(A7)
000025CC  2F02      6886          move.l    D2,-(A7)
000025CE  4EB8 0FFA 6887          jsr       _OS_EventTaskRdy
000025D2  DEFC 0010 6888          add.w     #16,A7
000025D6  C0BC 0000 6889          and.l     #255,D0
000025DA  00FF      
000025DC  60DC      6890          bra       OSMboxDel_15
                    6891   OSMboxDel_17:
                    6892   ; }
                    6893   ; #if OS_EVENT_NAME_EN > 0u
                    6894   ; pevent->OSEventName    = (INT8U *)(void *)"?";
000025DE  41F9 0000 6895          lea       @ucos_ii_1.L,A0
000025E2  708C      
000025E4  2242      6896          move.l    D2,A1
000025E6  2348 0012 6897          move.l    A0,18(A1)
                    6898   ; #endif
                    6899   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
000025EA  2042      6900          move.l    D2,A0
000025EC  4210      6901          clr.b     (A0)
                    6902   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
000025EE  2042      6903          move.l    D2,A0
000025F0  2152 0002 6904          move.l    (A2),2(A0)
                    6905   ; pevent->OSEventCnt     = 0u;
000025F4  2042      6906          move.l    D2,A0
000025F6  4268 0006 6907          clr.w     6(A0)
                    6908   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
000025FA  2482      6909          move.l    D2,(A2)
                    6910   ; OS_EXIT_CRITICAL();
000025FC  46DF      6911          dc.w      18143
                    6912   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
000025FE  0C05 0001 6913          cmp.b     #1,D5
00002602  6604      6914          bne.s     OSMboxDel_18
                    6915   ; OS_Sched();                               /* Find highest priority task ready to run  */
00002604  4EB8 15DA 6916          jsr       _OS_Sched
                    6917   OSMboxDel_18:
                    6918   ; }
                    6919   ; *perr         = OS_ERR_NONE;
00002608  2043      6920          move.l    D3,A0
0000260A  4210      6921          clr.b     (A0)
                    6922   ; pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
0000260C  4284      6923          clr.l     D4
                    6924   ; break;
0000260E  600A      6925          bra.s     OSMboxDel_9
                    6926   OSMboxDel_8:
                    6927   ; default:
                    6928   ; OS_EXIT_CRITICAL();
00002610  46DF      6929          dc.w      18143
                    6930   ; *perr         = OS_ERR_INVALID_OPT;
00002612  2043      6931          move.l    D3,A0
00002614  10BC 0007 6932          move.b    #7,(A0)
                    6933   ; pevent_return = pevent;
00002618  2802      6934          move.l    D2,D4
                    6935   ; break;
                    6936   OSMboxDel_9:
                    6937   ; }
                    6938   ; return (pevent_return);
0000261A  2004      6939          move.l    D4,D0
                    6940   OSMboxDel_3:
0000261C  4CDF 043C 6941          movem.l   (A7)+,D2/D3/D4/D5/A2
00002620  4E5E      6942          unlk      A6
00002622  4E75      6943          rts
                    6944   ; }
                    6945   ; #endif
                    6946   ; /*$PAGE*/
                    6947   ; /*
                    6948   ; *********************************************************************************************************
                    6949   ; *                                    PEND ON MAILBOX FOR A MESSAGE
                    6950   ; *
                    6951   ; * Description: This function waits for a message to be sent to a mailbox
                    6952   ; *
                    6953   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    6954   ; *
                    6955   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    6956   ; *                            wait for a message to arrive at the mailbox up to the amount of time
                    6957   ; *                            specified by this argument.  If you specify 0, however, your task will wait
                    6958   ; *                            forever at the specified mailbox or, until a message arrives.
                    6959   ; *
                    6960   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    6961   ; *                            messages are:
                    6962   ; *
                    6963   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    6964   ; *                                                message.
                    6965   ; *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
                    6966   ; *                            OS_ERR_PEND_ABORT   The wait on the mailbox was aborted.
                    6967   ; *                            OS_ERR_EVENT_TYPE   Invalid event type
                    6968   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    6969   ; *                                                would lead to a suspension.
                    6970   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    6971   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
                    6972   ; *
                    6973   ; * Returns    : != (void *)0  is a pointer to the message received
                    6974   ; *              == (void *)0  if no message was received or,
                    6975   ; *                            if 'pevent' is a NULL pointer or,
                    6976   ; *                            if you didn't pass the proper pointer to the event control block.
                    6977   ; *********************************************************************************************************
                    6978   ; */
                    6979   ; /*$PAGE*/
                    6980   ; void  *OSMboxPend (OS_EVENT  *pevent,
                    6981   ; INT32U     timeout,
                    6982   ; INT8U     *perr)
                    6983   ; {
                    6984   _OSMboxPend:
00002624  4E56 0000 6985          link      A6,#0
00002628  48E7 3820 6986          movem.l   D2/D3/D4/A2,-(A7)
0000262C  45F9 0800 6987          lea       _OSTCBCur.L,A2
00002630  0428      
00002632  262E 0010 6988          move.l    16(A6),D3
00002636  282E 0008 6989          move.l    8(A6),D4
                    6990   ; void      *pmsg;
                    6991   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    6992   ; OS_CPU_SR  cpu_sr = 0u;
                    6993   ; #endif
                    6994   ; #ifdef OS_SAFETY_CRITICAL
                    6995   ; if (perr == (INT8U *)0) {
                    6996   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6997   ; return ((void *)0);
                    6998   ; }
                    6999   ; #endif
                    7000   ; #if OS_ARG_CHK_EN > 0u
                    7001   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    7002   ; *perr = OS_ERR_PEVENT_NULL;
                    7003   ; return ((void *)0);
                    7004   ; }
                    7005   ; #endif
                    7006   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
0000263A  2044      7007          move.l    D4,A0
0000263C  1010      7008          move.b    (A0),D0
0000263E  0C00 0001 7009          cmp.b     #1,D0
00002642  670C      7010          beq.s     OSMboxPend_1
                    7011   ; *perr = OS_ERR_EVENT_TYPE;
00002644  2043      7012          move.l    D3,A0
00002646  10BC 0001 7013          move.b    #1,(A0)
                    7014   ; return ((void *)0);
0000264A  4280      7015          clr.l     D0
0000264C  6000 00F0 7016          bra       OSMboxPend_3
                    7017   OSMboxPend_1:
                    7018   ; }
                    7019   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
00002650  1039 0800 7020          move.b    _OSIntNesting.L,D0
00002654  030E      
00002656  0C00 0000 7021          cmp.b     #0,D0
0000265A  630C      7022          bls.s     OSMboxPend_4
                    7023   ; *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
0000265C  2043      7024          move.l    D3,A0
0000265E  10BC 0002 7025          move.b    #2,(A0)
                    7026   ; return ((void *)0);
00002662  4280      7027          clr.l     D0
00002664  6000 00D8 7028          bra       OSMboxPend_3
                    7029   OSMboxPend_4:
                    7030   ; }
                    7031   ; if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
00002668  1039 0800 7032          move.b    _OSLockNesting.L,D0
0000266C  0310      
0000266E  0C00 0000 7033          cmp.b     #0,D0
00002672  630C      7034          bls.s     OSMboxPend_6
                    7035   ; *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
00002674  2043      7036          move.l    D3,A0
00002676  10BC 000D 7037          move.b    #13,(A0)
                    7038   ; return ((void *)0);
0000267A  4280      7039          clr.l     D0
0000267C  6000 00C0 7040          bra       OSMboxPend_3
                    7041   OSMboxPend_6:
                    7042   ; }
                    7043   ; OS_ENTER_CRITICAL();
00002680  40E7      7044          dc.w      16615
00002682  007C      7045          dc.w      124
00002684  0700      7046          dc.w      1792
                    7047   ; pmsg = pevent->OSEventPtr;
00002686  2044      7048          move.l    D4,A0
00002688  2428 0002 7049          move.l    2(A0),D2
                    7050   ; if (pmsg != (void *)0) {                          /* See if there is already a message             */
0000268C  4A82      7051          tst.l     D2
0000268E  6712      7052          beq.s     OSMboxPend_8
                    7053   ; pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
00002690  2044      7054          move.l    D4,A0
00002692  42A8 0002 7055          clr.l     2(A0)
                    7056   ; OS_EXIT_CRITICAL();
00002696  46DF      7057          dc.w      18143
                    7058   ; *perr = OS_ERR_NONE;
00002698  2043      7059          move.l    D3,A0
0000269A  4210      7060          clr.b     (A0)
                    7061   ; return (pmsg);                                /* Return the message received (or NULL)         */
0000269C  2002      7062          move.l    D2,D0
0000269E  6000 009E 7063          bra       OSMboxPend_3
                    7064   OSMboxPend_8:
                    7065   ; }
                    7066   ; OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
000026A2  2052      7067          move.l    (A2),A0
000026A4  0028 0002 7068          or.b      #2,50(A0)
000026A8  0032      
                    7069   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
000026AA  2052      7070          move.l    (A2),A0
000026AC  4228 0033 7071          clr.b     51(A0)
                    7072   ; OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
000026B0  2052      7073          move.l    (A2),A0
000026B2  216E 000C 7074          move.l    12(A6),46(A0)
000026B6  002E      
                    7075   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
000026B8  2F04      7076          move.l    D4,-(A7)
000026BA  4EB8 10DE 7077          jsr       _OS_EventTaskWait
000026BE  584F      7078          addq.w    #4,A7
                    7079   ; OS_EXIT_CRITICAL();
000026C0  46DF      7080          dc.w      18143
                    7081   ; OS_Sched();                                       /* Find next highest priority task ready to run  */
000026C2  4EB8 15DA 7082          jsr       _OS_Sched
                    7083   ; OS_ENTER_CRITICAL();
000026C6  40E7      7084          dc.w      16615
000026C8  007C      7085          dc.w      124
000026CA  0700      7086          dc.w      1792
                    7087   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
000026CC  2052      7088          move.l    (A2),A0
000026CE  1028 0033 7089          move.b    51(A0),D0
000026D2  C0BC 0000 7090          and.l     #255,D0
000026D6  00FF      
000026D8  0C80 0000 7091          cmp.l     #1,D0
000026DC  0001      
000026DE  6700 002A 7092          beq       OSMboxPend_14
000026E2  6206      7093          bhi.s     OSMboxPend_16
000026E4  4A80      7094          tst.l     D0
000026E6  670C      7095          beq.s     OSMboxPend_12
000026E8  6020      7096          bra.s     OSMboxPend_14
                    7097   OSMboxPend_16:
000026EA  0C80 0000 7098          cmp.l     #2,D0
000026EE  0002      
000026F0  670E      7099          beq.s     OSMboxPend_13
000026F2  6016      7100          bra.s     OSMboxPend_14
                    7101   OSMboxPend_12:
                    7102   ; case OS_STAT_PEND_OK:
                    7103   ; pmsg =  OSTCBCur->OSTCBMsg;
000026F4  2052      7104          move.l    (A2),A0
000026F6  2428 0024 7105          move.l    36(A0),D2
                    7106   ; *perr =  OS_ERR_NONE;
000026FA  2043      7107          move.l    D3,A0
000026FC  4210      7108          clr.b     (A0)
                    7109   ; break;
000026FE  601C      7110          bra.s     OSMboxPend_11
                    7111   OSMboxPend_13:
                    7112   ; case OS_STAT_PEND_ABORT:
                    7113   ; pmsg = (void *)0;
00002700  4282      7114          clr.l     D2
                    7115   ; *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
00002702  2043      7116          move.l    D3,A0
00002704  10BC 000E 7117          move.b    #14,(A0)
                    7118   ; break;
00002708  6012      7119          bra.s     OSMboxPend_11
                    7120   OSMboxPend_14:
                    7121   ; case OS_STAT_PEND_TO:
                    7122   ; default:
                    7123   ; OS_EventTaskRemove(OSTCBCur, pevent);
0000270A  2F04      7124          move.l    D4,-(A7)
0000270C  2F12      7125          move.l    (A2),-(A7)
0000270E  4EB8 1200 7126          jsr       _OS_EventTaskRemove
00002712  504F      7127          addq.w    #8,A7
                    7128   ; pmsg = (void *)0;
00002714  4282      7129          clr.l     D2
                    7130   ; *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
00002716  2043      7131          move.l    D3,A0
00002718  10BC 000A 7132          move.b    #10,(A0)
                    7133   ; break;
                    7134   OSMboxPend_11:
                    7135   ; }
                    7136   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
0000271C  2052      7137          move.l    (A2),A0
0000271E  4228 0032 7138          clr.b     50(A0)
                    7139   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
00002722  2052      7140          move.l    (A2),A0
00002724  4228 0033 7141          clr.b     51(A0)
                    7142   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
00002728  2052      7143          move.l    (A2),A0
0000272A  42A8 001C 7144          clr.l     28(A0)
                    7145   ; #if (OS_EVENT_MULTI_EN > 0u)
                    7146   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
0000272E  2052      7147          move.l    (A2),A0
00002730  42A8 0020 7148          clr.l     32(A0)
                    7149   ; #endif
                    7150   ; OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
00002734  2052      7151          move.l    (A2),A0
00002736  42A8 0024 7152          clr.l     36(A0)
                    7153   ; OS_EXIT_CRITICAL();
0000273A  46DF      7154          dc.w      18143
                    7155   ; return (pmsg);                                    /* Return received message                       */
0000273C  2002      7156          move.l    D2,D0
                    7157   OSMboxPend_3:
0000273E  4CDF 041C 7158          movem.l   (A7)+,D2/D3/D4/A2
00002742  4E5E      7159          unlk      A6
00002744  4E75      7160          rts
                    7161   ; }
                    7162   ; /*$PAGE*/
                    7163   ; /*
                    7164   ; *********************************************************************************************************
                    7165   ; *                                     ABORT WAITING ON A MESSAGE MAILBOX
                    7166   ; *
                    7167   ; * Description: This function aborts & readies any tasks currently waiting on a mailbox.  This function
                    7168   ; *              should be used to fault-abort the wait on the mailbox, rather than to normally signal
                    7169   ; *              the mailbox via OSMboxPost() or OSMboxPostOpt().
                    7170   ; *
                    7171   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox.
                    7172   ; *
                    7173   ; *              opt           determines the type of ABORT performed:
                    7174   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    7175   ; *                                                     mailbox
                    7176   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    7177   ; *                                                     mailbox
                    7178   ; *
                    7179   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    7180   ; *                            messages are:
                    7181   ; *
                    7182   ; *                            OS_ERR_NONE         No tasks were     waiting on the mailbox.
                    7183   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the mailbox was readied
                    7184   ; *                                                and informed of the aborted wait; check return value
                    7185   ; *                                                for the number of tasks whose wait on the mailbox
                    7186   ; *                                                was aborted.
                    7187   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a mailbox.
                    7188   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    7189   ; *
                    7190   ; * Returns    : == 0          if no tasks were waiting on the mailbox, or upon error.
                    7191   ; *              >  0          if one or more tasks waiting on the mailbox are now readied and informed.
                    7192   ; *********************************************************************************************************
                    7193   ; */
                    7194   ; #if OS_MBOX_PEND_ABORT_EN > 0u
                    7195   ; INT8U  OSMboxPendAbort (OS_EVENT  *pevent,
                    7196   ; INT8U      opt,
                    7197   ; INT8U     *perr)
                    7198   ; {
                    7199   _OSMboxPendAbort:
00002746  4E56 0000 7200          link      A6,#0
0000274A  48E7 3800 7201          movem.l   D2/D3/D4,-(A7)
0000274E  242E 0008 7202          move.l    8(A6),D2
00002752  282E 0010 7203          move.l    16(A6),D4
                    7204   ; INT8U      nbr_tasks;
                    7205   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    7206   ; OS_CPU_SR  cpu_sr = 0u;
                    7207   ; #endif
                    7208   ; #ifdef OS_SAFETY_CRITICAL
                    7209   ; if (perr == (INT8U *)0) {
                    7210   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7211   ; return (0u);
                    7212   ; }
                    7213   ; #endif
                    7214   ; #if OS_ARG_CHK_EN > 0u
                    7215   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    7216   ; *perr = OS_ERR_PEVENT_NULL;
                    7217   ; return (0u);
                    7218   ; }
                    7219   ; #endif
                    7220   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00002756  2042      7221          move.l    D2,A0
00002758  1010      7222          move.b    (A0),D0
0000275A  0C00 0001 7223          cmp.b     #1,D0
0000275E  670C      7224          beq.s     OSMboxPendAbort_1
                    7225   ; *perr = OS_ERR_EVENT_TYPE;
00002760  2044      7226          move.l    D4,A0
00002762  10BC 0001 7227          move.b    #1,(A0)
                    7228   ; return (0u);
00002766  4200      7229          clr.b     D0
00002768  6000 008C 7230          bra       OSMboxPendAbort_3
                    7231   OSMboxPendAbort_1:
                    7232   ; }
                    7233   ; OS_ENTER_CRITICAL();
0000276C  40E7      7234          dc.w      16615
0000276E  007C      7235          dc.w      124
00002770  0700      7236          dc.w      1792
                    7237   ; if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on mailbox?      */
00002772  2042      7238          move.l    D2,A0
00002774  1028 0008 7239          move.b    8(A0),D0
00002778  6700 0074 7240          beq       OSMboxPendAbort_4
                    7241   ; nbr_tasks = 0u;
0000277C  4203      7242          clr.b     D3
                    7243   ; switch (opt) {
0000277E  102E 000F 7244          move.b    15(A6),D0
00002782  C0BC 0000 7245          and.l     #255,D0
00002786  00FF      
00002788  0C80 0000 7246          cmp.l     #1,D0
0000278C  0001      
0000278E  670A      7247          beq.s     OSMboxPendAbort_8
00002790  6200 0030 7248          bhi       OSMboxPendAbort_9
00002794  4A80      7249          tst.l     D0
00002796  672A      7250          beq.s     OSMboxPendAbort_9
00002798  6028      7251          bra.s     OSMboxPendAbort_9
                    7252   OSMboxPendAbort_8:
                    7253   ; case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                    7254   ; while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on mailbox  */
                    7255   OSMboxPendAbort_11:
0000279A  2042      7256          move.l    D2,A0
0000279C  1028 0008 7257          move.b    8(A0),D0
000027A0  671E      7258          beq.s     OSMboxPendAbort_13
                    7259   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
000027A2  4878 0002 7260          pea       2
000027A6  4878 0002 7261          pea       2
000027AA  42A7      7262          clr.l     -(A7)
000027AC  2F02      7263          move.l    D2,-(A7)
000027AE  4EB8 0FFA 7264          jsr       _OS_EventTaskRdy
000027B2  DEFC 0010 7265          add.w     #16,A7
000027B6  C0BC 0000 7266          and.l     #255,D0
000027BA  00FF      
                    7267   ; nbr_tasks++;
000027BC  5203      7268          addq.b    #1,D3
000027BE  60DA      7269          bra       OSMboxPendAbort_11
                    7270   OSMboxPendAbort_13:
                    7271   ; }
                    7272   ; break;
000027C0  601C      7273          bra.s     OSMboxPendAbort_7
                    7274   OSMboxPendAbort_9:
                    7275   ; case OS_PEND_OPT_NONE:
                    7276   ; default:                                       /* No,  ready HPT       waiting on mailbox  */
                    7277   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
000027C2  4878 0002 7278          pea       2
000027C6  4878 0002 7279          pea       2
000027CA  42A7      7280          clr.l     -(A7)
000027CC  2F02      7281          move.l    D2,-(A7)
000027CE  4EB8 0FFA 7282          jsr       _OS_EventTaskRdy
000027D2  DEFC 0010 7283          add.w     #16,A7
000027D6  C0BC 0000 7284          and.l     #255,D0
000027DA  00FF      
                    7285   ; nbr_tasks++;
000027DC  5203      7286          addq.b    #1,D3
                    7287   ; break;
                    7288   OSMboxPendAbort_7:
                    7289   ; }
                    7290   ; OS_EXIT_CRITICAL();
000027DE  46DF      7291          dc.w      18143
                    7292   ; OS_Sched();                                        /* Find HPT ready to run                    */
000027E0  4EB8 15DA 7293          jsr       _OS_Sched
                    7294   ; *perr = OS_ERR_PEND_ABORT;
000027E4  2044      7295          move.l    D4,A0
000027E6  10BC 000E 7296          move.b    #14,(A0)
                    7297   ; return (nbr_tasks);
000027EA  1003      7298          move.b    D3,D0
000027EC  6008      7299          bra.s     OSMboxPendAbort_3
                    7300   OSMboxPendAbort_4:
                    7301   ; }
                    7302   ; OS_EXIT_CRITICAL();
000027EE  46DF      7303          dc.w      18143
                    7304   ; *perr = OS_ERR_NONE;
000027F0  2044      7305          move.l    D4,A0
000027F2  4210      7306          clr.b     (A0)
                    7307   ; return (0u);                                           /* No tasks waiting on mailbox              */
000027F4  4200      7308          clr.b     D0
                    7309   OSMboxPendAbort_3:
000027F6  4CDF 001C 7310          movem.l   (A7)+,D2/D3/D4
000027FA  4E5E      7311          unlk      A6
000027FC  4E75      7312          rts
                    7313   ; }
                    7314   ; #endif
                    7315   ; /*$PAGE*/
                    7316   ; /*
                    7317   ; *********************************************************************************************************
                    7318   ; *                                      POST MESSAGE TO A MAILBOX
                    7319   ; *
                    7320   ; * Description: This function sends a message to a mailbox
                    7321   ; *
                    7322   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7323   ; *
                    7324   ; *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
                    7325   ; *
                    7326   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    7327   ; *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
                    7328   ; *                                   message at a time and thus, the message MUST be consumed before you
                    7329   ; *                                   are allowed to send another one.
                    7330   ; *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
                    7331   ; *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
                    7332   ; *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
                    7333   ; *
                    7334   ; * Note(s)    : 1) HPT means Highest Priority Task
                    7335   ; *********************************************************************************************************
                    7336   ; */
                    7337   ; #if OS_MBOX_POST_EN > 0u
                    7338   ; INT8U  OSMboxPost (OS_EVENT  *pevent,
                    7339   ; void      *pmsg)
                    7340   ; {
                    7341   _OSMboxPost:
000027FE  4E56 0000 7342          link      A6,#0
00002802  2F02      7343          move.l    D2,-(A7)
00002804  242E 0008 7344          move.l    8(A6),D2
                    7345   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7346   ; OS_CPU_SR  cpu_sr = 0u;
                    7347   ; #endif
                    7348   ; #if OS_ARG_CHK_EN > 0u
                    7349   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    7350   ; return (OS_ERR_PEVENT_NULL);
                    7351   ; }
                    7352   ; if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
                    7353   ; return (OS_ERR_POST_NULL_PTR);
                    7354   ; }
                    7355   ; #endif
                    7356   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00002808  2042      7357          move.l    D2,A0
0000280A  1010      7358          move.b    (A0),D0
0000280C  0C00 0001 7359          cmp.b     #1,D0
00002810  6706      7360          beq.s     OSMboxPost_1
                    7361   ; return (OS_ERR_EVENT_TYPE);
00002812  7001      7362          moveq     #1,D0
00002814  6000 004E 7363          bra       OSMboxPost_3
                    7364   OSMboxPost_1:
                    7365   ; }
                    7366   ; OS_ENTER_CRITICAL();
00002818  40E7      7367          dc.w      16615
0000281A  007C      7368          dc.w      124
0000281C  0700      7369          dc.w      1792
                    7370   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
0000281E  2042      7371          move.l    D2,A0
00002820  1028 0008 7372          move.b    8(A0),D0
00002824  6724      7373          beq.s     OSMboxPost_4
                    7374   ; /* Ready HPT waiting on event                    */
                    7375   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
00002826  42A7      7376          clr.l     -(A7)
00002828  4878 0002 7377          pea       2
0000282C  2F2E 000C 7378          move.l    12(A6),-(A7)
00002830  2F02      7379          move.l    D2,-(A7)
00002832  4EB8 0FFA 7380          jsr       _OS_EventTaskRdy
00002836  DEFC 0010 7381          add.w     #16,A7
0000283A  C0BC 0000 7382          and.l     #255,D0
0000283E  00FF      
                    7383   ; OS_EXIT_CRITICAL();
00002840  46DF      7384          dc.w      18143
                    7385   ; OS_Sched();                                   /* Find highest priority task ready to run       */
00002842  4EB8 15DA 7386          jsr       _OS_Sched
                    7387   ; return (OS_ERR_NONE);
00002846  4200      7388          clr.b     D0
00002848  601A      7389          bra.s     OSMboxPost_3
                    7390   OSMboxPost_4:
                    7391   ; }
                    7392   ; if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
0000284A  2042      7393          move.l    D2,A0
0000284C  2028 0002 7394          move.l    2(A0),D0
00002850  6706      7395          beq.s     OSMboxPost_6
                    7396   ; OS_EXIT_CRITICAL();
00002852  46DF      7397          dc.w      18143
                    7398   ; return (OS_ERR_MBOX_FULL);
00002854  7014      7399          moveq     #20,D0
00002856  600C      7400          bra.s     OSMboxPost_3
                    7401   OSMboxPost_6:
                    7402   ; }
                    7403   ; pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
00002858  2042      7404          move.l    D2,A0
0000285A  216E 000C 7405          move.l    12(A6),2(A0)
0000285E  0002      
                    7406   ; OS_EXIT_CRITICAL();
00002860  46DF      7407          dc.w      18143
                    7408   ; return (OS_ERR_NONE);
00002862  4200      7409          clr.b     D0
                    7410   OSMboxPost_3:
00002864  241F      7411          move.l    (A7)+,D2
00002866  4E5E      7412          unlk      A6
00002868  4E75      7413          rts
                    7414   ; }
                    7415   ; #endif
                    7416   ; /*$PAGE*/
                    7417   ; /*
                    7418   ; *********************************************************************************************************
                    7419   ; *                                      POST MESSAGE TO A MAILBOX
                    7420   ; *
                    7421   ; * Description: This function sends a message to a mailbox
                    7422   ; *
                    7423   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7424   ; *
                    7425   ; *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
                    7426   ; *
                    7427   ; *              opt           determines the type of POST performed:
                    7428   ; *                            OS_POST_OPT_NONE         POST to a single waiting task
                    7429   ; *                                                     (Identical to OSMboxPost())
                    7430   ; *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the mailbox
                    7431   ; *
                    7432   ; *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
                    7433   ; *
                    7434   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    7435   ; *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
                    7436   ; *                                   message at a time and thus, the message MUST be consumed before you
                    7437   ; *                                   are allowed to send another one.
                    7438   ; *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
                    7439   ; *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
                    7440   ; *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
                    7441   ; *
                    7442   ; * Note(s)    : 1) HPT means Highest Priority Task
                    7443   ; *
                    7444   ; * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
                    7445   ; *              interrupt disable time is proportional to the number of tasks waiting on the mailbox.
                    7446   ; *********************************************************************************************************
                    7447   ; */
                    7448   ; #if OS_MBOX_POST_OPT_EN > 0u
                    7449   ; INT8U  OSMboxPostOpt (OS_EVENT  *pevent,
                    7450   ; void      *pmsg,
                    7451   ; INT8U      opt)
                    7452   ; {
                    7453   _OSMboxPostOpt:
0000286A  4E56 0000 7454          link      A6,#0
0000286E  48E7 3000 7455          movem.l   D2/D3,-(A7)
00002872  242E 0008 7456          move.l    8(A6),D2
00002876  262E 000C 7457          move.l    12(A6),D3
                    7458   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7459   ; OS_CPU_SR  cpu_sr = 0u;
                    7460   ; #endif
                    7461   ; #if OS_ARG_CHK_EN > 0u
                    7462   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    7463   ; return (OS_ERR_PEVENT_NULL);
                    7464   ; }
                    7465   ; if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
                    7466   ; return (OS_ERR_POST_NULL_PTR);
                    7467   ; }
                    7468   ; #endif
                    7469   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
0000287A  2042      7470          move.l    D2,A0
0000287C  1010      7471          move.b    (A0),D0
0000287E  0C00 0001 7472          cmp.b     #1,D0
00002882  6706      7473          beq.s     OSMboxPostOpt_1
                    7474   ; return (OS_ERR_EVENT_TYPE);
00002884  7001      7475          moveq     #1,D0
00002886  6000 0084 7476          bra       OSMboxPostOpt_3
                    7477   OSMboxPostOpt_1:
                    7478   ; }
                    7479   ; OS_ENTER_CRITICAL();
0000288A  40E7      7480          dc.w      16615
0000288C  007C      7481          dc.w      124
0000288E  0700      7482          dc.w      1792
                    7483   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
00002890  2042      7484          move.l    D2,A0
00002892  1028 0008 7485          move.b    8(A0),D0
00002896  6700 005C 7486          beq       OSMboxPostOpt_4
                    7487   ; if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
0000289A  102E 0013 7488          move.b    19(A6),D0
0000289E  C03C 0001 7489          and.b     #1,D0
000028A2  6724      7490          beq.s     OSMboxPostOpt_6
                    7491   ; while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
                    7492   OSMboxPostOpt_8:
000028A4  2042      7493          move.l    D2,A0
000028A6  1028 0008 7494          move.b    8(A0),D0
000028AA  671A      7495          beq.s     OSMboxPostOpt_10
                    7496   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
000028AC  42A7      7497          clr.l     -(A7)
000028AE  4878 0002 7498          pea       2
000028B2  2F03      7499          move.l    D3,-(A7)
000028B4  2F02      7500          move.l    D2,-(A7)
000028B6  4EB8 0FFA 7501          jsr       _OS_EventTaskRdy
000028BA  DEFC 0010 7502          add.w     #16,A7
000028BE  C0BC 0000 7503          and.l     #255,D0
000028C2  00FF      
000028C4  60DE      7504          bra       OSMboxPostOpt_8
                    7505   OSMboxPostOpt_10:
000028C6  6018      7506          bra.s     OSMboxPostOpt_7
                    7507   OSMboxPostOpt_6:
                    7508   ; }
                    7509   ; } else {                                      /* No,  Post to HPT waiting on mbox              */
                    7510   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
000028C8  42A7      7511          clr.l     -(A7)
000028CA  4878 0002 7512          pea       2
000028CE  2F03      7513          move.l    D3,-(A7)
000028D0  2F02      7514          move.l    D2,-(A7)
000028D2  4EB8 0FFA 7515          jsr       _OS_EventTaskRdy
000028D6  DEFC 0010 7516          add.w     #16,A7
000028DA  C0BC 0000 7517          and.l     #255,D0
000028DE  00FF      
                    7518   OSMboxPostOpt_7:
                    7519   ; }
                    7520   ; OS_EXIT_CRITICAL();
000028E0  46DF      7521          dc.w      18143
                    7522   ; if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
000028E2  102E 0013 7523          move.b    19(A6),D0
000028E6  C03C 0004 7524          and.b     #4,D0
000028EA  6604      7525          bne.s     OSMboxPostOpt_11
                    7526   ; OS_Sched();                               /* Find HPT ready to run                         */
000028EC  4EB8 15DA 7527          jsr       _OS_Sched
                    7528   OSMboxPostOpt_11:
                    7529   ; }
                    7530   ; return (OS_ERR_NONE);
000028F0  4200      7531          clr.b     D0
000028F2  6018      7532          bra.s     OSMboxPostOpt_3
                    7533   OSMboxPostOpt_4:
                    7534   ; }
                    7535   ; if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
000028F4  2042      7536          move.l    D2,A0
000028F6  2028 0002 7537          move.l    2(A0),D0
000028FA  6706      7538          beq.s     OSMboxPostOpt_13
                    7539   ; OS_EXIT_CRITICAL();
000028FC  46DF      7540          dc.w      18143
                    7541   ; return (OS_ERR_MBOX_FULL);
000028FE  7014      7542          moveq     #20,D0
00002900  600A      7543          bra.s     OSMboxPostOpt_3
                    7544   OSMboxPostOpt_13:
                    7545   ; }
                    7546   ; pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
00002902  2042      7547          move.l    D2,A0
00002904  2143 0002 7548          move.l    D3,2(A0)
                    7549   ; OS_EXIT_CRITICAL();
00002908  46DF      7550          dc.w      18143
                    7551   ; return (OS_ERR_NONE);
0000290A  4200      7552          clr.b     D0
                    7553   OSMboxPostOpt_3:
0000290C  4CDF 000C 7554          movem.l   (A7)+,D2/D3
00002910  4E5E      7555          unlk      A6
00002912  4E75      7556          rts
                    7557   ; }
                    7558   ; #endif
                    7559   ; /*$PAGE*/
                    7560   ; /*
                    7561   ; *********************************************************************************************************
                    7562   ; *                                       QUERY A MESSAGE MAILBOX
                    7563   ; *
                    7564   ; * Description: This function obtains information about a message mailbox.
                    7565   ; *
                    7566   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7567   ; *
                    7568   ; *              p_mbox_data   is a pointer to a structure that will contain information about the message
                    7569   ; *                            mailbox.
                    7570   ; *
                    7571   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    7572   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non mailbox.
                    7573   ; *              OS_ERR_PEVENT_NULL  If 'pevent'      is a NULL pointer
                    7574   ; *              OS_ERR_PDATA_NULL   If 'p_mbox_data' is a NULL pointer
                    7575   ; *********************************************************************************************************
                    7576   ; */
                    7577   ; #if OS_MBOX_QUERY_EN > 0u
                    7578   ; INT8U  OSMboxQuery (OS_EVENT      *pevent,
                    7579   ; OS_MBOX_DATA  *p_mbox_data)
                    7580   ; {
                    7581   _OSMboxQuery:
00002914  4E56 FFF8 7582          link      A6,#-8
00002918  48E7 3800 7583          movem.l   D2/D3/D4,-(A7)
0000291C  242E 0008 7584          move.l    8(A6),D2
00002920  282E 000C 7585          move.l    12(A6),D4
                    7586   ; INT8U       i;
                    7587   ; OS_PRIO    *psrc;
                    7588   ; OS_PRIO    *pdest;
                    7589   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    7590   ; OS_CPU_SR   cpu_sr = 0u;
                    7591   ; #endif
                    7592   ; #if OS_ARG_CHK_EN > 0u
                    7593   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    7594   ; return (OS_ERR_PEVENT_NULL);
                    7595   ; }
                    7596   ; if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
                    7597   ; return (OS_ERR_PDATA_NULL);
                    7598   ; }
                    7599   ; #endif
                    7600   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00002924  2042      7601          move.l    D2,A0
00002926  1010      7602          move.b    (A0),D0
00002928  0C00 0001 7603          cmp.b     #1,D0
0000292C  6706      7604          beq.s     OSMboxQuery_1
                    7605   ; return (OS_ERR_EVENT_TYPE);
0000292E  7001      7606          moveq     #1,D0
00002930  6000 004C 7607          bra       OSMboxQuery_3
                    7608   OSMboxQuery_1:
                    7609   ; }
                    7610   ; OS_ENTER_CRITICAL();
00002934  40E7      7611          dc.w      16615
00002936  007C      7612          dc.w      124
00002938  0700      7613          dc.w      1792
                    7614   ; p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
0000293A  2042      7615          move.l    D2,A0
0000293C  2244      7616          move.l    D4,A1
0000293E  1368 0008 7617          move.b    8(A0),12(A1)
00002942  000C      
                    7618   ; psrc                    = &pevent->OSEventTbl[0];
00002944  700A      7619          moveq     #10,D0
00002946  D082      7620          add.l     D2,D0
00002948  2D40 FFF8 7621          move.l    D0,-8(A6)
                    7622   ; pdest                   = &p_mbox_data->OSEventTbl[0];
0000294C  7004      7623          moveq     #4,D0
0000294E  D084      7624          add.l     D4,D0
00002950  2D40 FFFC 7625          move.l    D0,-4(A6)
                    7626   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
00002954  4203      7627          clr.b     D3
                    7628   OSMboxQuery_4:
00002956  0C03 0008 7629          cmp.b     #8,D3
0000295A  6416      7630          bhs.s     OSMboxQuery_6
                    7631   ; *pdest++ = *psrc++;
0000295C  206E FFF8 7632          move.l    -8(A6),A0
00002960  52AE FFF8 7633          addq.l    #1,-8(A6)
00002964  226E FFFC 7634          move.l    -4(A6),A1
00002968  52AE FFFC 7635          addq.l    #1,-4(A6)
0000296C  1290      7636          move.b    (A0),(A1)
0000296E  5203      7637          addq.b    #1,D3
00002970  60E4      7638          bra       OSMboxQuery_4
                    7639   OSMboxQuery_6:
                    7640   ; }
                    7641   ; p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
00002972  2042      7642          move.l    D2,A0
00002974  2244      7643          move.l    D4,A1
00002976  22A8 0002 7644          move.l    2(A0),(A1)
                    7645   ; OS_EXIT_CRITICAL();
0000297A  46DF      7646          dc.w      18143
                    7647   ; return (OS_ERR_NONE);
0000297C  4200      7648          clr.b     D0
                    7649   OSMboxQuery_3:
0000297E  4CDF 001C 7650          movem.l   (A7)+,D2/D3/D4
00002982  4E5E      7651          unlk      A6
00002984  4E75      7652          rts
                    7653   ; /*
                    7654   ; *********************************************************************************************************
                    7655   ; *                                                uC/OS-II
                    7656   ; *                                          The Real-Time Kernel
                    7657   ; *                                            MEMORY MANAGEMENT
                    7658   ; *
                    7659   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    7660   ; *                                           All Rights Reserved
                    7661   ; *
                    7662   ; * File    : OS_MEM.C
                    7663   ; * By      : Jean J. Labrosse
                    7664   ; * Version : V2.92.07
                    7665   ; *
                    7666   ; * LICENSING TERMS:
                    7667   ; * ---------------
                    7668   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    7669   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    7670   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    7671   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    7672   ; * licensing fee.
                    7673   ; *********************************************************************************************************
                    7674   ; */
                    7675   ; #define  MICRIUM_SOURCE
                    7676   ; #ifndef  OS_MASTER_FILE
                    7677   ; #include <ucos_ii.h>
                    7678   ; #endif
                    7679   ; #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
                    7680   ; /*
                    7681   ; *********************************************************************************************************
                    7682   ; *                                      CREATE A MEMORY PARTITION
                    7683   ; *
                    7684   ; * Description : Create a fixed-sized memory partition that will be managed by uC/OS-II.
                    7685   ; *
                    7686   ; * Arguments   : addr     is the starting address of the memory partition
                    7687   ; *
                    7688   ; *               nblks    is the number of memory blocks to create from the partition.
                    7689   ; *
                    7690   ; *               blksize  is the size (in bytes) of each block in the memory partition.
                    7691   ; *
                    7692   ; *               perr     is a pointer to a variable containing an error message which will be set by
                    7693   ; *                        this function to either:
                    7694   ; *
                    7695   ; *                        OS_ERR_NONE              if the memory partition has been created correctly.
                    7696   ; *                        OS_ERR_MEM_INVALID_ADDR  if you are specifying an invalid address for the memory
                    7697   ; *                                                 storage of the partition or, the block does not align
                    7698   ; *                                                 on a pointer boundary
                    7699   ; *                        OS_ERR_MEM_INVALID_PART  no free partitions available
                    7700   ; *                        OS_ERR_MEM_INVALID_BLKS  user specified an invalid number of blocks (must be >= 2)
                    7701   ; *                        OS_ERR_MEM_INVALID_SIZE  user specified an invalid block size
                    7702   ; *                                                   - must be greater than the size of a pointer
                    7703   ; *                                                   - must be able to hold an integral number of pointers
                    7704   ; * Returns    : != (OS_MEM *)0  is the partition was created
                    7705   ; *              == (OS_MEM *)0  if the partition was not created because of invalid arguments or, no
                    7706   ; *                              free partition is available.
                    7707   ; *********************************************************************************************************
                    7708   ; */
                    7709   ; OS_MEM  *OSMemCreate (void   *addr,
                    7710   ; INT32U  nblks,
                    7711   ; INT32U  blksize,
                    7712   ; INT8U  *perr)
                    7713   ; {
                    7714   _OSMemCreate:
00002986  4E56 FFFC 7715          link      A6,#-4
0000298A  48E7 3F20 7716          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
0000298E  282E 0008 7717          move.l    8(A6),D4
00002992  45F9 0800 7718          lea       _OSMemFreeList.L,A2
00002996  0C9C      
00002998  2E2E 000C 7719          move.l    12(A6),D7
                    7720   ; OS_MEM    *pmem;
                    7721   ; INT8U     *pblk;
                    7722   ; void     **plink;
                    7723   ; INT32U     loops;
                    7724   ; INT32U     i;
                    7725   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7726   ; OS_CPU_SR  cpu_sr = 0u;
                    7727   ; #endif
                    7728   ; #ifdef OS_SAFETY_CRITICAL
                    7729   ; if (perr == (INT8U *)0) {
                    7730   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7731   ; return ((OS_MEM *)0);
                    7732   ; }
                    7733   ; #endif
                    7734   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    7735   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    7736   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7737   ; return ((OS_MEM *)0);
                    7738   ; }
                    7739   ; #endif
                    7740   ; #if OS_ARG_CHK_EN > 0u
                    7741   ; if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
                    7742   ; *perr = OS_ERR_MEM_INVALID_ADDR;
                    7743   ; return ((OS_MEM *)0);
                    7744   ; }
                    7745   ; if (((INT32U)addr & (sizeof(void *) - 1u)) != 0u){  /* Must be pointer size aligned                */
                    7746   ; *perr = OS_ERR_MEM_INVALID_ADDR;
                    7747   ; return ((OS_MEM *)0);
                    7748   ; }
                    7749   ; if (nblks < 2u) {                                 /* Must have at least 2 blocks per partition     */
                    7750   ; *perr = OS_ERR_MEM_INVALID_BLKS;
                    7751   ; return ((OS_MEM *)0);
                    7752   ; }
                    7753   ; if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
                    7754   ; *perr = OS_ERR_MEM_INVALID_SIZE;
                    7755   ; return ((OS_MEM *)0);
                    7756   ; }
                    7757   ; #endif
                    7758   ; OS_ENTER_CRITICAL();
0000299C  40E7      7759          dc.w      16615
0000299E  007C      7760          dc.w      124
000029A0  0700      7761          dc.w      1792
                    7762   ; pmem = OSMemFreeList;                             /* Get next free memory partition                */
000029A2  2412      7763          move.l    (A2),D2
                    7764   ; if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
000029A4  2012      7765          move.l    (A2),D0
000029A6  6706      7766          beq.s     OSMemCreate_1
                    7767   ; OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
000029A8  2052      7768          move.l    (A2),A0
000029AA  24A8 0004 7769          move.l    4(A0),(A2)
                    7770   OSMemCreate_1:
                    7771   ; }
                    7772   ; OS_EXIT_CRITICAL();
000029AE  46DF      7773          dc.w      18143
                    7774   ; if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
000029B0  4A82      7775          tst.l     D2
000029B2  660E      7776          bne.s     OSMemCreate_3
                    7777   ; *perr = OS_ERR_MEM_INVALID_PART;
000029B4  206E 0014 7778          move.l    20(A6),A0
000029B8  10BC 005A 7779          move.b    #90,(A0)
                    7780   ; return ((OS_MEM *)0);
000029BC  4280      7781          clr.l     D0
000029BE  6000 0050 7782          bra       OSMemCreate_5
                    7783   OSMemCreate_3:
                    7784   ; }
                    7785   ; plink = (void **)addr;                            /* Create linked list of free memory blocks      */
000029C2  2A04      7786          move.l    D4,D5
                    7787   ; pblk  = (INT8U *)addr;
000029C4  2604      7788          move.l    D4,D3
                    7789   ; loops  = nblks - 1u;
000029C6  2007      7790          move.l    D7,D0
000029C8  5380      7791          subq.l    #1,D0
000029CA  2D40 FFFC 7792          move.l    D0,-4(A6)
                    7793   ; for (i = 0u; i < loops; i++) {
000029CE  4286      7794          clr.l     D6
                    7795   OSMemCreate_6:
000029D0  BCAE FFFC 7796          cmp.l     -4(A6),D6
000029D4  6410      7797          bhs.s     OSMemCreate_8
                    7798   ; pblk +=  blksize;                             /* Point to the FOLLOWING block                  */
000029D6  202E 0010 7799          move.l    16(A6),D0
000029DA  D680      7800          add.l     D0,D3
                    7801   ; *plink = (void  *)pblk;                        /* Save pointer to NEXT block in CURRENT block   */
000029DC  2045      7802          move.l    D5,A0
000029DE  2083      7803          move.l    D3,(A0)
                    7804   ; plink = (void **)pblk;                        /* Position to  NEXT      block                  */
000029E0  2A03      7805          move.l    D3,D5
000029E2  5286      7806          addq.l    #1,D6
000029E4  60EA      7807          bra       OSMemCreate_6
                    7808   OSMemCreate_8:
                    7809   ; }
                    7810   ; *plink              = (void *)0;                  /* Last memory block points to NULL              */
000029E6  2045      7811          move.l    D5,A0
000029E8  4290      7812          clr.l     (A0)
                    7813   ; pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
000029EA  2042      7814          move.l    D2,A0
000029EC  2084      7815          move.l    D4,(A0)
                    7816   ; pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
000029EE  2042      7817          move.l    D2,A0
000029F0  2144 0004 7818          move.l    D4,4(A0)
                    7819   ; pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
000029F4  2042      7820          move.l    D2,A0
000029F6  2147 0010 7821          move.l    D7,16(A0)
                    7822   ; pmem->OSMemNBlks    = nblks;
000029FA  2042      7823          move.l    D2,A0
000029FC  2147 000C 7824          move.l    D7,12(A0)
                    7825   ; pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
00002A00  2042      7826          move.l    D2,A0
00002A02  216E 0010 7827          move.l    16(A6),8(A0)
00002A06  0008      
                    7828   ; *perr               = OS_ERR_NONE;
00002A08  206E 0014 7829          move.l    20(A6),A0
00002A0C  4210      7830          clr.b     (A0)
                    7831   ; return (pmem);
00002A0E  2002      7832          move.l    D2,D0
                    7833   OSMemCreate_5:
00002A10  4CDF 04FC 7834          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
00002A14  4E5E      7835          unlk      A6
00002A16  4E75      7836          rts
                    7837   ; }
                    7838   ; /*$PAGE*/
                    7839   ; /*
                    7840   ; *********************************************************************************************************
                    7841   ; *                                         GET A MEMORY BLOCK
                    7842   ; *
                    7843   ; * Description : Get a memory block from a partition
                    7844   ; *
                    7845   ; * Arguments   : pmem    is a pointer to the memory partition control block
                    7846   ; *
                    7847   ; *               perr    is a pointer to a variable containing an error message which will be set by this
                    7848   ; *                       function to either:
                    7849   ; *
                    7850   ; *                       OS_ERR_NONE             if the memory partition has been created correctly.
                    7851   ; *                       OS_ERR_MEM_NO_FREE_BLKS if there are no more free memory blocks to allocate to caller
                    7852   ; *                       OS_ERR_MEM_INVALID_PMEM if you passed a NULL pointer for 'pmem'
                    7853   ; *
                    7854   ; * Returns     : A pointer to a memory block if no error is detected
                    7855   ; *               A pointer to NULL if an error is detected
                    7856   ; *********************************************************************************************************
                    7857   ; */
                    7858   ; void  *OSMemGet (OS_MEM  *pmem,
                    7859   ; INT8U   *perr)
                    7860   ; {
                    7861   _OSMemGet:
00002A18  4E56 0000 7862          link      A6,#0
00002A1C  48E7 3000 7863          movem.l   D2/D3,-(A7)
00002A20  242E 0008 7864          move.l    8(A6),D2
                    7865   ; void      *pblk;
                    7866   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7867   ; OS_CPU_SR  cpu_sr = 0u;
                    7868   ; #endif
                    7869   ; #ifdef OS_SAFETY_CRITICAL
                    7870   ; if (perr == (INT8U *)0) {
                    7871   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7872   ; return ((void *)0);
                    7873   ; }
                    7874   ; #endif
                    7875   ; #if OS_ARG_CHK_EN > 0u
                    7876   ; if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
                    7877   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    7878   ; return ((void *)0);
                    7879   ; }
                    7880   ; #endif
                    7881   ; OS_ENTER_CRITICAL();
00002A24  40E7      7882          dc.w      16615
00002A26  007C      7883          dc.w      124
00002A28  0700      7884          dc.w      1792
                    7885   ; if (pmem->OSMemNFree > 0u) {                      /* See if there are any free memory blocks       */
00002A2A  2042      7886          move.l    D2,A0
00002A2C  2028 0010 7887          move.l    16(A0),D0
00002A30  0C80 0000 7888          cmp.l     #0,D0
00002A34  0000      
00002A36  6326      7889          bls.s     OSMemGet_1
                    7890   ; pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
00002A38  2042      7891          move.l    D2,A0
00002A3A  2628 0004 7892          move.l    4(A0),D3
                    7893   ; pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
00002A3E  2043      7894          move.l    D3,A0
00002A40  2242      7895          move.l    D2,A1
00002A42  2350 0004 7896          move.l    (A0),4(A1)
                    7897   ; pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
00002A46  2002      7898          move.l    D2,D0
00002A48  0680 0000 7899          add.l     #16,D0
00002A4C  0010      
00002A4E  2040      7900          move.l    D0,A0
00002A50  5390      7901          subq.l    #1,(A0)
                    7902   ; OS_EXIT_CRITICAL();
00002A52  46DF      7903          dc.w      18143
                    7904   ; *perr = OS_ERR_NONE;                          /*      No error                                 */
00002A54  206E 000C 7905          move.l    12(A6),A0
00002A58  4210      7906          clr.b     (A0)
                    7907   ; return (pblk);                                /*      Return memory block to caller            */
00002A5A  2003      7908          move.l    D3,D0
00002A5C  600C      7909          bra.s     OSMemGet_3
                    7910   OSMemGet_1:
                    7911   ; }
                    7912   ; OS_EXIT_CRITICAL();
00002A5E  46DF      7913          dc.w      18143
                    7914   ; *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
00002A60  206E 000C 7915          move.l    12(A6),A0
00002A64  10BC 005D 7916          move.b    #93,(A0)
                    7917   ; return ((void *)0);                               /*      Return NULL pointer to caller            */
00002A68  4280      7918          clr.l     D0
                    7919   OSMemGet_3:
00002A6A  4CDF 000C 7920          movem.l   (A7)+,D2/D3
00002A6E  4E5E      7921          unlk      A6
00002A70  4E75      7922          rts
                    7923   ; }
                    7924   ; /*$PAGE*/
                    7925   ; /*
                    7926   ; *********************************************************************************************************
                    7927   ; *                                 GET THE NAME OF A MEMORY PARTITION
                    7928   ; *
                    7929   ; * Description: This function is used to obtain the name assigned to a memory partition.
                    7930   ; *
                    7931   ; * Arguments  : pmem      is a pointer to the memory partition
                    7932   ; *
                    7933   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the memory partition.
                    7934   ; *
                    7935   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    7936   ; *
                    7937   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    7938   ; *                        OS_ERR_MEM_INVALID_PMEM    if you passed a NULL pointer for 'pmem'
                    7939   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    7940   ; *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
                    7941   ; *
                    7942   ; * Returns    : The length of the string or 0 if 'pmem' is a NULL pointer.
                    7943   ; *********************************************************************************************************
                    7944   ; */
                    7945   ; #if OS_MEM_NAME_EN > 0u
                    7946   ; INT8U  OSMemNameGet (OS_MEM   *pmem,
                    7947   ; INT8U   **pname,
                    7948   ; INT8U    *perr)
                    7949   ; {
                    7950   _OSMemNameGet:
00002A72  4E56 FFFC 7951          link      A6,#-4
                    7952   ; INT8U      len;
                    7953   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    7954   ; OS_CPU_SR  cpu_sr = 0u;
                    7955   ; #endif
                    7956   ; #ifdef OS_SAFETY_CRITICAL
                    7957   ; if (perr == (INT8U *)0) {
                    7958   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7959   ; return (0u);
                    7960   ; }
                    7961   ; #endif
                    7962   ; #if OS_ARG_CHK_EN > 0u
                    7963   ; if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
                    7964   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    7965   ; return (0u);
                    7966   ; }
                    7967   ; if (pname == (INT8U **)0) {                  /* Is 'pname' a NULL pointer?                         */
                    7968   ; *perr = OS_ERR_PNAME_NULL;
                    7969   ; return (0u);
                    7970   ; }
                    7971   ; #endif
                    7972   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00002A76  1039 0800 7973          move.b    _OSIntNesting.L,D0
00002A7A  030E      
00002A7C  0C00 0000 7974          cmp.b     #0,D0
00002A80  630C      7975          bls.s     OSMemNameGet_1
                    7976   ; *perr = OS_ERR_NAME_GET_ISR;
00002A82  206E 0010 7977          move.l    16(A6),A0
00002A86  10BC 0011 7978          move.b    #17,(A0)
                    7979   ; return (0u);
00002A8A  4200      7980          clr.b     D0
00002A8C  602E      7981          bra.s     OSMemNameGet_3
                    7982   OSMemNameGet_1:
                    7983   ; }
                    7984   ; OS_ENTER_CRITICAL();
00002A8E  40E7      7985          dc.w      16615
00002A90  007C      7986          dc.w      124
00002A92  0700      7987          dc.w      1792
                    7988   ; *pname = pmem->OSMemName;
00002A94  206E 0008 7989          move.l    8(A6),A0
00002A98  226E 000C 7990          move.l    12(A6),A1
00002A9C  22A8 0014 7991          move.l    20(A0),(A1)
                    7992   ; len    = OS_StrLen(*pname);
00002AA0  206E 000C 7993          move.l    12(A6),A0
00002AA4  2F10      7994          move.l    (A0),-(A7)
00002AA6  4EB8 1684 7995          jsr       _OS_StrLen
00002AAA  584F      7996          addq.w    #4,A7
00002AAC  1D40 FFFF 7997          move.b    D0,-1(A6)
                    7998   ; OS_EXIT_CRITICAL();
00002AB0  46DF      7999          dc.w      18143
                    8000   ; *perr  = OS_ERR_NONE;
00002AB2  206E 0010 8001          move.l    16(A6),A0
00002AB6  4210      8002          clr.b     (A0)
                    8003   ; return (len);
00002AB8  102E FFFF 8004          move.b    -1(A6),D0
                    8005   OSMemNameGet_3:
00002ABC  4E5E      8006          unlk      A6
00002ABE  4E75      8007          rts
                    8008   ; }
                    8009   ; #endif
                    8010   ; /*$PAGE*/
                    8011   ; /*
                    8012   ; *********************************************************************************************************
                    8013   ; *                                 ASSIGN A NAME TO A MEMORY PARTITION
                    8014   ; *
                    8015   ; * Description: This function assigns a name to a memory partition.
                    8016   ; *
                    8017   ; * Arguments  : pmem      is a pointer to the memory partition
                    8018   ; *
                    8019   ; *              pname     is a pointer to an ASCII string that contains the name of the memory partition.
                    8020   ; *
                    8021   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    8022   ; *
                    8023   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    8024   ; *                        OS_ERR_MEM_INVALID_PMEM    if you passed a NULL pointer for 'pmem'
                    8025   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    8026   ; *                        OS_ERR_MEM_NAME_TOO_LONG   if the name doesn't fit in the storage area
                    8027   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    8028   ; *
                    8029   ; * Returns    : None
                    8030   ; *********************************************************************************************************
                    8031   ; */
                    8032   ; #if OS_MEM_NAME_EN > 0u
                    8033   ; void  OSMemNameSet (OS_MEM  *pmem,
                    8034   ; INT8U   *pname,
                    8035   ; INT8U   *perr)
                    8036   ; {
                    8037   _OSMemNameSet:
00002AC0  4E56 0000 8038          link      A6,#0
                    8039   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8040   ; OS_CPU_SR  cpu_sr = 0u;
                    8041   ; #endif
                    8042   ; #ifdef OS_SAFETY_CRITICAL
                    8043   ; if (perr == (INT8U *)0) {
                    8044   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8045   ; return;
                    8046   ; }
                    8047   ; #endif
                    8048   ; #if OS_ARG_CHK_EN > 0u
                    8049   ; if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
                    8050   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    8051   ; return;
                    8052   ; }
                    8053   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    8054   ; *perr = OS_ERR_PNAME_NULL;
                    8055   ; return;
                    8056   ; }
                    8057   ; #endif
                    8058   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00002AC4  1039 0800 8059          move.b    _OSIntNesting.L,D0
00002AC8  030E      
00002ACA  0C00 0000 8060          cmp.b     #0,D0
00002ACE  630A      8061          bls.s     OSMemNameSet_1
                    8062   ; *perr = OS_ERR_NAME_SET_ISR;
00002AD0  206E 0010 8063          move.l    16(A6),A0
00002AD4  10BC 0012 8064          move.b    #18,(A0)
                    8065   ; return;
00002AD8  6018      8066          bra.s     OSMemNameSet_3
                    8067   OSMemNameSet_1:
                    8068   ; }
                    8069   ; OS_ENTER_CRITICAL();
00002ADA  40E7      8070          dc.w      16615
00002ADC  007C      8071          dc.w      124
00002ADE  0700      8072          dc.w      1792
                    8073   ; pmem->OSMemName = pname;
00002AE0  206E 0008 8074          move.l    8(A6),A0
00002AE4  216E 000C 8075          move.l    12(A6),20(A0)
00002AE8  0014      
                    8076   ; OS_EXIT_CRITICAL();
00002AEA  46DF      8077          dc.w      18143
                    8078   ; *perr           = OS_ERR_NONE;
00002AEC  206E 0010 8079          move.l    16(A6),A0
00002AF0  4210      8080          clr.b     (A0)
                    8081   OSMemNameSet_3:
00002AF2  4E5E      8082          unlk      A6
00002AF4  4E75      8083          rts
                    8084   ; }
                    8085   ; #endif
                    8086   ; /*$PAGE*/
                    8087   ; /*
                    8088   ; *********************************************************************************************************
                    8089   ; *                                       RELEASE A MEMORY BLOCK
                    8090   ; *
                    8091   ; * Description : Returns a memory block to a partition
                    8092   ; *
                    8093   ; * Arguments   : pmem    is a pointer to the memory partition control block
                    8094   ; *
                    8095   ; *               pblk    is a pointer to the memory block being released.
                    8096   ; *
                    8097   ; * Returns     : OS_ERR_NONE              if the memory block was inserted into the partition
                    8098   ; *               OS_ERR_MEM_FULL          if you are returning a memory block to an already FULL memory
                    8099   ; *                                        partition (You freed more blocks than you allocated!)
                    8100   ; *               OS_ERR_MEM_INVALID_PMEM  if you passed a NULL pointer for 'pmem'
                    8101   ; *               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
                    8102   ; *********************************************************************************************************
                    8103   ; */
                    8104   ; INT8U  OSMemPut (OS_MEM  *pmem,
                    8105   ; void    *pblk)
                    8106   ; {
                    8107   _OSMemPut:
00002AF6  4E56 0000 8108          link      A6,#0
00002AFA  2F02      8109          move.l    D2,-(A7)
00002AFC  242E 0008 8110          move.l    8(A6),D2
                    8111   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8112   ; OS_CPU_SR  cpu_sr = 0u;
                    8113   ; #endif
                    8114   ; #if OS_ARG_CHK_EN > 0u
                    8115   ; if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
                    8116   ; return (OS_ERR_MEM_INVALID_PMEM);
                    8117   ; }
                    8118   ; if (pblk == (void *)0) {                     /* Must release a valid block                         */
                    8119   ; return (OS_ERR_MEM_INVALID_PBLK);
                    8120   ; }
                    8121   ; #endif
                    8122   ; OS_ENTER_CRITICAL();
00002B00  40E7      8123          dc.w      16615
00002B02  007C      8124          dc.w      124
00002B04  0700      8125          dc.w      1792
                    8126   ; if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
00002B06  2042      8127          move.l    D2,A0
00002B08  2242      8128          move.l    D2,A1
00002B0A  2028 0010 8129          move.l    16(A0),D0
00002B0E  B0A9 000C 8130          cmp.l     12(A1),D0
00002B12  6506      8131          blo.s     OSMemPut_1
                    8132   ; OS_EXIT_CRITICAL();
00002B14  46DF      8133          dc.w      18143
                    8134   ; return (OS_ERR_MEM_FULL);
00002B16  705E      8135          moveq     #94,D0
00002B18  6024      8136          bra.s     OSMemPut_3
                    8137   OSMemPut_1:
                    8138   ; }
                    8139   ; *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
00002B1A  2042      8140          move.l    D2,A0
00002B1C  202E 000C 8141          move.l    12(A6),D0
00002B20  2240      8142          move.l    D0,A1
00002B22  22A8 0004 8143          move.l    4(A0),(A1)
                    8144   ; pmem->OSMemFreeList = pblk;
00002B26  2042      8145          move.l    D2,A0
00002B28  216E 000C 8146          move.l    12(A6),4(A0)
00002B2C  0004      
                    8147   ; pmem->OSMemNFree++;                          /* One more memory block in this partition            */
00002B2E  2002      8148          move.l    D2,D0
00002B30  0680 0000 8149          add.l     #16,D0
00002B34  0010      
00002B36  2040      8150          move.l    D0,A0
00002B38  5290      8151          addq.l    #1,(A0)
                    8152   ; OS_EXIT_CRITICAL();
00002B3A  46DF      8153          dc.w      18143
                    8154   ; return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
00002B3C  4200      8155          clr.b     D0
                    8156   OSMemPut_3:
00002B3E  241F      8157          move.l    (A7)+,D2
00002B40  4E5E      8158          unlk      A6
00002B42  4E75      8159          rts
                    8160   ; }
                    8161   ; /*$PAGE*/
                    8162   ; /*
                    8163   ; *********************************************************************************************************
                    8164   ; *                                       QUERY MEMORY PARTITION
                    8165   ; *
                    8166   ; * Description : This function is used to determine the number of free memory blocks and the number of
                    8167   ; *               used memory blocks from a memory partition.
                    8168   ; *
                    8169   ; * Arguments   : pmem        is a pointer to the memory partition control block
                    8170   ; *
                    8171   ; *               p_mem_data  is a pointer to a structure that will contain information about the memory
                    8172   ; *                           partition.
                    8173   ; *
                    8174   ; * Returns     : OS_ERR_NONE               if no errors were found.
                    8175   ; *               OS_ERR_MEM_INVALID_PMEM   if you passed a NULL pointer for 'pmem'
                    8176   ; *               OS_ERR_MEM_INVALID_PDATA  if you passed a NULL pointer to the data recipient.
                    8177   ; *********************************************************************************************************
                    8178   ; */
                    8179   ; #if OS_MEM_QUERY_EN > 0u
                    8180   ; INT8U  OSMemQuery (OS_MEM       *pmem,
                    8181   ; OS_MEM_DATA  *p_mem_data)
                    8182   ; {
                    8183   _OSMemQuery:
00002B44  4E56 0000 8184          link      A6,#0
00002B48  48E7 3000 8185          movem.l   D2/D3,-(A7)
00002B4C  242E 000C 8186          move.l    12(A6),D2
00002B50  262E 0008 8187          move.l    8(A6),D3
                    8188   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8189   ; OS_CPU_SR  cpu_sr = 0u;
                    8190   ; #endif
                    8191   ; #if OS_ARG_CHK_EN > 0u
                    8192   ; if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
                    8193   ; return (OS_ERR_MEM_INVALID_PMEM);
                    8194   ; }
                    8195   ; if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
                    8196   ; return (OS_ERR_MEM_INVALID_PDATA);
                    8197   ; }
                    8198   ; #endif
                    8199   ; OS_ENTER_CRITICAL();
00002B54  40E7      8200          dc.w      16615
00002B56  007C      8201          dc.w      124
00002B58  0700      8202          dc.w      1792
                    8203   ; p_mem_data->OSAddr     = pmem->OSMemAddr;
00002B5A  2043      8204          move.l    D3,A0
00002B5C  2242      8205          move.l    D2,A1
00002B5E  2290      8206          move.l    (A0),(A1)
                    8207   ; p_mem_data->OSFreeList = pmem->OSMemFreeList;
00002B60  2043      8208          move.l    D3,A0
00002B62  2242      8209          move.l    D2,A1
00002B64  2368 0004 8210          move.l    4(A0),4(A1)
00002B68  0004      
                    8211   ; p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
00002B6A  2043      8212          move.l    D3,A0
00002B6C  2242      8213          move.l    D2,A1
00002B6E  2368 0008 8214          move.l    8(A0),8(A1)
00002B72  0008      
                    8215   ; p_mem_data->OSNBlks    = pmem->OSMemNBlks;
00002B74  2043      8216          move.l    D3,A0
00002B76  2242      8217          move.l    D2,A1
00002B78  2368 000C 8218          move.l    12(A0),12(A1)
00002B7C  000C      
                    8219   ; p_mem_data->OSNFree    = pmem->OSMemNFree;
00002B7E  2043      8220          move.l    D3,A0
00002B80  2242      8221          move.l    D2,A1
00002B82  2368 0010 8222          move.l    16(A0),16(A1)
00002B86  0010      
                    8223   ; OS_EXIT_CRITICAL();
00002B88  46DF      8224          dc.w      18143
                    8225   ; p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
00002B8A  2042      8226          move.l    D2,A0
00002B8C  2028 000C 8227          move.l    12(A0),D0
00002B90  2042      8228          move.l    D2,A0
00002B92  90A8 0010 8229          sub.l     16(A0),D0
00002B96  2042      8230          move.l    D2,A0
00002B98  2140 0014 8231          move.l    D0,20(A0)
                    8232   ; return (OS_ERR_NONE);
00002B9C  4200      8233          clr.b     D0
00002B9E  4CDF 000C 8234          movem.l   (A7)+,D2/D3
00002BA2  4E5E      8235          unlk      A6
00002BA4  4E75      8236          rts
                    8237   ; }
                    8238   ; #endif                                           /* OS_MEM_QUERY_EN                                    */
                    8239   ; /*$PAGE*/
                    8240   ; /*
                    8241   ; *********************************************************************************************************
                    8242   ; *                                 INITIALIZE MEMORY PARTITION MANAGER
                    8243   ; *
                    8244   ; * Description : This function is called by uC/OS-II to initialize the memory partition manager.  Your
                    8245   ; *               application MUST NOT call this function.
                    8246   ; *
                    8247   ; * Arguments   : none
                    8248   ; *
                    8249   ; * Returns     : none
                    8250   ; *
                    8251   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    8252   ; *********************************************************************************************************
                    8253   ; */
                    8254   ; void  OS_MemInit (void)
                    8255   ; {
                    8256   _OS_MemInit:
00002BA6  48E7 3020 8257          movem.l   D2/D3/A2,-(A7)
00002BAA  45F9 0800 8258          lea       _OSMemTbl.L,A2
00002BAE  0CA0      
                    8259   ; #if OS_MAX_MEM_PART == 1u
                    8260   ; OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
                    8261   ; OSMemFreeList               = (OS_MEM *)&OSMemTbl[0]; /* Point to beginning of free list           */
                    8262   ; #if OS_MEM_NAME_EN > 0u
                    8263   ; OSMemFreeList->OSMemName    = (INT8U *)"?";           /* Unknown name                              */
                    8264   ; #endif
                    8265   ; #endif
                    8266   ; #if OS_MAX_MEM_PART >= 2u
                    8267   ; OS_MEM  *pmem;
                    8268   ; INT16U   i;
                    8269   ; OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
00002BB0  4878 0078 8270          pea       120
00002BB4  2F0A      8271          move.l    A2,-(A7)
00002BB6  4EB8 158E 8272          jsr       _OS_MemClr
00002BBA  504F      8273          addq.w    #8,A7
                    8274   ; for (i = 0u; i < (OS_MAX_MEM_PART - 1u); i++) {       /* Init. list of free memory partitions      */
00002BBC  4243      8275          clr.w     D3
                    8276   OS_MemInit_1:
00002BBE  0C43 0004 8277          cmp.w     #4,D3
00002BC2  6400 003C 8278          bhs       OS_MemInit_3
                    8279   ; pmem                = &OSMemTbl[i];               /* Point to memory control block (MCB)       */
00002BC6  200A      8280          move.l    A2,D0
00002BC8  C6BC 0000 8281          and.l     #65535,D3
00002BCC  FFFF      
00002BCE  2203      8282          move.l    D3,D1
00002BD0  C3FC 0018 8283          muls      #24,D1
00002BD4  D081      8284          add.l     D1,D0
00002BD6  2400      8285          move.l    D0,D2
                    8286   ; pmem->OSMemFreeList = (void *)&OSMemTbl[i + 1u];  /* Chain list of free partitions             */
00002BD8  200A      8287          move.l    A2,D0
00002BDA  C6BC 0000 8288          and.l     #65535,D3
00002BDE  FFFF      
00002BE0  2203      8289          move.l    D3,D1
00002BE2  5281      8290          addq.l    #1,D1
00002BE4  C3FC 0018 8291          muls      #24,D1
00002BE8  D081      8292          add.l     D1,D0
00002BEA  2042      8293          move.l    D2,A0
00002BEC  2140 0004 8294          move.l    D0,4(A0)
                    8295   ; #if OS_MEM_NAME_EN > 0u
                    8296   ; pmem->OSMemName  = (INT8U *)(void *)"?";
00002BF0  41F9 0000 8297          lea       @ucos_ii_1.L,A0
00002BF4  708C      
00002BF6  2242      8298          move.l    D2,A1
00002BF8  2348 0014 8299          move.l    A0,20(A1)
00002BFC  5243      8300          addq.w    #1,D3
00002BFE  60BE      8301          bra       OS_MemInit_1
                    8302   OS_MemInit_3:
                    8303   ; #endif
                    8304   ; }
                    8305   ; pmem                = &OSMemTbl[i];
00002C00  200A      8306          move.l    A2,D0
00002C02  C6BC 0000 8307          and.l     #65535,D3
00002C06  FFFF      
00002C08  2203      8308          move.l    D3,D1
00002C0A  C3FC 0018 8309          muls      #24,D1
00002C0E  D081      8310          add.l     D1,D0
00002C10  2400      8311          move.l    D0,D2
                    8312   ; pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
00002C12  2042      8313          move.l    D2,A0
00002C14  42A8 0004 8314          clr.l     4(A0)
                    8315   ; #if OS_MEM_NAME_EN > 0u
                    8316   ; pmem->OSMemName = (INT8U *)(void *)"?";
00002C18  41F9 0000 8317          lea       @ucos_ii_1.L,A0
00002C1C  708C      
00002C1E  2242      8318          move.l    D2,A1
00002C20  2348 0014 8319          move.l    A0,20(A1)
                    8320   ; #endif
                    8321   ; OSMemFreeList   = &OSMemTbl[0];                       /* Point to beginning of free list           */
00002C24  23CA 0800 8322          move.l    A2,_OSMemFreeList.L
00002C28  0C9C      
00002C2A  4CDF 040C 8323          movem.l   (A7)+,D2/D3/A2
00002C2E  4E75      8324          rts
                    8325   ; /*
                    8326   ; *********************************************************************************************************
                    8327   ; *                                                uC/OS-II
                    8328   ; *                                          The Real-Time Kernel
                    8329   ; *                                  MUTUAL EXCLUSION SEMAPHORE MANAGEMENT
                    8330   ; *
                    8331   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    8332   ; *                                           All Rights Reserved
                    8333   ; *
                    8334   ; * File    : OS_MUTEX.C
                    8335   ; * By      : Jean J. Labrosse
                    8336   ; * Version : V2.92.07
                    8337   ; *
                    8338   ; * LICENSING TERMS:
                    8339   ; * ---------------
                    8340   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    8341   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    8342   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    8343   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    8344   ; * licensing fee.
                    8345   ; *********************************************************************************************************
                    8346   ; */
                    8347   ; #define  MICRIUM_SOURCE
                    8348   ; #ifndef  OS_MASTER_FILE
                    8349   ; #include <ucos_ii.h>
                    8350   ; #endif
                    8351   ; #if OS_MUTEX_EN > 0u
                    8352   ; /*
                    8353   ; *********************************************************************************************************
                    8354   ; *                                           LOCAL CONSTANTS
                    8355   ; *********************************************************************************************************
                    8356   ; */
                    8357   ; #define  OS_MUTEX_KEEP_LOWER_8   ((INT16U)0x00FFu)
                    8358   ; #define  OS_MUTEX_KEEP_UPPER_8   ((INT16U)0xFF00u)
                    8359   ; #define  OS_MUTEX_AVAILABLE      ((INT16U)0x00FFu)
                    8360   ; /*
                    8361   ; *********************************************************************************************************
                    8362   ; *                                           LOCAL CONSTANTS
                    8363   ; *********************************************************************************************************
                    8364   ; */
                    8365   ; static  void  OSMutex_RdyAtPrio(OS_TCB *ptcb, INT8U prio);
                    8366   ; /*$PAGE*/
                    8367   ; /*
                    8368   ; *********************************************************************************************************
                    8369   ; *                                  ACCEPT MUTUAL EXCLUSION SEMAPHORE
                    8370   ; *
                    8371   ; * Description: This  function checks the mutual exclusion semaphore to see if a resource is available.
                    8372   ; *              Unlike OSMutexPend(), OSMutexAccept() does not suspend the calling task if the resource is
                    8373   ; *              not available or the event did not occur.
                    8374   ; *
                    8375   ; * Arguments  : pevent     is a pointer to the event control block
                    8376   ; *
                    8377   ; *              perr       is a pointer to an error code which will be returned to your application:
                    8378   ; *                            OS_ERR_NONE         if the call was successful.
                    8379   ; *                            OS_ERR_EVENT_TYPE   if 'pevent' is not a pointer to a mutex
                    8380   ; *                            OS_ERR_PEVENT_NULL  'pevent' is a NULL pointer
                    8381   ; *                            OS_ERR_PEND_ISR     if you called this function from an ISR
                    8382   ; *                            OS_ERR_PCP_LOWER    If the priority of the task that owns the Mutex is
                    8383   ; *                                                HIGHER (i.e. a lower number) than the PCP.  This error
                    8384   ; *                                                indicates that you did not set the PCP higher (lower
                    8385   ; *                                                number) than ALL the tasks that compete for the Mutex.
                    8386   ; *                                                Unfortunately, this is something that could not be
                    8387   ; *                                                detected when the Mutex is created because we don't know
                    8388   ; *                                                what tasks will be using the Mutex.
                    8389   ; *
                    8390   ; * Returns    : == OS_TRUE    if the resource is available, the mutual exclusion semaphore is acquired
                    8391   ; *              == OS_FALSE   a) if the resource is not available
                    8392   ; *                            b) you didn't pass a pointer to a mutual exclusion semaphore
                    8393   ; *                            c) you called this function from an ISR
                    8394   ; *
                    8395   ; * Warning(s) : This function CANNOT be called from an ISR because mutual exclusion semaphores are
                    8396   ; *              intended to be used by tasks only.
                    8397   ; *********************************************************************************************************
                    8398   ; */
                    8399   ; #if OS_MUTEX_ACCEPT_EN > 0u
                    8400   ; BOOLEAN  OSMutexAccept (OS_EVENT  *pevent,
                    8401   ; INT8U     *perr)
                    8402   ; {
                    8403   _OSMutexAccept:
00002C30  4E56 0000 8404          link      A6,#0
00002C34  48E7 3820 8405          movem.l   D2/D3/D4/A2,-(A7)
00002C38  242E 0008 8406          move.l    8(A6),D2
00002C3C  262E 000C 8407          move.l    12(A6),D3
00002C40  45F9 0800 8408          lea       _OSTCBCur.L,A2
00002C44  0428      
                    8409   ; INT8U      pcp;                                    /* Priority Ceiling Priority (PCP)              */
                    8410   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    8411   ; OS_CPU_SR  cpu_sr = 0u;
                    8412   ; #endif
                    8413   ; #ifdef OS_SAFETY_CRITICAL
                    8414   ; if (perr == (INT8U *)0) {
                    8415   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8416   ; return (OS_FALSE);
                    8417   ; }
                    8418   ; #endif
                    8419   ; #if OS_ARG_CHK_EN > 0u
                    8420   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    8421   ; *perr = OS_ERR_PEVENT_NULL;
                    8422   ; return (OS_FALSE);
                    8423   ; }
                    8424   ; #endif
                    8425   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
00002C46  2042      8426          move.l    D2,A0
00002C48  1010      8427          move.b    (A0),D0
00002C4A  0C00 0004 8428          cmp.b     #4,D0
00002C4E  670C      8429          beq.s     OSMutexAccept_1
                    8430   ; *perr = OS_ERR_EVENT_TYPE;
00002C50  2043      8431          move.l    D3,A0
00002C52  10BC 0001 8432          move.b    #1,(A0)
                    8433   ; return (OS_FALSE);
00002C56  4200      8434          clr.b     D0
00002C58  6000 0084 8435          bra       OSMutexAccept_3
                    8436   OSMutexAccept_1:
                    8437   ; }
                    8438   ; if (OSIntNesting > 0u) {                           /* Make sure it's not called from an ISR        */
00002C5C  1039 0800 8439          move.b    _OSIntNesting.L,D0
00002C60  030E      
00002C62  0C00 0000 8440          cmp.b     #0,D0
00002C66  630C      8441          bls.s     OSMutexAccept_4
                    8442   ; *perr = OS_ERR_PEND_ISR;
00002C68  2043      8443          move.l    D3,A0
00002C6A  10BC 0002 8444          move.b    #2,(A0)
                    8445   ; return (OS_FALSE);
00002C6E  4200      8446          clr.b     D0
00002C70  6000 006C 8447          bra       OSMutexAccept_3
                    8448   OSMutexAccept_4:
                    8449   ; }
                    8450   ; OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
00002C74  40E7      8451          dc.w      16615
00002C76  007C      8452          dc.w      124
00002C78  0700      8453          dc.w      1792
                    8454   ; pcp = (INT8U)(pevent->OSEventCnt >> 8u);           /* Get PCP from mutex                           */
00002C7A  2042      8455          move.l    D2,A0
00002C7C  3028 0006 8456          move.w    6(A0),D0
00002C80  E048      8457          lsr.w     #8,D0
00002C82  1800      8458          move.b    D0,D4
                    8459   ; if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
00002C84  2042      8460          move.l    D2,A0
00002C86  3028 0006 8461          move.w    6(A0),D0
00002C8A  C07C 00FF 8462          and.w     #255,D0
00002C8E  0C40 00FF 8463          cmp.w     #255,D0
00002C92  6600 0042 8464          bne       OSMutexAccept_6
                    8465   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
00002C96  2042      8466          move.l    D2,A0
00002C98  0268 FF00 8467          and.w     #65280,6(A0)
00002C9C  0006      
                    8468   ; pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
00002C9E  2042      8469          move.l    D2,A0
00002CA0  2252      8470          move.l    (A2),A1
00002CA2  1029 0034 8471          move.b    52(A1),D0
00002CA6  C07C 00FF 8472          and.w     #255,D0
00002CAA  8168 0006 8473          or.w      D0,6(A0)
                    8474   ; pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
00002CAE  2042      8475          move.l    D2,A0
00002CB0  2152 0002 8476          move.l    (A2),2(A0)
                    8477   ; if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
00002CB4  0C04 00FF 8478          cmp.b     #255,D4
00002CB8  6712      8479          beq.s     OSMutexAccept_8
00002CBA  2052      8480          move.l    (A2),A0
00002CBC  B828 0034 8481          cmp.b     52(A0),D4
00002CC0  650A      8482          blo.s     OSMutexAccept_8
                    8483   ; (OSTCBCur->OSTCBPrio <= pcp)) {            /*      PCP 'must' have a SMALLER prio ...      */
                    8484   ; OS_EXIT_CRITICAL();                       /*      ... than current task!                  */
00002CC2  46DF      8485          dc.w      18143
                    8486   ; *perr = OS_ERR_PCP_LOWER;
00002CC4  2043      8487          move.l    D3,A0
00002CC6  10BC 0078 8488          move.b    #120,(A0)
00002CCA  6006      8489          bra.s     OSMutexAccept_9
                    8490   OSMutexAccept_8:
                    8491   ; } else {
                    8492   ; OS_EXIT_CRITICAL();
00002CCC  46DF      8493          dc.w      18143
                    8494   ; *perr = OS_ERR_NONE;
00002CCE  2043      8495          move.l    D3,A0
00002CD0  4210      8496          clr.b     (A0)
                    8497   OSMutexAccept_9:
                    8498   ; }
                    8499   ; return (OS_TRUE);
00002CD2  7001      8500          moveq     #1,D0
00002CD4  6008      8501          bra.s     OSMutexAccept_3
                    8502   OSMutexAccept_6:
                    8503   ; }
                    8504   ; OS_EXIT_CRITICAL();
00002CD6  46DF      8505          dc.w      18143
                    8506   ; *perr = OS_ERR_NONE;
00002CD8  2043      8507          move.l    D3,A0
00002CDA  4210      8508          clr.b     (A0)
                    8509   ; return (OS_FALSE);
00002CDC  4200      8510          clr.b     D0
                    8511   OSMutexAccept_3:
00002CDE  4CDF 041C 8512          movem.l   (A7)+,D2/D3/D4/A2
00002CE2  4E5E      8513          unlk      A6
00002CE4  4E75      8514          rts
                    8515   ; }
                    8516   ; #endif
                    8517   ; /*$PAGE*/
                    8518   ; /*
                    8519   ; *********************************************************************************************************
                    8520   ; *                                 CREATE A MUTUAL EXCLUSION SEMAPHORE
                    8521   ; *
                    8522   ; * Description: This function creates a mutual exclusion semaphore.
                    8523   ; *
                    8524   ; * Arguments  : prio          is the priority to use when accessing the mutual exclusion semaphore.  In
                    8525   ; *                            other words, when the semaphore is acquired and a higher priority task
                    8526   ; *                            attempts to obtain the semaphore then the priority of the task owning the
                    8527   ; *                            semaphore is raised to this priority.  It is assumed that you will specify
                    8528   ; *                            a priority that is LOWER in value than ANY of the tasks competing for the
                    8529   ; *                            mutex. If the priority is specified as OS_PRIO_MUTEX_CEIL_DIS, then the
                    8530   ; *                            priority ceiling promotion is disabled. This way, the tasks accessing the
                    8531   ; *                            semaphore do not have their priority promoted.
                    8532   ; *
                    8533   ; *              perr          is a pointer to an error code which will be returned to your application:
                    8534   ; *                               OS_ERR_NONE         if the call was successful.
                    8535   ; *                               OS_ERR_CREATE_ISR   if you attempted to create a MUTEX from an ISR
                    8536   ; *                               OS_ERR_PRIO_EXIST   if a task at the priority ceiling priority
                    8537   ; *                                                   already exist.
                    8538   ; *                               OS_ERR_PEVENT_NULL  No more event control blocks available.
                    8539   ; *                               OS_ERR_PRIO_INVALID if the priority you specify is higher that the
                    8540   ; *                                                   maximum allowed (i.e. > OS_LOWEST_PRIO)
                    8541   ; *
                    8542   ; * Returns    : != (void *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    8543   ; *                            created mutex.
                    8544   ; *              == (void *)0  if an error is detected.
                    8545   ; *
                    8546   ; * Note(s)    : 1) The LEAST significant 8 bits of '.OSEventCnt' hold the priority number of the task
                    8547   ; *                 owning the mutex or 0xFF if no task owns the mutex.
                    8548   ; *
                    8549   ; *              2) The MOST  significant 8 bits of '.OSEventCnt' hold the priority number used to
                    8550   ; *                 reduce priority inversion or 0xFF (OS_PRIO_MUTEX_CEIL_DIS) if priority ceiling
                    8551   ; *                 promotion is disabled.
                    8552   ; *********************************************************************************************************
                    8553   ; */
                    8554   ; OS_EVENT  *OSMutexCreate (INT8U   prio,
                    8555   ; INT8U  *perr)
                    8556   ; {
                    8557   _OSMutexCreate:
00002CE6  4E56 0000 8558          link      A6,#0
00002CEA  48E7 3830 8559          movem.l   D2/D3/D4/A2/A3,-(A7)
00002CEE  162E 000B 8560          move.b    11(A6),D3
00002CF2  C6BC 0000 8561          and.l     #255,D3
00002CF6  00FF      
00002CF8  282E 000C 8562          move.l    12(A6),D4
00002CFC  45F9 0800 8563          lea       _OSEventFreeList.L,A2
00002D00  00E2      
00002D02  47F9 0800 8564          lea       _OSTCBPrioTbl.L,A3
00002D06  0438      
                    8565   ; OS_EVENT  *pevent;
                    8566   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    8567   ; OS_CPU_SR  cpu_sr = 0u;
                    8568   ; #endif
                    8569   ; #ifdef OS_SAFETY_CRITICAL
                    8570   ; if (perr == (INT8U *)0) {
                    8571   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8572   ; return ((OS_EVENT *)0);
                    8573   ; }
                    8574   ; #endif
                    8575   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    8576   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    8577   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8578   ; return ((OS_EVENT *)0);
                    8579   ; }
                    8580   ; #endif
                    8581   ; #if OS_ARG_CHK_EN > 0u
                    8582   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
                    8583   ; if (prio >= OS_LOWEST_PRIO) {                      /* Validate PCP                             */
                    8584   ; *perr = OS_ERR_PRIO_INVALID;
                    8585   ; return ((OS_EVENT *)0);
                    8586   ; }
                    8587   ; }
                    8588   ; #endif
                    8589   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00002D08  1039 0800 8590          move.b    _OSIntNesting.L,D0
00002D0C  030E      
00002D0E  0C00 0000 8591          cmp.b     #0,D0
00002D12  630C      8592          bls.s     OSMutexCreate_1
                    8593   ; *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
00002D14  2044      8594          move.l    D4,A0
00002D16  10BC 0010 8595          move.b    #16,(A0)
                    8596   ; return ((OS_EVENT *)0);
00002D1A  4280      8597          clr.l     D0
00002D1C  6000 00A6 8598          bra       OSMutexCreate_3
                    8599   OSMutexCreate_1:
                    8600   ; }
                    8601   ; OS_ENTER_CRITICAL();
00002D20  40E7      8602          dc.w      16615
00002D22  007C      8603          dc.w      124
00002D24  0700      8604          dc.w      1792
                    8605   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
00002D26  0C03 00FF 8606          cmp.b     #255,D3
00002D2A  6730      8607          beq.s     OSMutexCreate_4
                    8608   ; if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {           /* Mutex priority must not already exist    */
00002D2C  C6BC 0000 8609          and.l     #255,D3
00002D30  00FF      
00002D32  2003      8610          move.l    D3,D0
00002D34  E588      8611          lsl.l     #2,D0
00002D36  2033 0800 8612          move.l    0(A3,D0.L),D0
00002D3A  670E      8613          beq.s     OSMutexCreate_6
                    8614   ; OS_EXIT_CRITICAL();                            /* Task already exist at priority ...       */
00002D3C  46DF      8615          dc.w      18143
                    8616   ; *perr = OS_ERR_PRIO_EXIST;                      /* ... ceiling priority                     */
00002D3E  2044      8617          move.l    D4,A0
00002D40  10BC 0028 8618          move.b    #40,(A0)
                    8619   ; return ((OS_EVENT *)0);
00002D44  4280      8620          clr.l     D0
00002D46  6000 007C 8621          bra       OSMutexCreate_3
                    8622   OSMutexCreate_6:
                    8623   ; }
                    8624   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;              /* Reserve the table entry                  */
00002D4A  C6BC 0000 8625          and.l     #255,D3
00002D4E  00FF      
00002D50  2003      8626          move.l    D3,D0
00002D52  E588      8627          lsl.l     #2,D0
00002D54  27BC 0000 8628          move.l    #1,0(A3,D0.L)
00002D58  0001 0800 
                    8629   OSMutexCreate_4:
                    8630   ; }
                    8631   ; pevent = OSEventFreeList;                              /* Get next free event control block        */
00002D5C  2412      8632          move.l    (A2),D2
                    8633   ; if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
00002D5E  4A82      8634          tst.l     D2
00002D60  6622      8635          bne.s     OSMutexCreate_8
                    8636   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
00002D62  0C03 00FF 8637          cmp.b     #255,D3
00002D66  670E      8638          beq.s     OSMutexCreate_10
                    8639   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;              /* No, Release the table entry              */
00002D68  C6BC 0000 8640          and.l     #255,D3
00002D6C  00FF      
00002D6E  2003      8641          move.l    D3,D0
00002D70  E588      8642          lsl.l     #2,D0
00002D72  42B3 0800 8643          clr.l     0(A3,D0.L)
                    8644   OSMutexCreate_10:
                    8645   ; }
                    8646   ; OS_EXIT_CRITICAL();
00002D76  46DF      8647          dc.w      18143
                    8648   ; *perr = OS_ERR_PEVENT_NULL;                         /* No more event control blocks             */
00002D78  2044      8649          move.l    D4,A0
00002D7A  10BC 0004 8650          move.b    #4,(A0)
                    8651   ; return (pevent);
00002D7E  2002      8652          move.l    D2,D0
00002D80  6000 0042 8653          bra       OSMutexCreate_3
                    8654   OSMutexCreate_8:
                    8655   ; }
                    8656   ; OSEventFreeList     = (OS_EVENT *)OSEventFreeList->OSEventPtr; /* Adjust the free list             */
00002D84  2052      8657          move.l    (A2),A0
00002D86  24A8 0002 8658          move.l    2(A0),(A2)
                    8659   ; OS_EXIT_CRITICAL();
00002D8A  46DF      8660          dc.w      18143
                    8661   ; pevent->OSEventType = OS_EVENT_TYPE_MUTEX;
00002D8C  2042      8662          move.l    D2,A0
00002D8E  10BC 0004 8663          move.b    #4,(A0)
                    8664   ; pevent->OSEventCnt  = (INT16U)((INT16U)prio << 8u) | OS_MUTEX_AVAILABLE; /* Resource is avail.     */
00002D92  1003      8665          move.b    D3,D0
00002D94  C07C 00FF 8666          and.w     #255,D0
00002D98  E148      8667          lsl.w     #8,D0
00002D9A  807C 00FF 8668          or.w      #255,D0
00002D9E  2042      8669          move.l    D2,A0
00002DA0  3140 0006 8670          move.w    D0,6(A0)
                    8671   ; pevent->OSEventPtr  = (void *)0;                       /* No task owning the mutex                 */
00002DA4  2042      8672          move.l    D2,A0
00002DA6  42A8 0002 8673          clr.l     2(A0)
                    8674   ; #if OS_EVENT_NAME_EN > 0u
                    8675   ; pevent->OSEventName = (INT8U *)(void *)"?";
00002DAA  41F9 0000 8676          lea       @ucos_ii_1.L,A0
00002DAE  708C      
00002DB0  2242      8677          move.l    D2,A1
00002DB2  2348 0012 8678          move.l    A0,18(A1)
                    8679   ; #endif
                    8680   ; OS_EventWaitListInit(pevent);
00002DB6  2F02      8681          move.l    D2,-(A7)
00002DB8  4EB8 12C2 8682          jsr       _OS_EventWaitListInit
00002DBC  584F      8683          addq.w    #4,A7
                    8684   ; *perr = OS_ERR_NONE;
00002DBE  2044      8685          move.l    D4,A0
00002DC0  4210      8686          clr.b     (A0)
                    8687   ; return (pevent);
00002DC2  2002      8688          move.l    D2,D0
                    8689   OSMutexCreate_3:
00002DC4  4CDF 0C1C 8690          movem.l   (A7)+,D2/D3/D4/A2/A3
00002DC8  4E5E      8691          unlk      A6
00002DCA  4E75      8692          rts
                    8693   ; }
                    8694   ; /*$PAGE*/
                    8695   ; /*
                    8696   ; *********************************************************************************************************
                    8697   ; *                                           DELETE A MUTEX
                    8698   ; *
                    8699   ; * Description: This function deletes a mutual exclusion semaphore and readies all tasks pending on the it.
                    8700   ; *
                    8701   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mutex.
                    8702   ; *
                    8703   ; *              opt           determines delete options as follows:
                    8704   ; *                            opt == OS_DEL_NO_PEND   Delete mutex ONLY if no task pending
                    8705   ; *                            opt == OS_DEL_ALWAYS    Deletes the mutex even if tasks are waiting.
                    8706   ; *                                                    In this case, all the tasks pending will be readied.
                    8707   ; *
                    8708   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    8709   ; *                            OS_ERR_NONE             The call was successful and the mutex was deleted
                    8710   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the MUTEX from an ISR
                    8711   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    8712   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mutex
                    8713   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
                    8714   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    8715   ; *
                    8716   ; * Returns    : pevent        upon error
                    8717   ; *              (OS_EVENT *)0 if the mutex was successfully deleted.
                    8718   ; *
                    8719   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    8720   ; *                 the mutex MUST check the return code of OSMutexPend().
                    8721   ; *
                    8722   ; *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
                    8723   ; *                 time is directly proportional to the number of tasks waiting on the mutex.
                    8724   ; *
                    8725   ; *              3) Because ALL tasks pending on the mutex will be readied, you MUST be careful because the
                    8726   ; *                 resource(s) will no longer be guarded by the mutex.
                    8727   ; *
                    8728   ; *              4) IMPORTANT: In the 'OS_DEL_ALWAYS' case, we assume that the owner of the Mutex (if there
                    8729   ; *                            is one) is ready-to-run and is thus NOT pending on another kernel object or
                    8730   ; *                            has delayed itself.  In other words, if a task owns the mutex being deleted,
                    8731   ; *                            that task will be made ready-to-run at its original priority.
                    8732   ; *********************************************************************************************************
                    8733   ; */
                    8734   ; #if OS_MUTEX_DEL_EN > 0u
                    8735   ; OS_EVENT  *OSMutexDel (OS_EVENT  *pevent,
                    8736   ; INT8U      opt,
                    8737   ; INT8U     *perr)
                    8738   ; {
                    8739   _OSMutexDel:
00002DCC  4E56 FFFC 8740          link      A6,#-4
00002DD0  48E7 3F20 8741          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
00002DD4  242E 0008 8742          move.l    8(A6),D2
00002DD8  282E 0010 8743          move.l    16(A6),D4
00002DDC  45F9 0800 8744          lea       _OSEventFreeList.L,A2
00002DE0  00E2      
                    8745   ; BOOLEAN    tasks_waiting;
                    8746   ; OS_EVENT  *pevent_return;
                    8747   ; INT8U      pcp;                                        /* Priority ceiling priority                */
                    8748   ; INT8U      prio;
                    8749   ; OS_TCB    *ptcb;
                    8750   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    8751   ; OS_CPU_SR  cpu_sr = 0u;
                    8752   ; #endif
                    8753   ; #ifdef OS_SAFETY_CRITICAL
                    8754   ; if (perr == (INT8U *)0) {
                    8755   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8756   ; return ((OS_EVENT *)0);
                    8757   ; }
                    8758   ; #endif
                    8759   ; #if OS_ARG_CHK_EN > 0u
                    8760   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    8761   ; *perr = OS_ERR_PEVENT_NULL;
                    8762   ; return (pevent);
                    8763   ; }
                    8764   ; #endif
                    8765   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
00002DE2  2042      8766          move.l    D2,A0
00002DE4  1010      8767          move.b    (A0),D0
00002DE6  0C00 0004 8768          cmp.b     #4,D0
00002DEA  670C      8769          beq.s     OSMutexDel_1
                    8770   ; *perr = OS_ERR_EVENT_TYPE;
00002DEC  2044      8771          move.l    D4,A0
00002DEE  10BC 0001 8772          move.b    #1,(A0)
                    8773   ; return (pevent);
00002DF2  2002      8774          move.l    D2,D0
00002DF4  6000 017C 8775          bra       OSMutexDel_3
                    8776   OSMutexDel_1:
                    8777   ; }
                    8778   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00002DF8  1039 0800 8779          move.b    _OSIntNesting.L,D0
00002DFC  030E      
00002DFE  0C00 0000 8780          cmp.b     #0,D0
00002E02  630C      8781          bls.s     OSMutexDel_4
                    8782   ; *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
00002E04  2044      8783          move.l    D4,A0
00002E06  10BC 000F 8784          move.b    #15,(A0)
                    8785   ; return (pevent);
00002E0A  2002      8786          move.l    D2,D0
00002E0C  6000 0164 8787          bra       OSMutexDel_3
                    8788   OSMutexDel_4:
                    8789   ; }
                    8790   ; OS_ENTER_CRITICAL();
00002E10  40E7      8791          dc.w      16615
00002E12  007C      8792          dc.w      124
00002E14  0700      8793          dc.w      1792
                    8794   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mutex        */
00002E16  2042      8795          move.l    D2,A0
00002E18  1028 0008 8796          move.b    8(A0),D0
00002E1C  6704      8797          beq.s     OSMutexDel_6
                    8798   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
00002E1E  7E01      8799          moveq     #1,D7
00002E20  6002      8800          bra.s     OSMutexDel_7
                    8801   OSMutexDel_6:
                    8802   ; } else {
                    8803   ; tasks_waiting = OS_FALSE;                          /* No                                       */
00002E22  7E00      8804          moveq     #0,D7
                    8805   OSMutexDel_7:
                    8806   ; }
                    8807   ; switch (opt) {
00002E24  102E 000F 8808          move.b    15(A6),D0
00002E28  C0BC 0000 8809          and.l     #255,D0
00002E2C  00FF      
00002E2E  0C80 0000 8810          cmp.l     #1,D0
00002E32  0001      
00002E34  6700 006E 8811          beq       OSMutexDel_11
00002E38  6200 012C 8812          bhi       OSMutexDel_8
00002E3C  4A80      8813          tst.l     D0
00002E3E  6704      8814          beq.s     OSMutexDel_10
00002E40  6000 0124 8815          bra       OSMutexDel_8
                    8816   OSMutexDel_10:
                    8817   ; case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
                    8818   ; if (tasks_waiting == OS_FALSE) {
00002E44  4A07      8819          tst.b     D7
00002E46  6600 004E 8820          bne       OSMutexDel_13
                    8821   ; #if OS_EVENT_NAME_EN > 0u
                    8822   ; pevent->OSEventName   = (INT8U *)(void *)"?";
00002E4A  41F9 0000 8823          lea       @ucos_ii_1.L,A0
00002E4E  708C      
00002E50  2242      8824          move.l    D2,A1
00002E52  2348 0012 8825          move.l    A0,18(A1)
                    8826   ; #endif
                    8827   ; pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
00002E56  2042      8828          move.l    D2,A0
00002E58  3028 0006 8829          move.w    6(A0),D0
00002E5C  E048      8830          lsr.w     #8,D0
00002E5E  1600      8831          move.b    D0,D3
                    8832   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
00002E60  0C03 00FF 8833          cmp.b     #255,D3
00002E64  6714      8834          beq.s     OSMutexDel_15
                    8835   ; OSTCBPrioTbl[pcp] = (OS_TCB *)0;      /* Free up the PCP                          */
00002E66  C6BC 0000 8836          and.l     #255,D3
00002E6A  00FF      
00002E6C  2003      8837          move.l    D3,D0
00002E6E  E588      8838          lsl.l     #2,D0
00002E70  41F9 0800 8839          lea       _OSTCBPrioTbl.L,A0
00002E74  0438      
00002E76  42B0 0800 8840          clr.l     0(A0,D0.L)
                    8841   OSMutexDel_15:
                    8842   ; }
                    8843   ; pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
00002E7A  2042      8844          move.l    D2,A0
00002E7C  4210      8845          clr.b     (A0)
                    8846   ; pevent->OSEventPtr    = OSEventFreeList;  /* Return Event Control Block to free list  */
00002E7E  2042      8847          move.l    D2,A0
00002E80  2152 0002 8848          move.l    (A2),2(A0)
                    8849   ; pevent->OSEventCnt    = 0u;
00002E84  2042      8850          move.l    D2,A0
00002E86  4268 0006 8851          clr.w     6(A0)
                    8852   ; OSEventFreeList       = pevent;
00002E8A  2482      8853          move.l    D2,(A2)
                    8854   ; OS_EXIT_CRITICAL();
00002E8C  46DF      8855          dc.w      18143
                    8856   ; *perr                 = OS_ERR_NONE;
00002E8E  2044      8857          move.l    D4,A0
00002E90  4210      8858          clr.b     (A0)
                    8859   ; pevent_return         = (OS_EVENT *)0;    /* Mutex has been deleted                   */
00002E92  4285      8860          clr.l     D5
00002E94  600A      8861          bra.s     OSMutexDel_14
                    8862   OSMutexDel_13:
                    8863   ; } else {
                    8864   ; OS_EXIT_CRITICAL();
00002E96  46DF      8865          dc.w      18143
                    8866   ; *perr                 = OS_ERR_TASK_WAITING;
00002E98  2044      8867          move.l    D4,A0
00002E9A  10BC 0049 8868          move.b    #73,(A0)
                    8869   ; pevent_return         = pevent;
00002E9E  2A02      8870          move.l    D2,D5
                    8871   OSMutexDel_14:
                    8872   ; }
                    8873   ; break;
00002EA0  6000 00CE 8874          bra       OSMutexDel_9
                    8875   OSMutexDel_11:
                    8876   ; case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
                    8877   ; pcp  = (INT8U)(pevent->OSEventCnt >> 8u);                       /* Get PCP of mutex       */
00002EA4  2042      8878          move.l    D2,A0
00002EA6  3028 0006 8879          move.w    6(A0),D0
00002EAA  E048      8880          lsr.w     #8,D0
00002EAC  1600      8881          move.b    D0,D3
                    8882   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
00002EAE  0C03 00FF 8883          cmp.b     #255,D3
00002EB2  6700 0038 8884          beq       OSMutexDel_21
                    8885   ; prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /* Get owner's orig prio  */
00002EB6  2042      8886          move.l    D2,A0
00002EB8  3028 0006 8887          move.w    6(A0),D0
00002EBC  C07C 00FF 8888          and.w     #255,D0
00002EC0  1D40 FFFF 8889          move.b    D0,-1(A6)
                    8890   ; ptcb = (OS_TCB *)pevent->OSEventPtr;
00002EC4  2042      8891          move.l    D2,A0
00002EC6  2C28 0002 8892          move.l    2(A0),D6
                    8893   ; if (ptcb != (OS_TCB *)0) {                /* See if any task owns the mutex           */
00002ECA  4A86      8894          tst.l     D6
00002ECC  671E      8895          beq.s     OSMutexDel_21
                    8896   ; if (ptcb->OSTCBPrio == pcp) {         /* See if original prio was changed         */
00002ECE  2046      8897          move.l    D6,A0
00002ED0  B628 0034 8898          cmp.b     52(A0),D3
00002ED4  6616      8899          bne.s     OSMutexDel_21
                    8900   ; OSMutex_RdyAtPrio(ptcb, prio);    /* Yes, Restore the task's original prio    */
00002ED6  122E FFFF 8901          move.b    -1(A6),D1
00002EDA  C2BC 0000 8902          and.l     #255,D1
00002EDE  00FF      
00002EE0  2F01      8903          move.l    D1,-(A7)
00002EE2  2F06      8904          move.l    D6,-(A7)
00002EE4  4EB9 0000 8905          jsr       @ucos_ii_OSMutex_RdyAtPrio
00002EE8  3428      
00002EEA  504F      8906          addq.w    #8,A7
                    8907   OSMutexDel_21:
                    8908   ; }
                    8909   ; }
                    8910   ; }
                    8911   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mutex        */
                    8912   OSMutexDel_23:
00002EEC  2042      8913          move.l    D2,A0
00002EEE  1028 0008 8914          move.b    8(A0),D0
00002EF2  671C      8915          beq.s     OSMutexDel_25
                    8916   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_ABORT);
00002EF4  4878 0002 8917          pea       2
00002EF8  4878 0010 8918          pea       16
00002EFC  42A7      8919          clr.l     -(A7)
00002EFE  2F02      8920          move.l    D2,-(A7)
00002F00  4EB8 0FFA 8921          jsr       _OS_EventTaskRdy
00002F04  DEFC 0010 8922          add.w     #16,A7
00002F08  C0BC 0000 8923          and.l     #255,D0
00002F0C  00FF      
00002F0E  60DC      8924          bra       OSMutexDel_23
                    8925   OSMutexDel_25:
                    8926   ; }
                    8927   ; #if OS_EVENT_NAME_EN > 0u
                    8928   ; pevent->OSEventName   = (INT8U *)(void *)"?";
00002F10  41F9 0000 8929          lea       @ucos_ii_1.L,A0
00002F14  708C      
00002F16  2242      8930          move.l    D2,A1
00002F18  2348 0012 8931          move.l    A0,18(A1)
                    8932   ; #endif
                    8933   ; pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
00002F1C  2042      8934          move.l    D2,A0
00002F1E  3028 0006 8935          move.w    6(A0),D0
00002F22  E048      8936          lsr.w     #8,D0
00002F24  1600      8937          move.b    D0,D3
                    8938   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
00002F26  0C03 00FF 8939          cmp.b     #255,D3
00002F2A  6714      8940          beq.s     OSMutexDel_26
                    8941   ; OSTCBPrioTbl[pcp] = (OS_TCB *)0;          /* Free up the PCP                          */
00002F2C  C6BC 0000 8942          and.l     #255,D3
00002F30  00FF      
00002F32  2003      8943          move.l    D3,D0
00002F34  E588      8944          lsl.l     #2,D0
00002F36  41F9 0800 8945          lea       _OSTCBPrioTbl.L,A0
00002F3A  0438      
00002F3C  42B0 0800 8946          clr.l     0(A0,D0.L)
                    8947   OSMutexDel_26:
                    8948   ; }
                    8949   ; pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
00002F40  2042      8950          move.l    D2,A0
00002F42  4210      8951          clr.b     (A0)
                    8952   ; pevent->OSEventPtr    = OSEventFreeList;      /* Return Event Control Block to free list  */
00002F44  2042      8953          move.l    D2,A0
00002F46  2152 0002 8954          move.l    (A2),2(A0)
                    8955   ; pevent->OSEventCnt    = 0u;
00002F4A  2042      8956          move.l    D2,A0
00002F4C  4268 0006 8957          clr.w     6(A0)
                    8958   ; OSEventFreeList       = pevent;               /* Get next free event control block        */
00002F50  2482      8959          move.l    D2,(A2)
                    8960   ; OS_EXIT_CRITICAL();
00002F52  46DF      8961          dc.w      18143
                    8962   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00002F54  0C07 0001 8963          cmp.b     #1,D7
00002F58  6604      8964          bne.s     OSMutexDel_28
                    8965   ; OS_Sched();                               /* Find highest priority task ready to run  */
00002F5A  4EB8 15DA 8966          jsr       _OS_Sched
                    8967   OSMutexDel_28:
                    8968   ; }
                    8969   ; *perr         = OS_ERR_NONE;
00002F5E  2044      8970          move.l    D4,A0
00002F60  4210      8971          clr.b     (A0)
                    8972   ; pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
00002F62  4285      8973          clr.l     D5
                    8974   ; break;
00002F64  600A      8975          bra.s     OSMutexDel_9
                    8976   OSMutexDel_8:
                    8977   ; default:
                    8978   ; OS_EXIT_CRITICAL();
00002F66  46DF      8979          dc.w      18143
                    8980   ; *perr         = OS_ERR_INVALID_OPT;
00002F68  2044      8981          move.l    D4,A0
00002F6A  10BC 0007 8982          move.b    #7,(A0)
                    8983   ; pevent_return = pevent;
00002F6E  2A02      8984          move.l    D2,D5
                    8985   ; break;
                    8986   OSMutexDel_9:
                    8987   ; }
                    8988   ; return (pevent_return);
00002F70  2005      8989          move.l    D5,D0
                    8990   OSMutexDel_3:
00002F72  4CDF 04FC 8991          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
00002F76  4E5E      8992          unlk      A6
00002F78  4E75      8993          rts
                    8994   ; }
                    8995   ; #endif
                    8996   ; /*$PAGE*/
                    8997   ; /*
                    8998   ; *********************************************************************************************************
                    8999   ; *                                 PEND ON MUTUAL EXCLUSION SEMAPHORE
                    9000   ; *
                    9001   ; * Description: This function waits for a mutual exclusion semaphore.
                    9002   ; *
                    9003   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    9004   ; *                            mutex.
                    9005   ; *
                    9006   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    9007   ; *                            wait for the resource up to the amount of time specified by this argument.
                    9008   ; *                            If you specify 0, however, your task will wait forever at the specified
                    9009   ; *                            mutex or, until the resource becomes available.
                    9010   ; *
                    9011   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    9012   ; *                            messages are:
                    9013   ; *                               OS_ERR_NONE        The call was successful and your task owns the mutex
                    9014   ; *                               OS_ERR_TIMEOUT     The mutex was not available within the specified 'timeout'.
                    9015   ; *                               OS_ERR_PEND_ABORT  The wait on the mutex was aborted.
                    9016   ; *                               OS_ERR_EVENT_TYPE  If you didn't pass a pointer to a mutex
                    9017   ; *                               OS_ERR_PEVENT_NULL 'pevent' is a NULL pointer
                    9018   ; *                               OS_ERR_PEND_ISR    If you called this function from an ISR and the result
                    9019   ; *                                                  would lead to a suspension.
                    9020   ; *                               OS_ERR_PCP_LOWER   If the priority of the task that owns the Mutex is
                    9021   ; *                                                  HIGHER (i.e. a lower number) than the PCP.  This error
                    9022   ; *                                                  indicates that you did not set the PCP higher (lower
                    9023   ; *                                                  number) than ALL the tasks that compete for the Mutex.
                    9024   ; *                                                  Unfortunately, this is something that could not be
                    9025   ; *                                                  detected when the Mutex is created because we don't know
                    9026   ; *                                                  what tasks will be using the Mutex.
                    9027   ; *                               OS_ERR_PEND_LOCKED If you called this function when the scheduler is locked
                    9028   ; *
                    9029   ; * Returns    : none
                    9030   ; *
                    9031   ; * Note(s)    : 1) The task that owns the Mutex MUST NOT pend on any other event while it owns the mutex.
                    9032   ; *
                    9033   ; *              2) You MUST NOT change the priority of the task that owns the mutex
                    9034   ; *********************************************************************************************************
                    9035   ; */
                    9036   ; void  OSMutexPend (OS_EVENT  *pevent,
                    9037   ; INT32U     timeout,
                    9038   ; INT8U     *perr)
                    9039   ; {
                    9040   _OSMutexPend:
00002F7A  4E56 FFFC 9041          link      A6,#-4
00002F7E  48E7 3F30 9042          movem.l   D2/D3/D4/D5/D6/D7/A2/A3,-(A7)
00002F82  45F9 0800 9043          lea       _OSTCBCur.L,A2
00002F86  0428      
00002F88  262E 0008 9044          move.l    8(A6),D3
00002F8C  2A2E 0010 9045          move.l    16(A6),D5
00002F90  47F9 0800 9046          lea       _OSRdyTbl.L,A3
00002F94  0318      
                    9047   ; INT8U      pcp;                                        /* Priority Ceiling Priority (PCP)          */
                    9048   ; INT8U      mprio;                                      /* Mutex owner priority                     */
                    9049   ; BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
                    9050   ; OS_TCB    *ptcb;
                    9051   ; OS_EVENT  *pevent2;
                    9052   ; INT8U      y;
                    9053   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    9054   ; OS_CPU_SR  cpu_sr = 0u;
                    9055   ; #endif
                    9056   ; #ifdef OS_SAFETY_CRITICAL
                    9057   ; if (perr == (INT8U *)0) {
                    9058   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    9059   ; return;
                    9060   ; }
                    9061   ; #endif
                    9062   ; #if OS_ARG_CHK_EN > 0u
                    9063   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    9064   ; *perr = OS_ERR_PEVENT_NULL;
                    9065   ; return;
                    9066   ; }
                    9067   ; #endif
                    9068   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
00002F96  2043      9069          move.l    D3,A0
00002F98  1010      9070          move.b    (A0),D0
00002F9A  0C00 0004 9071          cmp.b     #4,D0
00002F9E  670A      9072          beq.s     OSMutexPend_1
                    9073   ; *perr = OS_ERR_EVENT_TYPE;
00002FA0  2045      9074          move.l    D5,A0
00002FA2  10BC 0001 9075          move.b    #1,(A0)
                    9076   ; return;
00002FA6  6000 02AC 9077          bra       OSMutexPend_3
                    9078   OSMutexPend_1:
                    9079   ; }
                    9080   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00002FAA  1039 0800 9081          move.b    _OSIntNesting.L,D0
00002FAE  030E      
00002FB0  0C00 0000 9082          cmp.b     #0,D0
00002FB4  630A      9083          bls.s     OSMutexPend_4
                    9084   ; *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
00002FB6  2045      9085          move.l    D5,A0
00002FB8  10BC 0002 9086          move.b    #2,(A0)
                    9087   ; return;
00002FBC  6000 0296 9088          bra       OSMutexPend_3
                    9089   OSMutexPend_4:
                    9090   ; }
                    9091   ; if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
00002FC0  1039 0800 9092          move.b    _OSLockNesting.L,D0
00002FC4  0310      
00002FC6  0C00 0000 9093          cmp.b     #0,D0
00002FCA  630A      9094          bls.s     OSMutexPend_6
                    9095   ; *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
00002FCC  2045      9096          move.l    D5,A0
00002FCE  10BC 000D 9097          move.b    #13,(A0)
                    9098   ; return;
00002FD2  6000 0280 9099          bra       OSMutexPend_3
                    9100   OSMutexPend_6:
                    9101   ; }
                    9102   ; /*$PAGE*/
                    9103   ; OS_ENTER_CRITICAL();
00002FD6  40E7      9104          dc.w      16615
00002FD8  007C      9105          dc.w      124
00002FDA  0700      9106          dc.w      1792
                    9107   ; pcp = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PCP from mutex                       */
00002FDC  2043      9108          move.l    D3,A0
00002FDE  3028 0006 9109          move.w    6(A0),D0
00002FE2  E048      9110          lsr.w     #8,D0
00002FE4  1E00      9111          move.b    D0,D7
                    9112   ; /* Is Mutex available?                      */
                    9113   ; if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
00002FE6  2043      9114          move.l    D3,A0
00002FE8  3028 0006 9115          move.w    6(A0),D0
00002FEC  C07C 00FF 9116          and.w     #255,D0
00002FF0  C07C 00FF 9117          and.w     #255,D0
00002FF4  0C40 00FF 9118          cmp.w     #255,D0
00002FF8  6600 0042 9119          bne       OSMutexPend_8
                    9120   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
00002FFC  2043      9121          move.l    D3,A0
00002FFE  0268 FF00 9122          and.w     #65280,6(A0)
00003002  0006      
                    9123   ; pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
00003004  2043      9124          move.l    D3,A0
00003006  2252      9125          move.l    (A2),A1
00003008  1029 0034 9126          move.b    52(A1),D0
0000300C  C07C 00FF 9127          and.w     #255,D0
00003010  8168 0006 9128          or.w      D0,6(A0)
                    9129   ; pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
00003014  2043      9130          move.l    D3,A0
00003016  2152 0002 9131          move.l    (A2),2(A0)
                    9132   ; if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
0000301A  0C07 00FF 9133          cmp.b     #255,D7
0000301E  6712      9134          beq.s     OSMutexPend_10
00003020  2052      9135          move.l    (A2),A0
00003022  BE28 0034 9136          cmp.b     52(A0),D7
00003026  650A      9137          blo.s     OSMutexPend_10
                    9138   ; (OSTCBCur->OSTCBPrio <= pcp)) {                /*      PCP 'must' have a SMALLER prio ...  */
                    9139   ; OS_EXIT_CRITICAL();                           /*      ... than current task!              */
00003028  46DF      9140          dc.w      18143
                    9141   ; *perr = OS_ERR_PCP_LOWER;
0000302A  2045      9142          move.l    D5,A0
0000302C  10BC 0078 9143          move.b    #120,(A0)
00003030  6006      9144          bra.s     OSMutexPend_11
                    9145   OSMutexPend_10:
                    9146   ; } else {
                    9147   ; OS_EXIT_CRITICAL();
00003032  46DF      9148          dc.w      18143
                    9149   ; *perr = OS_ERR_NONE;
00003034  2045      9150          move.l    D5,A0
00003036  4210      9151          clr.b     (A0)
                    9152   OSMutexPend_11:
                    9153   ; }
                    9154   ; return;
00003038  6000 021A 9155          bra       OSMutexPend_3
                    9156   OSMutexPend_8:
                    9157   ; }
                    9158   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
0000303C  0C07 00FF 9159          cmp.b     #255,D7
00003040  6700 018A 9160          beq       OSMutexPend_16
                    9161   ; mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /*  Get priority of mutex owner   */
00003044  2043      9162          move.l    D3,A0
00003046  3028 0006 9163          move.w    6(A0),D0
0000304A  C07C 00FF 9164          and.w     #255,D0
0000304E  1D40 FFFE 9165          move.b    D0,-2(A6)
                    9166   ; ptcb  = (OS_TCB *)(pevent->OSEventPtr);                   /*     Point to TCB of mutex owner   */
00003052  2043      9167          move.l    D3,A0
00003054  2428 0002 9168          move.l    2(A0),D2
                    9169   ; if (ptcb->OSTCBPrio > pcp) {                              /*     Need to promote prio of owner?*/
00003058  2042      9170          move.l    D2,A0
0000305A  BE28 0034 9171          cmp.b     52(A0),D7
0000305E  6400 016C 9172          bhs       OSMutexPend_16
                    9173   ; if (mprio > OSTCBCur->OSTCBPrio) {
00003062  2052      9174          move.l    (A2),A0
00003064  102E FFFE 9175          move.b    -2(A6),D0
00003068  B028 0034 9176          cmp.b     52(A0),D0
0000306C  6300 015E 9177          bls       OSMutexPend_16
                    9178   ; y = ptcb->OSTCBY;
00003070  2042      9179          move.l    D2,A0
00003072  1C28 0036 9180          move.b    54(A0),D6
                    9181   ; if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0u) {      /*     See if mutex owner is ready   */
00003076  CCBC 0000 9182          and.l     #255,D6
0000307A  00FF      
0000307C  1033 6800 9183          move.b    0(A3,D6.L),D0
00003080  2042      9184          move.l    D2,A0
00003082  C028 0037 9185          and.b     55(A0),D0
00003086  6736      9186          beq.s     OSMutexPend_18
                    9187   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;     /*     Yes, Remove owner from Rdy ...*/
00003088  CCBC 0000 9188          and.l     #255,D6
0000308C  00FF      
0000308E  2042      9189          move.l    D2,A0
00003090  1028 0037 9190          move.b    55(A0),D0
00003094  4600      9191          not.b     D0
00003096  C133 6800 9192          and.b     D0,0(A3,D6.L)
                    9193   ; if (OSRdyTbl[y] == 0u) {                      /*          ... list at current prio */
0000309A  CCBC 0000 9194          and.l     #255,D6
0000309E  00FF      
000030A0  1033 6800 9195          move.b    0(A3,D6.L),D0
000030A4  660E      9196          bne.s     OSMutexPend_20
                    9197   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
000030A6  2042      9198          move.l    D2,A0
000030A8  1028 0038 9199          move.b    56(A0),D0
000030AC  4600      9200          not.b     D0
000030AE  C139 0800 9201          and.b     D0,_OSRdyGrp.L
000030B2  0316      
                    9202   OSMutexPend_20:
                    9203   ; }
                    9204   ; rdy = OS_TRUE;
000030B4  1D7C 0001 9205          move.b    #1,-1(A6)
000030B8  FFFF      
000030BA  6000 004C 9206          bra       OSMutexPend_19
                    9207   OSMutexPend_18:
                    9208   ; } else {
                    9209   ; pevent2 = ptcb->OSTCBEventPtr;
000030BE  2042      9210          move.l    D2,A0
000030C0  2828 001C 9211          move.l    28(A0),D4
                    9212   ; if (pevent2 != (OS_EVENT *)0) {               /* Remove from event wait list       */
000030C4  4A84      9213          tst.l     D4
000030C6  6700 003C 9214          beq       OSMutexPend_24
                    9215   ; y = ptcb->OSTCBY;
000030CA  2042      9216          move.l    D2,A0
000030CC  1C28 0036 9217          move.b    54(A0),D6
                    9218   ; pevent2->OSEventTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
000030D0  2044      9219          move.l    D4,A0
000030D2  CCBC 0000 9220          and.l     #255,D6
000030D6  00FF      
000030D8  D1C6      9221          add.l     D6,A0
000030DA  2242      9222          move.l    D2,A1
000030DC  1029 0037 9223          move.b    55(A1),D0
000030E0  4600      9224          not.b     D0
000030E2  C128 000A 9225          and.b     D0,10(A0)
                    9226   ; if (pevent2->OSEventTbl[y] == 0u) {
000030E6  2044      9227          move.l    D4,A0
000030E8  CCBC 0000 9228          and.l     #255,D6
000030EC  00FF      
000030EE  D1C6      9229          add.l     D6,A0
000030F0  1028 000A 9230          move.b    10(A0),D0
000030F4  660E      9231          bne.s     OSMutexPend_24
                    9232   ; pevent2->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
000030F6  2044      9233          move.l    D4,A0
000030F8  2242      9234          move.l    D2,A1
000030FA  1029 0038 9235          move.b    56(A1),D0
000030FE  4600      9236          not.b     D0
00003100  C128 0008 9237          and.b     D0,8(A0)
                    9238   OSMutexPend_24:
                    9239   ; }
                    9240   ; }
                    9241   ; rdy = OS_FALSE;                        /* No                                       */
00003104  422E FFFF 9242          clr.b     -1(A6)
                    9243   OSMutexPend_19:
                    9244   ; }
                    9245   ; ptcb->OSTCBPrio = pcp;                     /* Change owner task prio to PCP            */
00003108  2042      9246          move.l    D2,A0
0000310A  1147 0034 9247          move.b    D7,52(A0)
                    9248   ; #if OS_LOWEST_PRIO <= 63u
                    9249   ; ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
0000310E  2042      9250          move.l    D2,A0
00003110  1028 0034 9251          move.b    52(A0),D0
00003114  E608      9252          lsr.b     #3,D0
00003116  2042      9253          move.l    D2,A0
00003118  1140 0036 9254          move.b    D0,54(A0)
                    9255   ; ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
0000311C  2042      9256          move.l    D2,A0
0000311E  1028 0034 9257          move.b    52(A0),D0
00003122  C03C 0007 9258          and.b     #7,D0
00003126  2042      9259          move.l    D2,A0
00003128  1140 0035 9260          move.b    D0,53(A0)
                    9261   ; #else
                    9262   ; ptcb->OSTCBY    = (INT8U)((INT8U)(ptcb->OSTCBPrio >> 4u) & 0xFFu);
                    9263   ; ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0Fu);
                    9264   ; #endif
                    9265   ; ptcb->OSTCBBitY = (OS_PRIO)(1uL << ptcb->OSTCBY);
0000312C  7001      9266          moveq     #1,D0
0000312E  2042      9267          move.l    D2,A0
00003130  1228 0036 9268          move.b    54(A0),D1
00003134  C2BC 0000 9269          and.l     #255,D1
00003138  00FF      
0000313A  E3A8      9270          lsl.l     D1,D0
0000313C  2042      9271          move.l    D2,A0
0000313E  1140 0038 9272          move.b    D0,56(A0)
                    9273   ; ptcb->OSTCBBitX = (OS_PRIO)(1uL << ptcb->OSTCBX);
00003142  7001      9274          moveq     #1,D0
00003144  2042      9275          move.l    D2,A0
00003146  1228 0035 9276          move.b    53(A0),D1
0000314A  C2BC 0000 9277          and.l     #255,D1
0000314E  00FF      
00003150  E3A8      9278          lsl.l     D1,D0
00003152  2042      9279          move.l    D2,A0
00003154  1140 0037 9280          move.b    D0,55(A0)
                    9281   ; if (rdy == OS_TRUE) {                      /* If task was ready at owner's priority ...*/
00003158  102E FFFF 9282          move.b    -1(A6),D0
0000315C  0C00 0001 9283          cmp.b     #1,D0
00003160  6626      9284          bne.s     OSMutexPend_26
                    9285   ; OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.   */
00003162  2042      9286          move.l    D2,A0
00003164  1028 0038 9287          move.b    56(A0),D0
00003168  8139 0800 9288          or.b      D0,_OSRdyGrp.L
0000316C  0316      
                    9289   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0000316E  2042      9290          move.l    D2,A0
00003170  1028 0036 9291          move.b    54(A0),D0
00003174  C0BC 0000 9292          and.l     #255,D0
00003178  00FF      
0000317A  2042      9293          move.l    D2,A0
0000317C  1228 0037 9294          move.b    55(A0),D1
00003180  8333 0800 9295          or.b      D1,0(A3,D0.L)
00003184  6000 0032 9296          bra       OSMutexPend_28
                    9297   OSMutexPend_26:
                    9298   ; } else {
                    9299   ; pevent2 = ptcb->OSTCBEventPtr;
00003188  2042      9300          move.l    D2,A0
0000318A  2828 001C 9301          move.l    28(A0),D4
                    9302   ; if (pevent2 != (OS_EVENT *)0) {        /* Add to event wait list                   */
0000318E  4A84      9303          tst.l     D4
00003190  6726      9304          beq.s     OSMutexPend_28
                    9305   ; pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
00003192  2044      9306          move.l    D4,A0
00003194  2242      9307          move.l    D2,A1
00003196  1029 0038 9308          move.b    56(A1),D0
0000319A  8128 0008 9309          or.b      D0,8(A0)
                    9310   ; pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0000319E  2044      9311          move.l    D4,A0
000031A0  2242      9312          move.l    D2,A1
000031A2  1029 0036 9313          move.b    54(A1),D0
000031A6  C0BC 0000 9314          and.l     #255,D0
000031AA  00FF      
000031AC  D1C0      9315          add.l     D0,A0
000031AE  2242      9316          move.l    D2,A1
000031B0  1029 0037 9317          move.b    55(A1),D0
000031B4  8128 000A 9318          or.b      D0,10(A0)
                    9319   OSMutexPend_28:
                    9320   ; }
                    9321   ; }
                    9322   ; OSTCBPrioTbl[pcp] = ptcb;
000031B8  CEBC 0000 9323          and.l     #255,D7
000031BC  00FF      
000031BE  2007      9324          move.l    D7,D0
000031C0  E588      9325          lsl.l     #2,D0
000031C2  41F9 0800 9326          lea       _OSTCBPrioTbl.L,A0
000031C6  0438      
000031C8  2182 0800 9327          move.l    D2,0(A0,D0.L)
                    9328   OSMutexPend_16:
                    9329   ; }
                    9330   ; }
                    9331   ; }
                    9332   ; OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
000031CC  2052      9333          move.l    (A2),A0
000031CE  0028 0010 9334          or.b      #16,50(A0)
000031D2  0032      
                    9335   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
000031D4  2052      9336          move.l    (A2),A0
000031D6  4228 0033 9337          clr.b     51(A0)
                    9338   ; OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
000031DA  2052      9339          move.l    (A2),A0
000031DC  216E 000C 9340          move.l    12(A6),46(A0)
000031E0  002E      
                    9341   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
000031E2  2F03      9342          move.l    D3,-(A7)
000031E4  4EB8 10DE 9343          jsr       _OS_EventTaskWait
000031E8  584F      9344          addq.w    #4,A7
                    9345   ; OS_EXIT_CRITICAL();
000031EA  46DF      9346          dc.w      18143
                    9347   ; OS_Sched();                                       /* Find next highest priority task ready         */
000031EC  4EB8 15DA 9348          jsr       _OS_Sched
                    9349   ; OS_ENTER_CRITICAL();
000031F0  40E7      9350          dc.w      16615
000031F2  007C      9351          dc.w      124
000031F4  0700      9352          dc.w      1792
                    9353   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
000031F6  2052      9354          move.l    (A2),A0
000031F8  1028 0033 9355          move.b    51(A0),D0
000031FC  C0BC 0000 9356          and.l     #255,D0
00003200  00FF      
00003202  0C80 0000 9357          cmp.l     #1,D0
00003206  0001      
00003208  6720      9358          beq.s     OSMutexPend_34
0000320A  6206      9359          bhi.s     OSMutexPend_36
0000320C  4A80      9360          tst.l     D0
0000320E  670C      9361          beq.s     OSMutexPend_32
00003210  6018      9362          bra.s     OSMutexPend_34
                    9363   OSMutexPend_36:
00003212  0C80 0000 9364          cmp.l     #2,D0
00003216  0002      
00003218  6708      9365          beq.s     OSMutexPend_33
0000321A  600E      9366          bra.s     OSMutexPend_34
                    9367   OSMutexPend_32:
                    9368   ; case OS_STAT_PEND_OK:
                    9369   ; *perr = OS_ERR_NONE;
0000321C  2045      9370          move.l    D5,A0
0000321E  4210      9371          clr.b     (A0)
                    9372   ; break;
00003220  6018      9373          bra.s     OSMutexPend_31
                    9374   OSMutexPend_33:
                    9375   ; case OS_STAT_PEND_ABORT:
                    9376   ; *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
00003222  2045      9377          move.l    D5,A0
00003224  10BC 000E 9378          move.b    #14,(A0)
                    9379   ; break;
00003228  6010      9380          bra.s     OSMutexPend_31
                    9381   OSMutexPend_34:
                    9382   ; case OS_STAT_PEND_TO:
                    9383   ; default:
                    9384   ; OS_EventTaskRemove(OSTCBCur, pevent);
0000322A  2F03      9385          move.l    D3,-(A7)
0000322C  2F12      9386          move.l    (A2),-(A7)
0000322E  4EB8 1200 9387          jsr       _OS_EventTaskRemove
00003232  504F      9388          addq.w    #8,A7
                    9389   ; *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
00003234  2045      9390          move.l    D5,A0
00003236  10BC 000A 9391          move.b    #10,(A0)
                    9392   ; break;
                    9393   OSMutexPend_31:
                    9394   ; }
                    9395   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
0000323A  2052      9396          move.l    (A2),A0
0000323C  4228 0032 9397          clr.b     50(A0)
                    9398   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
00003240  2052      9399          move.l    (A2),A0
00003242  4228 0033 9400          clr.b     51(A0)
                    9401   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
00003246  2052      9402          move.l    (A2),A0
00003248  42A8 001C 9403          clr.l     28(A0)
                    9404   ; #if (OS_EVENT_MULTI_EN > 0u)
                    9405   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
0000324C  2052      9406          move.l    (A2),A0
0000324E  42A8 0020 9407          clr.l     32(A0)
                    9408   ; #endif
                    9409   ; OS_EXIT_CRITICAL();
00003252  46DF      9410          dc.w      18143
                    9411   OSMutexPend_3:
00003254  4CDF 0CFC 9412          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3
00003258  4E5E      9413          unlk      A6
0000325A  4E75      9414          rts
                    9415   ; }
                    9416   ; /*$PAGE*/
                    9417   ; /*
                    9418   ; *********************************************************************************************************
                    9419   ; *                                POST TO A MUTUAL EXCLUSION SEMAPHORE
                    9420   ; *
                    9421   ; * Description: This function signals a mutual exclusion semaphore
                    9422   ; *
                    9423   ; * Arguments  : pevent              is a pointer to the event control block associated with the desired
                    9424   ; *                                  mutex.
                    9425   ; *
                    9426   ; * Returns    : OS_ERR_NONE             The call was successful and the mutex was signaled.
                    9427   ; *              OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
                    9428   ; *              OS_ERR_PEVENT_NULL      'pevent' is a NULL pointer
                    9429   ; *              OS_ERR_POST_ISR         Attempted to post from an ISR (not valid for MUTEXes)
                    9430   ; *              OS_ERR_NOT_MUTEX_OWNER  The task that did the post is NOT the owner of the MUTEX.
                    9431   ; *              OS_ERR_PCP_LOWER        If the priority of the new task that owns the Mutex is
                    9432   ; *                                      HIGHER (i.e. a lower number) than the PCP.  This error
                    9433   ; *                                      indicates that you did not set the PCP higher (lower
                    9434   ; *                                      number) than ALL the tasks that compete for the Mutex.
                    9435   ; *                                      Unfortunately, this is something that could not be
                    9436   ; *                                      detected when the Mutex is created because we don't know
                    9437   ; *                                      what tasks will be using the Mutex.
                    9438   ; *********************************************************************************************************
                    9439   ; */
                    9440   ; INT8U  OSMutexPost (OS_EVENT *pevent)
                    9441   ; {
                    9442   _OSMutexPost:
0000325C  4E56 0000 9443          link      A6,#0
00003260  48E7 3820 9444          movem.l   D2/D3/D4/A2,-(A7)
00003264  242E 0008 9445          move.l    8(A6),D2
00003268  45F9 0800 9446          lea       _OSTCBCur.L,A2
0000326C  0428      
                    9447   ; INT8U      pcp;                                   /* Priority ceiling priority                     */
                    9448   ; INT8U      prio;
                    9449   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    9450   ; OS_CPU_SR  cpu_sr = 0u;
                    9451   ; #endif
                    9452   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
0000326E  1039 0800 9453          move.b    _OSIntNesting.L,D0
00003272  030E      
00003274  0C00 0000 9454          cmp.b     #0,D0
00003278  6306      9455          bls.s     OSMutexPost_1
                    9456   ; return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
0000327A  7005      9457          moveq     #5,D0
0000327C  6000 00F0 9458          bra       OSMutexPost_3
                    9459   OSMutexPost_1:
                    9460   ; }
                    9461   ; #if OS_ARG_CHK_EN > 0u
                    9462   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    9463   ; return (OS_ERR_PEVENT_NULL);
                    9464   ; }
                    9465   ; #endif
                    9466   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
00003280  2042      9467          move.l    D2,A0
00003282  1010      9468          move.b    (A0),D0
00003284  0C00 0004 9469          cmp.b     #4,D0
00003288  6706      9470          beq.s     OSMutexPost_4
                    9471   ; return (OS_ERR_EVENT_TYPE);
0000328A  7001      9472          moveq     #1,D0
0000328C  6000 00E0 9473          bra       OSMutexPost_3
                    9474   OSMutexPost_4:
                    9475   ; }
                    9476   ; OS_ENTER_CRITICAL();
00003290  40E7      9477          dc.w      16615
00003292  007C      9478          dc.w      124
00003294  0700      9479          dc.w      1792
                    9480   ; pcp  = (INT8U)(pevent->OSEventCnt >> 8u);         /* Get priority ceiling priority of mutex        */
00003296  2042      9481          move.l    D2,A0
00003298  3028 0006 9482          move.w    6(A0),D0
0000329C  E048      9483          lsr.w     #8,D0
0000329E  1800      9484          move.b    D0,D4
                    9485   ; prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
000032A0  2042      9486          move.l    D2,A0
000032A2  3028 0006 9487          move.w    6(A0),D0
000032A6  C07C 00FF 9488          and.w     #255,D0
000032AA  1600      9489          move.b    D0,D3
                    9490   ; if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
000032AC  2042      9491          move.l    D2,A0
000032AE  2012      9492          move.l    (A2),D0
000032B0  B0A8 0002 9493          cmp.l     2(A0),D0
000032B4  6708      9494          beq.s     OSMutexPost_6
                    9495   ; OS_EXIT_CRITICAL();
000032B6  46DF      9496          dc.w      18143
                    9497   ; return (OS_ERR_NOT_MUTEX_OWNER);
000032B8  7064      9498          moveq     #100,D0
000032BA  6000 00B2 9499          bra       OSMutexPost_3
                    9500   OSMutexPost_6:
                    9501   ; }
                    9502   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
000032BE  0C04 00FF 9503          cmp.b     #255,D4
000032C2  6732      9504          beq.s     OSMutexPost_8
                    9505   ; if (OSTCBCur->OSTCBPrio == pcp) {             /* Did we have to raise current task's priority? */
000032C4  2052      9506          move.l    (A2),A0
000032C6  B828 0034 9507          cmp.b     52(A0),D4
000032CA  6612      9508          bne.s     OSMutexPost_10
                    9509   ; OSMutex_RdyAtPrio(OSTCBCur, prio);        /* Restore the task's original priority          */
000032CC  C6BC 0000 9510          and.l     #255,D3
000032D0  00FF      
000032D2  2F03      9511          move.l    D3,-(A7)
000032D4  2F12      9512          move.l    (A2),-(A7)
000032D6  4EB9 0000 9513          jsr       @ucos_ii_OSMutex_RdyAtPrio
000032DA  3428      
000032DC  504F      9514          addq.w    #8,A7
                    9515   OSMutexPost_10:
                    9516   ; }
                    9517   ; OSTCBPrioTbl[pcp] = OS_TCB_RESERVED;          /* Reserve table entry                           */
000032DE  C8BC 0000 9518          and.l     #255,D4
000032E2  00FF      
000032E4  2004      9519          move.l    D4,D0
000032E6  E588      9520          lsl.l     #2,D0
000032E8  41F9 0800 9521          lea       _OSTCBPrioTbl.L,A0
000032EC  0438      
000032EE  21BC 0000 9522          move.l    #1,0(A0,D0.L)
000032F2  0001 0800 
                    9523   OSMutexPost_8:
                    9524   ; }
                    9525   ; if (pevent->OSEventGrp != 0u) {                   /* Any task waiting for the mutex?               */
000032F6  2042      9526          move.l    D2,A0
000032F8  1028 0008 9527          move.b    8(A0),D0
000032FC  6700 005E 9528          beq       OSMutexPost_12
                    9529   ; /* Yes, Make HPT waiting for mutex ready         */
                    9530   ; prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
00003300  42A7      9531          clr.l     -(A7)
00003302  4878 0010 9532          pea       16
00003306  42A7      9533          clr.l     -(A7)
00003308  2F02      9534          move.l    D2,-(A7)
0000330A  4EB8 0FFA 9535          jsr       _OS_EventTaskRdy
0000330E  DEFC 0010 9536          add.w     #16,A7
00003312  1600      9537          move.b    D0,D3
                    9538   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
00003314  2042      9539          move.l    D2,A0
00003316  0268 FF00 9540          and.w     #65280,6(A0)
0000331A  0006      
                    9541   ; pevent->OSEventCnt |= prio;
0000331C  2042      9542          move.l    D2,A0
0000331E  C67C 00FF 9543          and.w     #255,D3
00003322  8768 0006 9544          or.w      D3,6(A0)
                    9545   ; pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
00003326  C6BC 0000 9546          and.l     #255,D3
0000332A  00FF      
0000332C  2003      9547          move.l    D3,D0
0000332E  E588      9548          lsl.l     #2,D0
00003330  41F9 0800 9549          lea       _OSTCBPrioTbl.L,A0
00003334  0438      
00003336  2242      9550          move.l    D2,A1
00003338  2370 0800 9551          move.l    0(A0,D0.L),2(A1)
0000333C  0002      
                    9552   ; if ((pcp  != OS_PRIO_MUTEX_CEIL_DIS) &&
0000333E  0C04 00FF 9553          cmp.b     #255,D4
00003342  670E      9554          beq.s     OSMutexPost_14
00003344  B604      9555          cmp.b     D4,D3
00003346  620A      9556          bhi.s     OSMutexPost_14
                    9557   ; (prio <= pcp)) {                          /*      PCP 'must' have a SMALLER prio ...       */
                    9558   ; OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
00003348  46DF      9559          dc.w      18143
                    9560   ; OS_Sched();                               /*      Find highest priority task ready to run  */
0000334A  4EB8 15DA 9561          jsr       _OS_Sched
                    9562   ; return (OS_ERR_PCP_LOWER);
0000334E  7078      9563          moveq     #120,D0
00003350  601C      9564          bra.s     OSMutexPost_3
                    9565   OSMutexPost_14:
                    9566   ; } else {
                    9567   ; OS_EXIT_CRITICAL();
00003352  46DF      9568          dc.w      18143
                    9569   ; OS_Sched();                               /*      Find highest priority task ready to run  */
00003354  4EB8 15DA 9570          jsr       _OS_Sched
                    9571   ; return (OS_ERR_NONE);
00003358  4200      9572          clr.b     D0
0000335A  6012      9573          bra.s     OSMutexPost_3
                    9574   OSMutexPost_12:
                    9575   ; }
                    9576   ; }
                    9577   ; pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
0000335C  2042      9578          move.l    D2,A0
0000335E  0068 00FF 9579          or.w      #255,6(A0)
00003362  0006      
                    9580   ; pevent->OSEventPtr  = (void *)0;
00003364  2042      9581          move.l    D2,A0
00003366  42A8 0002 9582          clr.l     2(A0)
                    9583   ; OS_EXIT_CRITICAL();
0000336A  46DF      9584          dc.w      18143
                    9585   ; return (OS_ERR_NONE);
0000336C  4200      9586          clr.b     D0
                    9587   OSMutexPost_3:
0000336E  4CDF 041C 9588          movem.l   (A7)+,D2/D3/D4/A2
00003372  4E5E      9589          unlk      A6
00003374  4E75      9590          rts
                    9591   ; }
                    9592   ; /*$PAGE*/
                    9593   ; /*
                    9594   ; *********************************************************************************************************
                    9595   ; *                                 QUERY A MUTUAL EXCLUSION SEMAPHORE
                    9596   ; *
                    9597   ; * Description: This function obtains information about a mutex
                    9598   ; *
                    9599   ; * Arguments  : pevent          is a pointer to the event control block associated with the desired mutex
                    9600   ; *
                    9601   ; *              p_mutex_data    is a pointer to a structure that will contain information about the mutex
                    9602   ; *
                    9603   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    9604   ; *              OS_ERR_QUERY_ISR     If you called this function from an ISR
                    9605   ; *              OS_ERR_PEVENT_NULL   If 'pevent'       is a NULL pointer
                    9606   ; *              OS_ERR_PDATA_NULL    If 'p_mutex_data' is a NULL pointer
                    9607   ; *              OS_ERR_EVENT_TYPE    If you are attempting to obtain data from a non mutex.
                    9608   ; *********************************************************************************************************
                    9609   ; */
                    9610   ; #if OS_MUTEX_QUERY_EN > 0u
                    9611   ; INT8U  OSMutexQuery (OS_EVENT       *pevent,
                    9612   ; OS_MUTEX_DATA  *p_mutex_data)
                    9613   ; {
                    9614   _OSMutexQuery:
00003376  4E56 FFF8 9615          link      A6,#-8
0000337A  48E7 3800 9616          movem.l   D2/D3/D4,-(A7)
0000337E  242E 000C 9617          move.l    12(A6),D2
00003382  262E 0008 9618          move.l    8(A6),D3
                    9619   ; INT8U       i;
                    9620   ; OS_PRIO    *psrc;
                    9621   ; OS_PRIO    *pdest;
                    9622   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    9623   ; OS_CPU_SR   cpu_sr = 0u;
                    9624   ; #endif
                    9625   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00003386  1039 0800 9626          move.b    _OSIntNesting.L,D0
0000338A  030E      
0000338C  0C00 0000 9627          cmp.b     #0,D0
00003390  6306      9628          bls.s     OSMutexQuery_1
                    9629   ; return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
00003392  7006      9630          moveq     #6,D0
00003394  6000 008A 9631          bra       OSMutexQuery_3
                    9632   OSMutexQuery_1:
                    9633   ; }
                    9634   ; #if OS_ARG_CHK_EN > 0u
                    9635   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    9636   ; return (OS_ERR_PEVENT_NULL);
                    9637   ; }
                    9638   ; if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
                    9639   ; return (OS_ERR_PDATA_NULL);
                    9640   ; }
                    9641   ; #endif
                    9642   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
00003398  2043      9643          move.l    D3,A0
0000339A  1010      9644          move.b    (A0),D0
0000339C  0C00 0004 9645          cmp.b     #4,D0
000033A0  6706      9646          beq.s     OSMutexQuery_4
                    9647   ; return (OS_ERR_EVENT_TYPE);
000033A2  7001      9648          moveq     #1,D0
000033A4  6000 007A 9649          bra       OSMutexQuery_3
                    9650   OSMutexQuery_4:
                    9651   ; }
                    9652   ; OS_ENTER_CRITICAL();
000033A8  40E7      9653          dc.w      16615
000033AA  007C      9654          dc.w      124
000033AC  0700      9655          dc.w      1792
                    9656   ; p_mutex_data->OSMutexPCP  = (INT8U)(pevent->OSEventCnt >> 8u);
000033AE  2043      9657          move.l    D3,A0
000033B0  3028 0006 9658          move.w    6(A0),D0
000033B4  E048      9659          lsr.w     #8,D0
000033B6  2042      9660          move.l    D2,A0
000033B8  1140 000B 9661          move.b    D0,11(A0)
                    9662   ; p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
000033BC  2043      9663          move.l    D3,A0
000033BE  3028 0006 9664          move.w    6(A0),D0
000033C2  C07C 00FF 9665          and.w     #255,D0
000033C6  2042      9666          move.l    D2,A0
000033C8  1140 000A 9667          move.b    D0,10(A0)
                    9668   ; if (p_mutex_data->OSOwnerPrio == 0xFFu) {
000033CC  2042      9669          move.l    D2,A0
000033CE  1028 000A 9670          move.b    10(A0),D0
000033D2  0C00 00FF 9671          cmp.b     #255,D0
000033D6  660A      9672          bne.s     OSMutexQuery_6
                    9673   ; p_mutex_data->OSValue = OS_TRUE;
000033D8  2042      9674          move.l    D2,A0
000033DA  117C 0001 9675          move.b    #1,9(A0)
000033DE  0009      
000033E0  6006      9676          bra.s     OSMutexQuery_7
                    9677   OSMutexQuery_6:
                    9678   ; } else {
                    9679   ; p_mutex_data->OSValue = OS_FALSE;
000033E2  2042      9680          move.l    D2,A0
000033E4  4228 0009 9681          clr.b     9(A0)
                    9682   OSMutexQuery_7:
                    9683   ; }
                    9684   ; p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
000033E8  2043      9685          move.l    D3,A0
000033EA  2242      9686          move.l    D2,A1
000033EC  1368 0008 9687          move.b    8(A0),8(A1)
000033F0  0008      
                    9688   ; psrc                      = &pevent->OSEventTbl[0];
000033F2  700A      9689          moveq     #10,D0
000033F4  D083      9690          add.l     D3,D0
000033F6  2D40 FFF8 9691          move.l    D0,-8(A6)
                    9692   ; pdest                     = &p_mutex_data->OSEventTbl[0];
000033FA  2D42 FFFC 9693          move.l    D2,-4(A6)
                    9694   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
000033FE  4204      9695          clr.b     D4
                    9696   OSMutexQuery_8:
00003400  0C04 0008 9697          cmp.b     #8,D4
00003404  6416      9698          bhs.s     OSMutexQuery_10
                    9699   ; *pdest++ = *psrc++;
00003406  206E FFF8 9700          move.l    -8(A6),A0
0000340A  52AE FFF8 9701          addq.l    #1,-8(A6)
0000340E  226E FFFC 9702          move.l    -4(A6),A1
00003412  52AE FFFC 9703          addq.l    #1,-4(A6)
00003416  1290      9704          move.b    (A0),(A1)
00003418  5204      9705          addq.b    #1,D4
0000341A  60E4      9706          bra       OSMutexQuery_8
                    9707   OSMutexQuery_10:
                    9708   ; }
                    9709   ; OS_EXIT_CRITICAL();
0000341C  46DF      9710          dc.w      18143
                    9711   ; return (OS_ERR_NONE);
0000341E  4200      9712          clr.b     D0
                    9713   OSMutexQuery_3:
00003420  4CDF 001C 9714          movem.l   (A7)+,D2/D3/D4
00003424  4E5E      9715          unlk      A6
00003426  4E75      9716          rts
                    9717   ; }
                    9718   ; #endif                                                     /* OS_MUTEX_QUERY_EN                        */
                    9719   ; /*$PAGE*/
                    9720   ; /*
                    9721   ; *********************************************************************************************************
                    9722   ; *                            RESTORE A TASK BACK TO ITS ORIGINAL PRIORITY
                    9723   ; *
                    9724   ; * Description: This function makes a task ready at the specified priority
                    9725   ; *
                    9726   ; * Arguments  : ptcb            is a pointer to OS_TCB of the task to make ready
                    9727   ; *
                    9728   ; *              prio            is the desired priority
                    9729   ; *
                    9730   ; * Returns    : none
                    9731   ; *********************************************************************************************************
                    9732   ; */
                    9733   ; static  void  OSMutex_RdyAtPrio (OS_TCB  *ptcb,
                    9734   ; INT8U    prio)
                    9735   ; {
                    9736   @ucos_ii_OSMutex_RdyAtPrio:
00003428  4E56 0000 9737          link      A6,#0
0000342C  48E7 3820 9738          movem.l   D2/D3/D4/A2,-(A7)
00003430  242E 0008 9739          move.l    8(A6),D2
00003434  162E 000F 9740          move.b    15(A6),D3
00003438  C6BC 0000 9741          and.l     #255,D3
0000343C  00FF      
0000343E  45F9 0800 9742          lea       _OSRdyTbl.L,A2
00003442  0318      
                    9743   ; INT8U  y;
                    9744   ; y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pcp'    */
00003444  2042      9745          move.l    D2,A0
00003446  1828 0036 9746          move.b    54(A0),D4
                    9747   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
0000344A  C8BC 0000 9748          and.l     #255,D4
0000344E  00FF      
00003450  2042      9749          move.l    D2,A0
00003452  1028 0037 9750          move.b    55(A0),D0
00003456  4600      9751          not.b     D0
00003458  C132 4800 9752          and.b     D0,0(A2,D4.L)
                    9753   ; if (OSRdyTbl[y] == 0u) {
0000345C  C8BC 0000 9754          and.l     #255,D4
00003460  00FF      
00003462  1032 4800 9755          move.b    0(A2,D4.L),D0
00003466  660E      9756          bne.s     @ucos_ii_OSMutex_RdyAtPrio_1
                    9757   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00003468  2042      9758          move.l    D2,A0
0000346A  1028 0038 9759          move.b    56(A0),D0
0000346E  4600      9760          not.b     D0
00003470  C139 0800 9761          and.b     D0,_OSRdyGrp.L
00003474  0316      
                    9762   @ucos_ii_OSMutex_RdyAtPrio_1:
                    9763   ; }
                    9764   ; ptcb->OSTCBPrio         = prio;
00003476  2042      9765          move.l    D2,A0
00003478  1143 0034 9766          move.b    D3,52(A0)
                    9767   ; OSPrioCur               = prio;                        /* The current task is now at this priority */
0000347C  13C3 0800 9768          move.b    D3,_OSPrioCur.L
00003480  0312      
                    9769   ; #if OS_LOWEST_PRIO <= 63u
                    9770   ; ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 3u) & 0x07u);
00003482  1003      9771          move.b    D3,D0
00003484  E608      9772          lsr.b     #3,D0
00003486  C03C 0007 9773          and.b     #7,D0
0000348A  2042      9774          move.l    D2,A0
0000348C  1140 0036 9775          move.b    D0,54(A0)
                    9776   ; ptcb->OSTCBX            = (INT8U)(prio & 0x07u);
00003490  1003      9777          move.b    D3,D0
00003492  C03C 0007 9778          and.b     #7,D0
00003496  2042      9779          move.l    D2,A0
00003498  1140 0035 9780          move.b    D0,53(A0)
                    9781   ; #else
                    9782   ; ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 4u) & 0x0Fu);
                    9783   ; ptcb->OSTCBX            = (INT8U) (prio & 0x0Fu);
                    9784   ; #endif
                    9785   ; ptcb->OSTCBBitY         = (OS_PRIO)(1uL << ptcb->OSTCBY);
0000349C  7001      9786          moveq     #1,D0
0000349E  2042      9787          move.l    D2,A0
000034A0  1228 0036 9788          move.b    54(A0),D1
000034A4  C2BC 0000 9789          and.l     #255,D1
000034A8  00FF      
000034AA  E3A8      9790          lsl.l     D1,D0
000034AC  2042      9791          move.l    D2,A0
000034AE  1140 0038 9792          move.b    D0,56(A0)
                    9793   ; ptcb->OSTCBBitX         = (OS_PRIO)(1uL << ptcb->OSTCBX);
000034B2  7001      9794          moveq     #1,D0
000034B4  2042      9795          move.l    D2,A0
000034B6  1228 0035 9796          move.b    53(A0),D1
000034BA  C2BC 0000 9797          and.l     #255,D1
000034BE  00FF      
000034C0  E3A8      9798          lsl.l     D1,D0
000034C2  2042      9799          move.l    D2,A0
000034C4  1140 0037 9800          move.b    D0,55(A0)
                    9801   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
000034C8  2042      9802          move.l    D2,A0
000034CA  1028 0038 9803          move.b    56(A0),D0
000034CE  8139 0800 9804          or.b      D0,_OSRdyGrp.L
000034D2  0316      
                    9805   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000034D4  2042      9806          move.l    D2,A0
000034D6  1028 0036 9807          move.b    54(A0),D0
000034DA  C0BC 0000 9808          and.l     #255,D0
000034DE  00FF      
000034E0  2042      9809          move.l    D2,A0
000034E2  1228 0037 9810          move.b    55(A0),D1
000034E6  8332 0800 9811          or.b      D1,0(A2,D0.L)
                    9812   ; OSTCBPrioTbl[prio]      = ptcb;
000034EA  C6BC 0000 9813          and.l     #255,D3
000034EE  00FF      
000034F0  2003      9814          move.l    D3,D0
000034F2  E588      9815          lsl.l     #2,D0
000034F4  41F9 0800 9816          lea       _OSTCBPrioTbl.L,A0
000034F8  0438      
000034FA  2182 0800 9817          move.l    D2,0(A0,D0.L)
000034FE  4CDF 041C 9818          movem.l   (A7)+,D2/D3/D4/A2
00003502  4E5E      9819          unlk      A6
00003504  4E75      9820          rts
                    9821   ; /*
                    9822   ; *********************************************************************************************************
                    9823   ; *                                                uC/OS-II
                    9824   ; *                                          The Real-Time Kernel
                    9825   ; *                                        MESSAGE QUEUE MANAGEMENT
                    9826   ; *
                    9827   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    9828   ; *                                           All Rights Reserved
                    9829   ; *
                    9830   ; * File    : OS_Q.C
                    9831   ; * By      : Jean J. Labrosse
                    9832   ; * Version : V2.92.07
                    9833   ; *
                    9834   ; * LICENSING TERMS:
                    9835   ; * ---------------
                    9836   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    9837   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    9838   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    9839   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    9840   ; * licensing fee.
                    9841   ; *********************************************************************************************************
                    9842   ; */
                    9843   ; #define  MICRIUM_SOURCE
                    9844   ; #ifndef  OS_MASTER_FILE
                    9845   ; #include <ucos_ii.h>
                    9846   ; #endif
                    9847   ; #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
                    9848   ; /*
                    9849   ; *********************************************************************************************************
                    9850   ; *                                      ACCEPT MESSAGE FROM QUEUE
                    9851   ; *
                    9852   ; * Description: This function checks the queue to see if a message is available.  Unlike OSQPend(),
                    9853   ; *              OSQAccept() does not suspend the calling task if a message is not available.
                    9854   ; *
                    9855   ; * Arguments  : pevent        is a pointer to the event control block
                    9856   ; *
                    9857   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    9858   ; *                            messages are:
                    9859   ; *
                    9860   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    9861   ; *                                                message.
                    9862   ; *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
                    9863   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    9864   ; *                            OS_ERR_Q_EMPTY      The queue did not contain any messages
                    9865   ; *
                    9866   ; * Returns    : != (void *)0  is the message in the queue if one is available.  The message is removed
                    9867   ; *                            from the so the next time OSQAccept() is called, the queue will contain
                    9868   ; *                            one less entry.
                    9869   ; *              == (void *)0  if you received a NULL pointer message
                    9870   ; *                            if the queue is empty or,
                    9871   ; *                            if 'pevent' is a NULL pointer or,
                    9872   ; *                            if you passed an invalid event type
                    9873   ; *
                    9874   ; * Note(s)    : As of V2.60, you can now pass NULL pointers through queues.  Because of this, the argument
                    9875   ; *              'perr' has been added to the API to tell you about the outcome of the call.
                    9876   ; *********************************************************************************************************
                    9877   ; */
                    9878   ; #if OS_Q_ACCEPT_EN > 0u
                    9879   ; void  *OSQAccept (OS_EVENT  *pevent,
                    9880   ; INT8U     *perr)
                    9881   ; {
                    9882   _OSQAccept:
00003506  4E56 0000 9883          link      A6,#0
0000350A  48E7 3800 9884          movem.l   D2/D3/D4,-(A7)
0000350E  282E 000C 9885          move.l    12(A6),D4
                    9886   ; void      *pmsg;
                    9887   ; OS_Q      *pq;
                    9888   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    9889   ; OS_CPU_SR  cpu_sr = 0u;
                    9890   ; #endif
                    9891   ; #ifdef OS_SAFETY_CRITICAL
                    9892   ; if (perr == (INT8U *)0) {
                    9893   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    9894   ; return ((void *)0);
                    9895   ; }
                    9896   ; #endif
                    9897   ; #if OS_ARG_CHK_EN > 0u
                    9898   ; if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
                    9899   ; *perr = OS_ERR_PEVENT_NULL;
                    9900   ; return ((void *)0);
                    9901   ; }
                    9902   ; #endif
                    9903   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
00003512  206E 0008 9904          move.l    8(A6),A0
00003516  1010      9905          move.b    (A0),D0
00003518  0C00 0002 9906          cmp.b     #2,D0
0000351C  670C      9907          beq.s     OSQAccept_1
                    9908   ; *perr = OS_ERR_EVENT_TYPE;
0000351E  2044      9909          move.l    D4,A0
00003520  10BC 0001 9910          move.b    #1,(A0)
                    9911   ; return ((void *)0);
00003524  4280      9912          clr.l     D0
00003526  6000 0064 9913          bra       OSQAccept_3
                    9914   OSQAccept_1:
                    9915   ; }
                    9916   ; OS_ENTER_CRITICAL();
0000352A  40E7      9917          dc.w      16615
0000352C  007C      9918          dc.w      124
0000352E  0700      9919          dc.w      1792
                    9920   ; pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
00003530  206E 0008 9921          move.l    8(A6),A0
00003534  2428 0002 9922          move.l    2(A0),D2
                    9923   ; if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
00003538  2042      9924          move.l    D2,A0
0000353A  3028 0016 9925          move.w    22(A0),D0
0000353E  0C40 0000 9926          cmp.w     #0,D0
00003542  6300 003C 9927          bls       OSQAccept_4
                    9928   ; pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
00003546  2002      9929          move.l    D2,D0
00003548  0680 0000 9930          add.l     #16,D0
0000354C  0010      
0000354E  2040      9931          move.l    D0,A0
00003550  2250      9932          move.l    (A0),A1
00003552  5890      9933          addq.l    #4,(A0)
00003554  2611      9934          move.l    (A1),D3
                    9935   ; pq->OSQEntries--;                        /* Update the number of entries in the queue          */
00003556  2002      9936          move.l    D2,D0
00003558  0680 0000 9937          add.l     #22,D0
0000355C  0016      
0000355E  2040      9938          move.l    D0,A0
00003560  5350      9939          subq.w    #1,(A0)
                    9940   ; if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
00003562  2042      9941          move.l    D2,A0
00003564  2242      9942          move.l    D2,A1
00003566  2028 0010 9943          move.l    16(A0),D0
0000356A  B0A9 0008 9944          cmp.l     8(A1),D0
0000356E  660A      9945          bne.s     OSQAccept_6
                    9946   ; pq->OSQOut = pq->OSQStart;
00003570  2042      9947          move.l    D2,A0
00003572  2242      9948          move.l    D2,A1
00003574  2368 0004 9949          move.l    4(A0),16(A1)
00003578  0010      
                    9950   OSQAccept_6:
                    9951   ; }
                    9952   ; *perr = OS_ERR_NONE;
0000357A  2044      9953          move.l    D4,A0
0000357C  4210      9954          clr.b     (A0)
0000357E  6008      9955          bra.s     OSQAccept_5
                    9956   OSQAccept_4:
                    9957   ; } else {
                    9958   ; *perr = OS_ERR_Q_EMPTY;
00003580  2044      9959          move.l    D4,A0
00003582  10BC 001F 9960          move.b    #31,(A0)
                    9961   ; pmsg  = (void *)0;                       /* Queue is empty                                     */
00003586  4283      9962          clr.l     D3
                    9963   OSQAccept_5:
                    9964   ; }
                    9965   ; OS_EXIT_CRITICAL();
00003588  46DF      9966          dc.w      18143
                    9967   ; return (pmsg);                               /* Return message received (or NULL)                  */
0000358A  2003      9968          move.l    D3,D0
                    9969   OSQAccept_3:
0000358C  4CDF 001C 9970          movem.l   (A7)+,D2/D3/D4
00003590  4E5E      9971          unlk      A6
00003592  4E75      9972          rts
                    9973   ; }
                    9974   ; #endif
                    9975   ; /*$PAGE*/
                    9976   ; /*
                    9977   ; *********************************************************************************************************
                    9978   ; *                                       CREATE A MESSAGE QUEUE
                    9979   ; *
                    9980   ; * Description: This function creates a message queue if free event control blocks are available.
                    9981   ; *
                    9982   ; * Arguments  : start         is a pointer to the base address of the message queue storage area.  The
                    9983   ; *                            storage area MUST be declared as an array of pointers to 'void' as follows
                    9984   ; *
                    9985   ; *                            void *MessageStorage[size]
                    9986   ; *
                    9987   ; *              size          is the number of elements in the storage area
                    9988   ; *
                    9989   ; * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    9990   ; *                                created queue
                    9991   ; *              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
                    9992   ; *********************************************************************************************************
                    9993   ; */
                    9994   ; OS_EVENT  *OSQCreate (void    **start,
                    9995   ; INT16U    size)
                    9996   ; {
                    9997   _OSQCreate:
00003594  4E56 0000 9998          link      A6,#0
00003598  48E7 3830 9999          movem.l   D2/D3/D4/A2/A3,-(A7)
0000359C  45F9 0800 10000          lea       _OSEventFreeList.L,A2
000035A0  00E2      
000035A2  282E 0008 10001          move.l    8(A6),D4
000035A6  47F9 0800 10002          lea       _OSQFreeList.L,A3
000035AA  0D18      
                    10003   ; OS_EVENT  *pevent;
                    10004   ; OS_Q      *pq;
                    10005   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    10006   ; OS_CPU_SR  cpu_sr = 0u;
                    10007   ; #endif
                    10008   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    10009   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    10010   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10011   ; return ((OS_EVENT *)0);
                    10012   ; }
                    10013   ; #endif
                    10014   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
000035AC  1039 0800 10015          move.b    _OSIntNesting.L,D0
000035B0  030E      
000035B2  0C00 0000 10016          cmp.b     #0,D0
000035B6  6306      10017          bls.s     OSQCreate_1
                    10018   ; return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
000035B8  4280      10019          clr.l     D0
000035BA  6000 009C 10020          bra       OSQCreate_3
                    10021   OSQCreate_1:
                    10022   ; }
                    10023   ; OS_ENTER_CRITICAL();
000035BE  40E7      10024          dc.w      16615
000035C0  007C      10025          dc.w      124
000035C2  0700      10026          dc.w      1792
                    10027   ; pevent = OSEventFreeList;                    /* Get next free event control block                  */
000035C4  2412      10028          move.l    (A2),D2
                    10029   ; if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
000035C6  2012      10030          move.l    (A2),D0
000035C8  6706      10031          beq.s     OSQCreate_4
                    10032   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
000035CA  2052      10033          move.l    (A2),A0
000035CC  24A8 0002 10034          move.l    2(A0),(A2)
                    10035   OSQCreate_4:
                    10036   ; }
                    10037   ; OS_EXIT_CRITICAL();
000035D0  46DF      10038          dc.w      18143
                    10039   ; if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
000035D2  4A82      10040          tst.l     D2
000035D4  6700 0080 10041          beq       OSQCreate_9
                    10042   ; OS_ENTER_CRITICAL();
000035D8  40E7      10043          dc.w      16615
000035DA  007C      10044          dc.w      124
000035DC  0700      10045          dc.w      1792
                    10046   ; pq = OSQFreeList;                        /* Get a free queue control block                     */
000035DE  2613      10047          move.l    (A3),D3
                    10048   ; if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
000035E0  4A83      10049          tst.l     D3
000035E2  6700 0066 10050          beq       OSQCreate_8
                    10051   ; OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
000035E6  2053      10052          move.l    (A3),A0
000035E8  2690      10053          move.l    (A0),(A3)
                    10054   ; OS_EXIT_CRITICAL();
000035EA  46DF      10055          dc.w      18143
                    10056   ; pq->OSQStart           = start;               /*      Initialize the queue                 */
000035EC  2043      10057          move.l    D3,A0
000035EE  2144 0004 10058          move.l    D4,4(A0)
                    10059   ; pq->OSQEnd             = &start[size];
000035F2  2004      10060          move.l    D4,D0
000035F4  322E 000E 10061          move.w    14(A6),D1
000035F8  C2BC 0000 10062          and.l     #65535,D1
000035FC  FFFF      
000035FE  E589      10063          lsl.l     #2,D1
00003600  D081      10064          add.l     D1,D0
00003602  2043      10065          move.l    D3,A0
00003604  2140 0008 10066          move.l    D0,8(A0)
                    10067   ; pq->OSQIn              = start;
00003608  2043      10068          move.l    D3,A0
0000360A  2144 000C 10069          move.l    D4,12(A0)
                    10070   ; pq->OSQOut             = start;
0000360E  2043      10071          move.l    D3,A0
00003610  2144 0010 10072          move.l    D4,16(A0)
                    10073   ; pq->OSQSize            = size;
00003614  2043      10074          move.l    D3,A0
00003616  316E 000E 10075          move.w    14(A6),20(A0)
0000361A  0014      
                    10076   ; pq->OSQEntries         = 0u;
0000361C  2043      10077          move.l    D3,A0
0000361E  4268 0016 10078          clr.w     22(A0)
                    10079   ; pevent->OSEventType    = OS_EVENT_TYPE_Q;
00003622  2042      10080          move.l    D2,A0
00003624  10BC 0002 10081          move.b    #2,(A0)
                    10082   ; pevent->OSEventCnt     = 0u;
00003628  2042      10083          move.l    D2,A0
0000362A  4268 0006 10084          clr.w     6(A0)
                    10085   ; pevent->OSEventPtr     = pq;
0000362E  2042      10086          move.l    D2,A0
00003630  2143 0002 10087          move.l    D3,2(A0)
                    10088   ; #if OS_EVENT_NAME_EN > 0u
                    10089   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003634  41F9 0000 10090          lea       @ucos_ii_1.L,A0
00003638  708C      
0000363A  2242      10091          move.l    D2,A1
0000363C  2348 0012 10092          move.l    A0,18(A1)
                    10093   ; #endif
                    10094   ; OS_EventWaitListInit(pevent);                 /*      Initialize the wait list             */
00003640  2F02      10095          move.l    D2,-(A7)
00003642  4EB8 12C2 10096          jsr       _OS_EventWaitListInit
00003646  584F      10097          addq.w    #4,A7
00003648  600C      10098          bra.s     OSQCreate_9
                    10099   OSQCreate_8:
                    10100   ; } else {
                    10101   ; pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
0000364A  2042      10102          move.l    D2,A0
0000364C  2152 0002 10103          move.l    (A2),2(A0)
                    10104   ; OSEventFreeList    = pevent;
00003650  2482      10105          move.l    D2,(A2)
                    10106   ; OS_EXIT_CRITICAL();
00003652  46DF      10107          dc.w      18143
                    10108   ; pevent = (OS_EVENT *)0;
00003654  4282      10109          clr.l     D2
                    10110   OSQCreate_9:
                    10111   ; }
                    10112   ; }
                    10113   ; return (pevent);
00003656  2002      10114          move.l    D2,D0
                    10115   OSQCreate_3:
00003658  4CDF 0C1C 10116          movem.l   (A7)+,D2/D3/D4/A2/A3
0000365C  4E5E      10117          unlk      A6
0000365E  4E75      10118          rts
                    10119   ; }
                    10120   ; /*$PAGE*/
                    10121   ; /*
                    10122   ; *********************************************************************************************************
                    10123   ; *                                       DELETE A MESSAGE QUEUE
                    10124   ; *
                    10125   ; * Description: This function deletes a message queue and readies all tasks pending on the queue.
                    10126   ; *
                    10127   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    10128   ; *                            queue.
                    10129   ; *
                    10130   ; *              opt           determines delete options as follows:
                    10131   ; *                            opt == OS_DEL_NO_PEND   Delete the queue ONLY if no task pending
                    10132   ; *                            opt == OS_DEL_ALWAYS    Deletes the queue even if tasks are waiting.
                    10133   ; *                                                    In this case, all the tasks pending will be readied.
                    10134   ; *
                    10135   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    10136   ; *                            OS_ERR_NONE             The call was successful and the queue was deleted
                    10137   ; *                            OS_ERR_DEL_ISR          If you tried to delete the queue from an ISR
                    10138   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    10139   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the queue
                    10140   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a queue
                    10141   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    10142   ; *
                    10143   ; * Returns    : pevent        upon error
                    10144   ; *              (OS_EVENT *)0 if the queue was successfully deleted.
                    10145   ; *
                    10146   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    10147   ; *                 the queue MUST check the return code of OSQPend().
                    10148   ; *              2) OSQAccept() callers will not know that the intended queue has been deleted unless
                    10149   ; *                 they check 'pevent' to see that it's a NULL pointer.
                    10150   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    10151   ; *                 time is directly proportional to the number of tasks waiting on the queue.
                    10152   ; *              4) Because ALL tasks pending on the queue will be readied, you MUST be careful in
                    10153   ; *                 applications where the queue is used for mutual exclusion because the resource(s)
                    10154   ; *                 will no longer be guarded by the queue.
                    10155   ; *              5) If the storage for the message queue was allocated dynamically (i.e. using a malloc()
                    10156   ; *                 type call) then your application MUST release the memory storage by call the counterpart
                    10157   ; *                 call of the dynamic allocation scheme used.  If the queue storage was created statically
                    10158   ; *                 then, the storage can be reused.
                    10159   ; *              6) All tasks that were waiting for the queue will be readied and returned an 
                    10160   ; *                 OS_ERR_PEND_ABORT if OSQDel() was called with OS_DEL_ALWAYS
                    10161   ; *********************************************************************************************************
                    10162   ; */
                    10163   ; #if OS_Q_DEL_EN > 0u
                    10164   ; OS_EVENT  *OSQDel (OS_EVENT  *pevent,
                    10165   ; INT8U      opt,
                    10166   ; INT8U     *perr)
                    10167   ; {
                    10168   _OSQDel:
00003660  4E56 0000 10169          link      A6,#0
00003664  48E7 3E30 10170          movem.l   D2/D3/D4/D5/D6/A2/A3,-(A7)
00003668  242E 0008 10171          move.l    8(A6),D2
0000366C  282E 0010 10172          move.l    16(A6),D4
00003670  45F9 0800 10173          lea       _OSEventFreeList.L,A2
00003674  00E2      
00003676  47F9 0800 10174          lea       _OSQFreeList.L,A3
0000367A  0D18      
                    10175   ; BOOLEAN    tasks_waiting;
                    10176   ; OS_EVENT  *pevent_return;
                    10177   ; OS_Q      *pq;
                    10178   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    10179   ; OS_CPU_SR  cpu_sr = 0u;
                    10180   ; #endif
                    10181   ; #ifdef OS_SAFETY_CRITICAL
                    10182   ; if (perr == (INT8U *)0) {
                    10183   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10184   ; return ((OS_EVENT *)0);
                    10185   ; }
                    10186   ; #endif
                    10187   ; #if OS_ARG_CHK_EN > 0u
                    10188   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    10189   ; *perr = OS_ERR_PEVENT_NULL;
                    10190   ; return (pevent);
                    10191   ; }
                    10192   ; #endif
                    10193   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
0000367C  2042      10194          move.l    D2,A0
0000367E  1010      10195          move.b    (A0),D0
00003680  0C00 0002 10196          cmp.b     #2,D0
00003684  670C      10197          beq.s     OSQDel_1
                    10198   ; *perr = OS_ERR_EVENT_TYPE;
00003686  2044      10199          move.l    D4,A0
00003688  10BC 0001 10200          move.b    #1,(A0)
                    10201   ; return (pevent);
0000368C  2002      10202          move.l    D2,D0
0000368E  6000 0104 10203          bra       OSQDel_3
                    10204   OSQDel_1:
                    10205   ; }
                    10206   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00003692  1039 0800 10207          move.b    _OSIntNesting.L,D0
00003696  030E      
00003698  0C00 0000 10208          cmp.b     #0,D0
0000369C  630C      10209          bls.s     OSQDel_4
                    10210   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
0000369E  2044      10211          move.l    D4,A0
000036A0  10BC 000F 10212          move.b    #15,(A0)
                    10213   ; return (pevent);
000036A4  2002      10214          move.l    D2,D0
000036A6  6000 00EC 10215          bra       OSQDel_3
                    10216   OSQDel_4:
                    10217   ; }
                    10218   ; OS_ENTER_CRITICAL();
000036AA  40E7      10219          dc.w      16615
000036AC  007C      10220          dc.w      124
000036AE  0700      10221          dc.w      1792
                    10222   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on queue        */
000036B0  2042      10223          move.l    D2,A0
000036B2  1028 0008 10224          move.b    8(A0),D0
000036B6  6704      10225          beq.s     OSQDel_6
                    10226   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
000036B8  7C01      10227          moveq     #1,D6
000036BA  6002      10228          bra.s     OSQDel_7
                    10229   OSQDel_6:
                    10230   ; } else {
                    10231   ; tasks_waiting = OS_FALSE;                          /* No                                       */
000036BC  4206      10232          clr.b     D6
                    10233   OSQDel_7:
                    10234   ; }
                    10235   ; switch (opt) {
000036BE  102E 000F 10236          move.b    15(A6),D0
000036C2  C0BC 0000 10237          and.l     #255,D0
000036C6  00FF      
000036C8  0C80 0000 10238          cmp.l     #1,D0
000036CC  0001      
000036CE  6700 0056 10239          beq       OSQDel_11
000036D2  6200 00B4 10240          bhi       OSQDel_8
000036D6  4A80      10241          tst.l     D0
000036D8  6704      10242          beq.s     OSQDel_10
000036DA  6000 00AC 10243          bra       OSQDel_8
                    10244   OSQDel_10:
                    10245   ; case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
                    10246   ; if (tasks_waiting == OS_FALSE) {
000036DE  4A06      10247          tst.b     D6
000036E0  6600 0036 10248          bne       OSQDel_13
                    10249   ; #if OS_EVENT_NAME_EN > 0u
                    10250   ; pevent->OSEventName    = (INT8U *)(void *)"?";
000036E4  41F9 0000 10251          lea       @ucos_ii_1.L,A0
000036E8  708C      
000036EA  2242      10252          move.l    D2,A1
000036EC  2348 0012 10253          move.l    A0,18(A1)
                    10254   ; #endif
                    10255   ; pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
000036F0  2042      10256          move.l    D2,A0
000036F2  2628 0002 10257          move.l    2(A0),D3
                    10258   ; pq->OSQPtr             = OSQFreeList;
000036F6  2043      10259          move.l    D3,A0
000036F8  2093      10260          move.l    (A3),(A0)
                    10261   ; OSQFreeList            = pq;
000036FA  2683      10262          move.l    D3,(A3)
                    10263   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
000036FC  2042      10264          move.l    D2,A0
000036FE  4210      10265          clr.b     (A0)
                    10266   ; pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
00003700  2042      10267          move.l    D2,A0
00003702  2152 0002 10268          move.l    (A2),2(A0)
                    10269   ; pevent->OSEventCnt     = 0u;
00003706  2042      10270          move.l    D2,A0
00003708  4268 0006 10271          clr.w     6(A0)
                    10272   ; OSEventFreeList        = pevent;          /* Get next free event control block        */
0000370C  2482      10273          move.l    D2,(A2)
                    10274   ; OS_EXIT_CRITICAL();
0000370E  46DF      10275          dc.w      18143
                    10276   ; *perr                  = OS_ERR_NONE;
00003710  2044      10277          move.l    D4,A0
00003712  4210      10278          clr.b     (A0)
                    10279   ; pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
00003714  4285      10280          clr.l     D5
00003716  600A      10281          bra.s     OSQDel_14
                    10282   OSQDel_13:
                    10283   ; } else {
                    10284   ; OS_EXIT_CRITICAL();
00003718  46DF      10285          dc.w      18143
                    10286   ; *perr                  = OS_ERR_TASK_WAITING;
0000371A  2044      10287          move.l    D4,A0
0000371C  10BC 0049 10288          move.b    #73,(A0)
                    10289   ; pevent_return          = pevent;
00003720  2A02      10290          move.l    D2,D5
                    10291   OSQDel_14:
                    10292   ; }
                    10293   ; break;
00003722  6000 006E 10294          bra       OSQDel_9
                    10295   OSQDel_11:
                    10296   ; case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
                    10297   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for queue        */
                    10298   OSQDel_15:
00003726  2042      10299          move.l    D2,A0
00003728  1028 0008 10300          move.b    8(A0),D0
0000372C  671C      10301          beq.s     OSQDel_17
                    10302   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
0000372E  4878 0002 10303          pea       2
00003732  4878 0004 10304          pea       4
00003736  42A7      10305          clr.l     -(A7)
00003738  2F02      10306          move.l    D2,-(A7)
0000373A  4EB8 0FFA 10307          jsr       _OS_EventTaskRdy
0000373E  DEFC 0010 10308          add.w     #16,A7
00003742  C0BC 0000 10309          and.l     #255,D0
00003746  00FF      
00003748  60DC      10310          bra       OSQDel_15
                    10311   OSQDel_17:
                    10312   ; }
                    10313   ; #if OS_EVENT_NAME_EN > 0u
                    10314   ; pevent->OSEventName    = (INT8U *)(void *)"?";
0000374A  41F9 0000 10315          lea       @ucos_ii_1.L,A0
0000374E  708C      
00003750  2242      10316          move.l    D2,A1
00003752  2348 0012 10317          move.l    A0,18(A1)
                    10318   ; #endif
                    10319   ; pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
00003756  2042      10320          move.l    D2,A0
00003758  2628 0002 10321          move.l    2(A0),D3
                    10322   ; pq->OSQPtr             = OSQFreeList;
0000375C  2043      10323          move.l    D3,A0
0000375E  2093      10324          move.l    (A3),(A0)
                    10325   ; OSQFreeList            = pq;
00003760  2683      10326          move.l    D3,(A3)
                    10327   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00003762  2042      10328          move.l    D2,A0
00003764  4210      10329          clr.b     (A0)
                    10330   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
00003766  2042      10331          move.l    D2,A0
00003768  2152 0002 10332          move.l    (A2),2(A0)
                    10333   ; pevent->OSEventCnt     = 0u;
0000376C  2042      10334          move.l    D2,A0
0000376E  4268 0006 10335          clr.w     6(A0)
                    10336   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
00003772  2482      10337          move.l    D2,(A2)
                    10338   ; OS_EXIT_CRITICAL();
00003774  46DF      10339          dc.w      18143
                    10340   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00003776  0C06 0001 10341          cmp.b     #1,D6
0000377A  6604      10342          bne.s     OSQDel_18
                    10343   ; OS_Sched();                               /* Find highest priority task ready to run  */
0000377C  4EB8 15DA 10344          jsr       _OS_Sched
                    10345   OSQDel_18:
                    10346   ; }
                    10347   ; *perr                  = OS_ERR_NONE;
00003780  2044      10348          move.l    D4,A0
00003782  4210      10349          clr.b     (A0)
                    10350   ; pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
00003784  4285      10351          clr.l     D5
                    10352   ; break;
00003786  600A      10353          bra.s     OSQDel_9
                    10354   OSQDel_8:
                    10355   ; default:
                    10356   ; OS_EXIT_CRITICAL();
00003788  46DF      10357          dc.w      18143
                    10358   ; *perr                  = OS_ERR_INVALID_OPT;
0000378A  2044      10359          move.l    D4,A0
0000378C  10BC 0007 10360          move.b    #7,(A0)
                    10361   ; pevent_return          = pevent;
00003790  2A02      10362          move.l    D2,D5
                    10363   ; break;
                    10364   OSQDel_9:
                    10365   ; }
                    10366   ; return (pevent_return);
00003792  2005      10367          move.l    D5,D0
                    10368   OSQDel_3:
00003794  4CDF 0C7C 10369          movem.l   (A7)+,D2/D3/D4/D5/D6/A2/A3
00003798  4E5E      10370          unlk      A6
0000379A  4E75      10371          rts
                    10372   ; }
                    10373   ; #endif
                    10374   ; /*$PAGE*/
                    10375   ; /*
                    10376   ; *********************************************************************************************************
                    10377   ; *                                             FLUSH QUEUE
                    10378   ; *
                    10379   ; * Description : This function is used to flush the contents of the message queue.
                    10380   ; *
                    10381   ; * Arguments   : none
                    10382   ; *
                    10383   ; * Returns     : OS_ERR_NONE         upon success
                    10384   ; *               OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue
                    10385   ; *               OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    10386   ; *
                    10387   ; * WARNING     : You should use this function with great care because, when to flush the queue, you LOOSE
                    10388   ; *               the references to what the queue entries are pointing to and thus, you could cause
                    10389   ; *               'memory leaks'.  In other words, the data you are pointing to that's being referenced
                    10390   ; *               by the queue entries should, most likely, need to be de-allocated (i.e. freed).
                    10391   ; *********************************************************************************************************
                    10392   ; */
                    10393   ; #if OS_Q_FLUSH_EN > 0u
                    10394   ; INT8U  OSQFlush (OS_EVENT *pevent)
                    10395   ; {
                    10396   _OSQFlush:
0000379C  4E56 0000 10397          link      A6,#0
000037A0  2F02      10398          move.l    D2,-(A7)
                    10399   ; OS_Q      *pq;
                    10400   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    10401   ; OS_CPU_SR  cpu_sr = 0u;
                    10402   ; #endif
                    10403   ; #if OS_ARG_CHK_EN > 0u
                    10404   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    10405   ; return (OS_ERR_PEVENT_NULL);
                    10406   ; }
                    10407   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
                    10408   ; return (OS_ERR_EVENT_TYPE);
                    10409   ; }
                    10410   ; #endif
                    10411   ; OS_ENTER_CRITICAL();
000037A2  40E7      10412          dc.w      16615
000037A4  007C      10413          dc.w      124
000037A6  0700      10414          dc.w      1792
                    10415   ; pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
000037A8  206E 0008 10416          move.l    8(A6),A0
000037AC  2428 0002 10417          move.l    2(A0),D2
                    10418   ; pq->OSQIn      = pq->OSQStart;
000037B0  2042      10419          move.l    D2,A0
000037B2  2242      10420          move.l    D2,A1
000037B4  2368 0004 10421          move.l    4(A0),12(A1)
000037B8  000C      
                    10422   ; pq->OSQOut     = pq->OSQStart;
000037BA  2042      10423          move.l    D2,A0
000037BC  2242      10424          move.l    D2,A1
000037BE  2368 0004 10425          move.l    4(A0),16(A1)
000037C2  0010      
                    10426   ; pq->OSQEntries = 0u;
000037C4  2042      10427          move.l    D2,A0
000037C6  4268 0016 10428          clr.w     22(A0)
                    10429   ; OS_EXIT_CRITICAL();
000037CA  46DF      10430          dc.w      18143
                    10431   ; return (OS_ERR_NONE);
000037CC  4200      10432          clr.b     D0
000037CE  241F      10433          move.l    (A7)+,D2
000037D0  4E5E      10434          unlk      A6
000037D2  4E75      10435          rts
                    10436   ; }
                    10437   ; #endif
                    10438   ; /*$PAGE*/
                    10439   ; /*
                    10440   ; *********************************************************************************************************
                    10441   ; *                                    PEND ON A QUEUE FOR A MESSAGE
                    10442   ; *
                    10443   ; * Description: This function waits for a message to be sent to a queue
                    10444   ; *
                    10445   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    10446   ; *
                    10447   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    10448   ; *                            wait for a message to arrive at the queue up to the amount of time
                    10449   ; *                            specified by this argument.  If you specify 0, however, your task will wait
                    10450   ; *                            forever at the specified queue or, until a message arrives.
                    10451   ; *
                    10452   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    10453   ; *                            messages are:
                    10454   ; *
                    10455   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    10456   ; *                                                message.
                    10457   ; *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
                    10458   ; *                            OS_ERR_PEND_ABORT   The wait on the queue was aborted.
                    10459   ; *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
                    10460   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    10461   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    10462   ; *                                                would lead to a suspension.
                    10463   ; *                            OS_ERR_PEND_LOCKED  If you called this function with the scheduler is locked
                    10464   ; *
                    10465   ; * Returns    : != (void *)0  is a pointer to the message received
                    10466   ; *              == (void *)0  if you received a NULL pointer message or,
                    10467   ; *                            if no message was received or,
                    10468   ; *                            if 'pevent' is a NULL pointer or,
                    10469   ; *                            if you didn't pass a pointer to a queue.
                    10470   ; *
                    10471   ; * Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
                    10472   ; *********************************************************************************************************
                    10473   ; */
                    10474   ; void  *OSQPend (OS_EVENT  *pevent,
                    10475   ; INT32U     timeout,
                    10476   ; INT8U     *perr)
                    10477   ; {
                    10478   _OSQPend:
000037D4  4E56 0000 10479          link      A6,#0
000037D8  48E7 3C20 10480          movem.l   D2/D3/D4/D5/A2,-(A7)
000037DC  45F9 0800 10481          lea       _OSTCBCur.L,A2
000037E0  0428      
000037E2  262E 0010 10482          move.l    16(A6),D3
000037E6  2A2E 0008 10483          move.l    8(A6),D5
                    10484   ; void      *pmsg;
                    10485   ; OS_Q      *pq;
                    10486   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    10487   ; OS_CPU_SR  cpu_sr = 0u;
                    10488   ; #endif
                    10489   ; #ifdef OS_SAFETY_CRITICAL
                    10490   ; if (perr == (INT8U *)0) {
                    10491   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10492   ; return ((void *)0);
                    10493   ; }
                    10494   ; #endif
                    10495   ; #if OS_ARG_CHK_EN > 0u
                    10496   ; if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
                    10497   ; *perr = OS_ERR_PEVENT_NULL;
                    10498   ; return ((void *)0);
                    10499   ; }
                    10500   ; #endif
                    10501   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
000037EA  2045      10502          move.l    D5,A0
000037EC  1010      10503          move.b    (A0),D0
000037EE  0C00 0002 10504          cmp.b     #2,D0
000037F2  670C      10505          beq.s     OSQPend_1
                    10506   ; *perr = OS_ERR_EVENT_TYPE;
000037F4  2043      10507          move.l    D3,A0
000037F6  10BC 0001 10508          move.b    #1,(A0)
                    10509   ; return ((void *)0);
000037FA  4280      10510          clr.l     D0
000037FC  6000 0128 10511          bra       OSQPend_3
                    10512   OSQPend_1:
                    10513   ; }
                    10514   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
00003800  1039 0800 10515          move.b    _OSIntNesting.L,D0
00003804  030E      
00003806  0C00 0000 10516          cmp.b     #0,D0
0000380A  630C      10517          bls.s     OSQPend_4
                    10518   ; *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
0000380C  2043      10519          move.l    D3,A0
0000380E  10BC 0002 10520          move.b    #2,(A0)
                    10521   ; return ((void *)0);
00003812  4280      10522          clr.l     D0
00003814  6000 0110 10523          bra       OSQPend_3
                    10524   OSQPend_4:
                    10525   ; }
                    10526   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked ...            */
00003818  1039 0800 10527          move.b    _OSLockNesting.L,D0
0000381C  0310      
0000381E  0C00 0000 10528          cmp.b     #0,D0
00003822  630C      10529          bls.s     OSQPend_6
                    10530   ; *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
00003824  2043      10531          move.l    D3,A0
00003826  10BC 000D 10532          move.b    #13,(A0)
                    10533   ; return ((void *)0);
0000382A  4280      10534          clr.l     D0
0000382C  6000 00F8 10535          bra       OSQPend_3
                    10536   OSQPend_6:
                    10537   ; }
                    10538   ; OS_ENTER_CRITICAL();
00003830  40E7      10539          dc.w      16615
00003832  007C      10540          dc.w      124
00003834  0700      10541          dc.w      1792
                    10542   ; pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
00003836  2045      10543          move.l    D5,A0
00003838  2428 0002 10544          move.l    2(A0),D2
                    10545   ; if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
0000383C  2042      10546          move.l    D2,A0
0000383E  3028 0016 10547          move.w    22(A0),D0
00003842  0C40 0000 10548          cmp.w     #0,D0
00003846  6300 0042 10549          bls       OSQPend_8
                    10550   ; pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
0000384A  2002      10551          move.l    D2,D0
0000384C  0680 0000 10552          add.l     #16,D0
00003850  0010      
00003852  2040      10553          move.l    D0,A0
00003854  2250      10554          move.l    (A0),A1
00003856  5890      10555          addq.l    #4,(A0)
00003858  2811      10556          move.l    (A1),D4
                    10557   ; pq->OSQEntries--;                        /* Update the number of entries in the queue          */
0000385A  2002      10558          move.l    D2,D0
0000385C  0680 0000 10559          add.l     #22,D0
00003860  0016      
00003862  2040      10560          move.l    D0,A0
00003864  5350      10561          subq.w    #1,(A0)
                    10562   ; if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
00003866  2042      10563          move.l    D2,A0
00003868  2242      10564          move.l    D2,A1
0000386A  2028 0010 10565          move.l    16(A0),D0
0000386E  B0A9 0008 10566          cmp.l     8(A1),D0
00003872  660A      10567          bne.s     OSQPend_10
                    10568   ; pq->OSQOut = pq->OSQStart;
00003874  2042      10569          move.l    D2,A0
00003876  2242      10570          move.l    D2,A1
00003878  2368 0004 10571          move.l    4(A0),16(A1)
0000387C  0010      
                    10572   OSQPend_10:
                    10573   ; }
                    10574   ; OS_EXIT_CRITICAL();
0000387E  46DF      10575          dc.w      18143
                    10576   ; *perr = OS_ERR_NONE;
00003880  2043      10577          move.l    D3,A0
00003882  4210      10578          clr.b     (A0)
                    10579   ; return (pmsg);                           /* Return message received                            */
00003884  2004      10580          move.l    D4,D0
00003886  6000 009E 10581          bra       OSQPend_3
                    10582   OSQPend_8:
                    10583   ; }
                    10584   ; OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
0000388A  2052      10585          move.l    (A2),A0
0000388C  0028 0004 10586          or.b      #4,50(A0)
00003890  0032      
                    10587   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00003892  2052      10588          move.l    (A2),A0
00003894  4228 0033 10589          clr.b     51(A0)
                    10590   ; OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
00003898  2052      10591          move.l    (A2),A0
0000389A  216E 000C 10592          move.l    12(A6),46(A0)
0000389E  002E      
                    10593   ; OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
000038A0  2F05      10594          move.l    D5,-(A7)
000038A2  4EB8 10DE 10595          jsr       _OS_EventTaskWait
000038A6  584F      10596          addq.w    #4,A7
                    10597   ; OS_EXIT_CRITICAL();
000038A8  46DF      10598          dc.w      18143
                    10599   ; OS_Sched();                                  /* Find next highest priority task ready to run       */
000038AA  4EB8 15DA 10600          jsr       _OS_Sched
                    10601   ; OS_ENTER_CRITICAL();
000038AE  40E7      10602          dc.w      16615
000038B0  007C      10603          dc.w      124
000038B2  0700      10604          dc.w      1792
                    10605   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
000038B4  2052      10606          move.l    (A2),A0
000038B6  1028 0033 10607          move.b    51(A0),D0
000038BA  C0BC 0000 10608          and.l     #255,D0
000038BE  00FF      
000038C0  0C80 0000 10609          cmp.l     #1,D0
000038C4  0001      
000038C6  6700 002A 10610          beq       OSQPend_16
000038CA  6206      10611          bhi.s     OSQPend_18
000038CC  4A80      10612          tst.l     D0
000038CE  670C      10613          beq.s     OSQPend_14
000038D0  6020      10614          bra.s     OSQPend_16
                    10615   OSQPend_18:
000038D2  0C80 0000 10616          cmp.l     #2,D0
000038D6  0002      
000038D8  670E      10617          beq.s     OSQPend_15
000038DA  6016      10618          bra.s     OSQPend_16
                    10619   OSQPend_14:
                    10620   ; case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
                    10621   ; pmsg =  OSTCBCur->OSTCBMsg;
000038DC  2052      10622          move.l    (A2),A0
000038DE  2828 0024 10623          move.l    36(A0),D4
                    10624   ; *perr =  OS_ERR_NONE;
000038E2  2043      10625          move.l    D3,A0
000038E4  4210      10626          clr.b     (A0)
                    10627   ; break;
000038E6  601C      10628          bra.s     OSQPend_13
                    10629   OSQPend_15:
                    10630   ; case OS_STAT_PEND_ABORT:
                    10631   ; pmsg = (void *)0;
000038E8  4284      10632          clr.l     D4
                    10633   ; *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
000038EA  2043      10634          move.l    D3,A0
000038EC  10BC 000E 10635          move.b    #14,(A0)
                    10636   ; break;
000038F0  6012      10637          bra.s     OSQPend_13
                    10638   OSQPend_16:
                    10639   ; case OS_STAT_PEND_TO:
                    10640   ; default:
                    10641   ; OS_EventTaskRemove(OSTCBCur, pevent);
000038F2  2F05      10642          move.l    D5,-(A7)
000038F4  2F12      10643          move.l    (A2),-(A7)
000038F6  4EB8 1200 10644          jsr       _OS_EventTaskRemove
000038FA  504F      10645          addq.w    #8,A7
                    10646   ; pmsg = (void *)0;
000038FC  4284      10647          clr.l     D4
                    10648   ; *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
000038FE  2043      10649          move.l    D3,A0
00003900  10BC 000A 10650          move.b    #10,(A0)
                    10651   ; break;
                    10652   OSQPend_13:
                    10653   ; }
                    10654   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
00003904  2052      10655          move.l    (A2),A0
00003906  4228 0032 10656          clr.b     50(A0)
                    10657   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
0000390A  2052      10658          move.l    (A2),A0
0000390C  4228 0033 10659          clr.b     51(A0)
                    10660   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
00003910  2052      10661          move.l    (A2),A0
00003912  42A8 001C 10662          clr.l     28(A0)
                    10663   ; #if (OS_EVENT_MULTI_EN > 0u)
                    10664   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
00003916  2052      10665          move.l    (A2),A0
00003918  42A8 0020 10666          clr.l     32(A0)
                    10667   ; #endif
                    10668   ; OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
0000391C  2052      10669          move.l    (A2),A0
0000391E  42A8 0024 10670          clr.l     36(A0)
                    10671   ; OS_EXIT_CRITICAL();
00003922  46DF      10672          dc.w      18143
                    10673   ; return (pmsg);                                    /* Return received message                       */
00003924  2004      10674          move.l    D4,D0
                    10675   OSQPend_3:
00003926  4CDF 043C 10676          movem.l   (A7)+,D2/D3/D4/D5/A2
0000392A  4E5E      10677          unlk      A6
0000392C  4E75      10678          rts
                    10679   ; }
                    10680   ; /*$PAGE*/
                    10681   ; /*
                    10682   ; *********************************************************************************************************
                    10683   ; *                                  ABORT WAITING ON A MESSAGE QUEUE
                    10684   ; *
                    10685   ; * Description: This function aborts & readies any tasks currently waiting on a queue.  This function
                    10686   ; *              should be used to fault-abort the wait on the queue, rather than to normally signal
                    10687   ; *              the queue via OSQPost(), OSQPostFront() or OSQPostOpt().
                    10688   ; *
                    10689   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue.
                    10690   ; *
                    10691   ; *              opt           determines the type of ABORT performed:
                    10692   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    10693   ; *                                                     queue
                    10694   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    10695   ; *                                                     queue
                    10696   ; *
                    10697   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    10698   ; *                            messages are:
                    10699   ; *
                    10700   ; *                            OS_ERR_NONE         No tasks were     waiting on the queue.
                    10701   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the queue was readied
                    10702   ; *                                                and informed of the aborted wait; check return value
                    10703   ; *                                                for the number of tasks whose wait on the queue
                    10704   ; *                                                was aborted.
                    10705   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue.
                    10706   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    10707   ; *
                    10708   ; * Returns    : == 0          if no tasks were waiting on the queue, or upon error.
                    10709   ; *              >  0          if one or more tasks waiting on the queue are now readied and informed.
                    10710   ; *********************************************************************************************************
                    10711   ; */
                    10712   ; #if OS_Q_PEND_ABORT_EN > 0u
                    10713   ; INT8U  OSQPendAbort (OS_EVENT  *pevent,
                    10714   ; INT8U      opt,
                    10715   ; INT8U     *perr)
                    10716   ; {
                    10717   _OSQPendAbort:
0000392E  4E56 0000 10718          link      A6,#0
00003932  48E7 3800 10719          movem.l   D2/D3/D4,-(A7)
00003936  242E 0008 10720          move.l    8(A6),D2
0000393A  282E 0010 10721          move.l    16(A6),D4
                    10722   ; INT8U      nbr_tasks;
                    10723   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    10724   ; OS_CPU_SR  cpu_sr = 0u;
                    10725   ; #endif
                    10726   ; #ifdef OS_SAFETY_CRITICAL
                    10727   ; if (perr == (INT8U *)0) {
                    10728   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10729   ; return (0u);
                    10730   ; }
                    10731   ; #endif
                    10732   ; #if OS_ARG_CHK_EN > 0u
                    10733   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    10734   ; *perr = OS_ERR_PEVENT_NULL;
                    10735   ; return (0u);
                    10736   ; }
                    10737   ; #endif
                    10738   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
0000393E  2042      10739          move.l    D2,A0
00003940  1010      10740          move.b    (A0),D0
00003942  0C00 0002 10741          cmp.b     #2,D0
00003946  670C      10742          beq.s     OSQPendAbort_1
                    10743   ; *perr = OS_ERR_EVENT_TYPE;
00003948  2044      10744          move.l    D4,A0
0000394A  10BC 0001 10745          move.b    #1,(A0)
                    10746   ; return (0u);
0000394E  4200      10747          clr.b     D0
00003950  6000 008C 10748          bra       OSQPendAbort_3
                    10749   OSQPendAbort_1:
                    10750   ; }
                    10751   ; OS_ENTER_CRITICAL();
00003954  40E7      10752          dc.w      16615
00003956  007C      10753          dc.w      124
00003958  0700      10754          dc.w      1792
                    10755   ; if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on queue?        */
0000395A  2042      10756          move.l    D2,A0
0000395C  1028 0008 10757          move.b    8(A0),D0
00003960  6700 0074 10758          beq       OSQPendAbort_4
                    10759   ; nbr_tasks = 0u;
00003964  4203      10760          clr.b     D3
                    10761   ; switch (opt) {
00003966  102E 000F 10762          move.b    15(A6),D0
0000396A  C0BC 0000 10763          and.l     #255,D0
0000396E  00FF      
00003970  0C80 0000 10764          cmp.l     #1,D0
00003974  0001      
00003976  670A      10765          beq.s     OSQPendAbort_8
00003978  6200 0030 10766          bhi       OSQPendAbort_9
0000397C  4A80      10767          tst.l     D0
0000397E  672A      10768          beq.s     OSQPendAbort_9
00003980  6028      10769          bra.s     OSQPendAbort_9
                    10770   OSQPendAbort_8:
                    10771   ; case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                    10772   ; while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on queue    */
                    10773   OSQPendAbort_11:
00003982  2042      10774          move.l    D2,A0
00003984  1028 0008 10775          move.b    8(A0),D0
00003988  671E      10776          beq.s     OSQPendAbort_13
                    10777   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
0000398A  4878 0002 10778          pea       2
0000398E  4878 0004 10779          pea       4
00003992  42A7      10780          clr.l     -(A7)
00003994  2F02      10781          move.l    D2,-(A7)
00003996  4EB8 0FFA 10782          jsr       _OS_EventTaskRdy
0000399A  DEFC 0010 10783          add.w     #16,A7
0000399E  C0BC 0000 10784          and.l     #255,D0
000039A2  00FF      
                    10785   ; nbr_tasks++;
000039A4  5203      10786          addq.b    #1,D3
000039A6  60DA      10787          bra       OSQPendAbort_11
                    10788   OSQPendAbort_13:
                    10789   ; }
                    10790   ; break;
000039A8  601C      10791          bra.s     OSQPendAbort_7
                    10792   OSQPendAbort_9:
                    10793   ; case OS_PEND_OPT_NONE:
                    10794   ; default:                                       /* No,  ready HPT       waiting on queue    */
                    10795   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
000039AA  4878 0002 10796          pea       2
000039AE  4878 0004 10797          pea       4
000039B2  42A7      10798          clr.l     -(A7)
000039B4  2F02      10799          move.l    D2,-(A7)
000039B6  4EB8 0FFA 10800          jsr       _OS_EventTaskRdy
000039BA  DEFC 0010 10801          add.w     #16,A7
000039BE  C0BC 0000 10802          and.l     #255,D0
000039C2  00FF      
                    10803   ; nbr_tasks++;
000039C4  5203      10804          addq.b    #1,D3
                    10805   ; break;
                    10806   OSQPendAbort_7:
                    10807   ; }
                    10808   ; OS_EXIT_CRITICAL();
000039C6  46DF      10809          dc.w      18143
                    10810   ; OS_Sched();                                        /* Find HPT ready to run                    */
000039C8  4EB8 15DA 10811          jsr       _OS_Sched
                    10812   ; *perr = OS_ERR_PEND_ABORT;
000039CC  2044      10813          move.l    D4,A0
000039CE  10BC 000E 10814          move.b    #14,(A0)
                    10815   ; return (nbr_tasks);
000039D2  1003      10816          move.b    D3,D0
000039D4  6008      10817          bra.s     OSQPendAbort_3
                    10818   OSQPendAbort_4:
                    10819   ; }
                    10820   ; OS_EXIT_CRITICAL();
000039D6  46DF      10821          dc.w      18143
                    10822   ; *perr = OS_ERR_NONE;
000039D8  2044      10823          move.l    D4,A0
000039DA  4210      10824          clr.b     (A0)
                    10825   ; return (0u);                                           /* No tasks waiting on queue                */
000039DC  4200      10826          clr.b     D0
                    10827   OSQPendAbort_3:
000039DE  4CDF 001C 10828          movem.l   (A7)+,D2/D3/D4
000039E2  4E5E      10829          unlk      A6
000039E4  4E75      10830          rts
                    10831   ; }
                    10832   ; #endif
                    10833   ; /*$PAGE*/
                    10834   ; /*
                    10835   ; *********************************************************************************************************
                    10836   ; *                                       POST MESSAGE TO A QUEUE
                    10837   ; *
                    10838   ; * Description: This function sends a message to a queue
                    10839   ; *
                    10840   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    10841   ; *
                    10842   ; *              pmsg          is a pointer to the message to send.
                    10843   ; *
                    10844   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    10845   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    10846   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    10847   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    10848   ; *
                    10849   ; * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
                    10850   ; *********************************************************************************************************
                    10851   ; */
                    10852   ; #if OS_Q_POST_EN > 0u
                    10853   ; INT8U  OSQPost (OS_EVENT  *pevent,
                    10854   ; void      *pmsg)
                    10855   ; {
                    10856   _OSQPost:
000039E6  4E56 0000 10857          link      A6,#0
000039EA  48E7 3000 10858          movem.l   D2/D3,-(A7)
000039EE  262E 0008 10859          move.l    8(A6),D3
                    10860   ; OS_Q      *pq;
                    10861   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    10862   ; OS_CPU_SR  cpu_sr = 0u;
                    10863   ; #endif
                    10864   ; #if OS_ARG_CHK_EN > 0u
                    10865   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    10866   ; return (OS_ERR_PEVENT_NULL);
                    10867   ; }
                    10868   ; #endif
                    10869   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
000039F2  2043      10870          move.l    D3,A0
000039F4  1010      10871          move.b    (A0),D0
000039F6  0C00 0002 10872          cmp.b     #2,D0
000039FA  6706      10873          beq.s     OSQPost_1
                    10874   ; return (OS_ERR_EVENT_TYPE);
000039FC  7001      10875          moveq     #1,D0
000039FE  6000 008C 10876          bra       OSQPost_3
                    10877   OSQPost_1:
                    10878   ; }
                    10879   ; OS_ENTER_CRITICAL();
00003A02  40E7      10880          dc.w      16615
00003A04  007C      10881          dc.w      124
00003A06  0700      10882          dc.w      1792
                    10883   ; if (pevent->OSEventGrp != 0u) {                    /* See if any task pending on queue             */
00003A08  2043      10884          move.l    D3,A0
00003A0A  1028 0008 10885          move.b    8(A0),D0
00003A0E  6726      10886          beq.s     OSQPost_4
                    10887   ; /* Ready highest priority task waiting on event */
                    10888   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
00003A10  42A7      10889          clr.l     -(A7)
00003A12  4878 0004 10890          pea       4
00003A16  2F2E 000C 10891          move.l    12(A6),-(A7)
00003A1A  2F03      10892          move.l    D3,-(A7)
00003A1C  4EB8 0FFA 10893          jsr       _OS_EventTaskRdy
00003A20  DEFC 0010 10894          add.w     #16,A7
00003A24  C0BC 0000 10895          and.l     #255,D0
00003A28  00FF      
                    10896   ; OS_EXIT_CRITICAL();
00003A2A  46DF      10897          dc.w      18143
                    10898   ; OS_Sched();                                    /* Find highest priority task ready to run      */
00003A2C  4EB8 15DA 10899          jsr       _OS_Sched
                    10900   ; return (OS_ERR_NONE);
00003A30  4200      10901          clr.b     D0
00003A32  6000 0058 10902          bra       OSQPost_3
                    10903   OSQPost_4:
                    10904   ; }
                    10905   ; pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
00003A36  2043      10906          move.l    D3,A0
00003A38  2428 0002 10907          move.l    2(A0),D2
                    10908   ; if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
00003A3C  2042      10909          move.l    D2,A0
00003A3E  2242      10910          move.l    D2,A1
00003A40  3028 0016 10911          move.w    22(A0),D0
00003A44  B069 0014 10912          cmp.w     20(A1),D0
00003A48  6508      10913          blo.s     OSQPost_6
                    10914   ; OS_EXIT_CRITICAL();
00003A4A  46DF      10915          dc.w      18143
                    10916   ; return (OS_ERR_Q_FULL);
00003A4C  701E      10917          moveq     #30,D0
00003A4E  6000 003C 10918          bra       OSQPost_3
                    10919   OSQPost_6:
                    10920   ; }
                    10921   ; *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
00003A52  2002      10922          move.l    D2,D0
00003A54  0680 0000 10923          add.l     #12,D0
00003A58  000C      
00003A5A  2040      10924          move.l    D0,A0
00003A5C  2250      10925          move.l    (A0),A1
00003A5E  5890      10926          addq.l    #4,(A0)
00003A60  22AE 000C 10927          move.l    12(A6),(A1)
                    10928   ; pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
00003A64  2002      10929          move.l    D2,D0
00003A66  0680 0000 10930          add.l     #22,D0
00003A6A  0016      
00003A6C  2040      10931          move.l    D0,A0
00003A6E  5250      10932          addq.w    #1,(A0)
                    10933   ; if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
00003A70  2042      10934          move.l    D2,A0
00003A72  2242      10935          move.l    D2,A1
00003A74  2028 000C 10936          move.l    12(A0),D0
00003A78  B0A9 0008 10937          cmp.l     8(A1),D0
00003A7C  660A      10938          bne.s     OSQPost_8
                    10939   ; pq->OSQIn = pq->OSQStart;
00003A7E  2042      10940          move.l    D2,A0
00003A80  2242      10941          move.l    D2,A1
00003A82  2368 0004 10942          move.l    4(A0),12(A1)
00003A86  000C      
                    10943   OSQPost_8:
                    10944   ; }
                    10945   ; OS_EXIT_CRITICAL();
00003A88  46DF      10946          dc.w      18143
                    10947   ; return (OS_ERR_NONE);
00003A8A  4200      10948          clr.b     D0
                    10949   OSQPost_3:
00003A8C  4CDF 000C 10950          movem.l   (A7)+,D2/D3
00003A90  4E5E      10951          unlk      A6
00003A92  4E75      10952          rts
                    10953   ; }
                    10954   ; #endif
                    10955   ; /*$PAGE*/
                    10956   ; /*
                    10957   ; *********************************************************************************************************
                    10958   ; *                                POST MESSAGE TO THE FRONT OF A QUEUE
                    10959   ; *
                    10960   ; * Description: This function sends a message to a queue but unlike OSQPost(), the message is posted at
                    10961   ; *              the front instead of the end of the queue.  Using OSQPostFront() allows you to send
                    10962   ; *              'priority' messages.
                    10963   ; *
                    10964   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    10965   ; *
                    10966   ; *              pmsg          is a pointer to the message to send.
                    10967   ; *
                    10968   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    10969   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    10970   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    10971   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    10972   ; *
                    10973   ; * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
                    10974   ; *********************************************************************************************************
                    10975   ; */
                    10976   ; #if OS_Q_POST_FRONT_EN > 0u
                    10977   ; INT8U  OSQPostFront (OS_EVENT  *pevent,
                    10978   ; void      *pmsg)
                    10979   ; {
                    10980   _OSQPostFront:
00003A94  4E56 0000 10981          link      A6,#0
00003A98  48E7 3000 10982          movem.l   D2/D3,-(A7)
00003A9C  262E 0008 10983          move.l    8(A6),D3
                    10984   ; OS_Q      *pq;
                    10985   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    10986   ; OS_CPU_SR  cpu_sr = 0u;
                    10987   ; #endif
                    10988   ; #if OS_ARG_CHK_EN > 0u
                    10989   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    10990   ; return (OS_ERR_PEVENT_NULL);
                    10991   ; }
                    10992   ; #endif
                    10993   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
00003AA0  2043      10994          move.l    D3,A0
00003AA2  1010      10995          move.b    (A0),D0
00003AA4  0C00 0002 10996          cmp.b     #2,D0
00003AA8  6706      10997          beq.s     OSQPostFront_1
                    10998   ; return (OS_ERR_EVENT_TYPE);
00003AAA  7001      10999          moveq     #1,D0
00003AAC  6000 0090 11000          bra       OSQPostFront_3
                    11001   OSQPostFront_1:
                    11002   ; }
                    11003   ; OS_ENTER_CRITICAL();
00003AB0  40E7      11004          dc.w      16615
00003AB2  007C      11005          dc.w      124
00003AB4  0700      11006          dc.w      1792
                    11007   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on queue              */
00003AB6  2043      11008          move.l    D3,A0
00003AB8  1028 0008 11009          move.b    8(A0),D0
00003ABC  6726      11010          beq.s     OSQPostFront_4
                    11011   ; /* Ready highest priority task waiting on event  */
                    11012   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
00003ABE  42A7      11013          clr.l     -(A7)
00003AC0  4878 0004 11014          pea       4
00003AC4  2F2E 000C 11015          move.l    12(A6),-(A7)
00003AC8  2F03      11016          move.l    D3,-(A7)
00003ACA  4EB8 0FFA 11017          jsr       _OS_EventTaskRdy
00003ACE  DEFC 0010 11018          add.w     #16,A7
00003AD2  C0BC 0000 11019          and.l     #255,D0
00003AD6  00FF      
                    11020   ; OS_EXIT_CRITICAL();
00003AD8  46DF      11021          dc.w      18143
                    11022   ; OS_Sched();                                   /* Find highest priority task ready to run       */
00003ADA  4EB8 15DA 11023          jsr       _OS_Sched
                    11024   ; return (OS_ERR_NONE);
00003ADE  4200      11025          clr.b     D0
00003AE0  6000 005C 11026          bra       OSQPostFront_3
                    11027   OSQPostFront_4:
                    11028   ; }
                    11029   ; pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
00003AE4  2043      11030          move.l    D3,A0
00003AE6  2428 0002 11031          move.l    2(A0),D2
                    11032   ; if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
00003AEA  2042      11033          move.l    D2,A0
00003AEC  2242      11034          move.l    D2,A1
00003AEE  3028 0016 11035          move.w    22(A0),D0
00003AF2  B069 0014 11036          cmp.w     20(A1),D0
00003AF6  6508      11037          blo.s     OSQPostFront_6
                    11038   ; OS_EXIT_CRITICAL();
00003AF8  46DF      11039          dc.w      18143
                    11040   ; return (OS_ERR_Q_FULL);
00003AFA  701E      11041          moveq     #30,D0
00003AFC  6000 0040 11042          bra       OSQPostFront_3
                    11043   OSQPostFront_6:
                    11044   ; }
                    11045   ; if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
00003B00  2042      11046          move.l    D2,A0
00003B02  2242      11047          move.l    D2,A1
00003B04  2028 0010 11048          move.l    16(A0),D0
00003B08  B0A9 0004 11049          cmp.l     4(A1),D0
00003B0C  660A      11050          bne.s     OSQPostFront_8
                    11051   ; pq->OSQOut = pq->OSQEnd;
00003B0E  2042      11052          move.l    D2,A0
00003B10  2242      11053          move.l    D2,A1
00003B12  2368 0008 11054          move.l    8(A0),16(A1)
00003B16  0010      
                    11055   OSQPostFront_8:
                    11056   ; }
                    11057   ; pq->OSQOut--;
00003B18  2002      11058          move.l    D2,D0
00003B1A  0680 0000 11059          add.l     #16,D0
00003B1E  0010      
00003B20  2040      11060          move.l    D0,A0
00003B22  5990      11061          subq.l    #4,(A0)
                    11062   ; *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
00003B24  2042      11063          move.l    D2,A0
00003B26  2068 0010 11064          move.l    16(A0),A0
00003B2A  20AE 000C 11065          move.l    12(A6),(A0)
                    11066   ; pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
00003B2E  2002      11067          move.l    D2,D0
00003B30  0680 0000 11068          add.l     #22,D0
00003B34  0016      
00003B36  2040      11069          move.l    D0,A0
00003B38  5250      11070          addq.w    #1,(A0)
                    11071   ; OS_EXIT_CRITICAL();
00003B3A  46DF      11072          dc.w      18143
                    11073   ; return (OS_ERR_NONE);
00003B3C  4200      11074          clr.b     D0
                    11075   OSQPostFront_3:
00003B3E  4CDF 000C 11076          movem.l   (A7)+,D2/D3
00003B42  4E5E      11077          unlk      A6
00003B44  4E75      11078          rts
                    11079   ; }
                    11080   ; #endif
                    11081   ; /*$PAGE*/
                    11082   ; /*
                    11083   ; *********************************************************************************************************
                    11084   ; *                                       POST MESSAGE TO A QUEUE
                    11085   ; *
                    11086   ; * Description: This function sends a message to a queue.  This call has been added to reduce code size
                    11087   ; *              since it can replace both OSQPost() and OSQPostFront().  Also, this function adds the
                    11088   ; *              capability to broadcast a message to ALL tasks waiting on the message queue.
                    11089   ; *
                    11090   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11091   ; *
                    11092   ; *              pmsg          is a pointer to the message to send.
                    11093   ; *
                    11094   ; *              opt           determines the type of POST performed:
                    11095   ; *                            OS_POST_OPT_NONE         POST to a single waiting task
                    11096   ; *                                                     (Identical to OSQPost())
                    11097   ; *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the queue
                    11098   ; *                            OS_POST_OPT_FRONT        POST as LIFO (Simulates OSQPostFront())
                    11099   ; *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
                    11100   ; *
                    11101   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    11102   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    11103   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    11104   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    11105   ; *
                    11106   ; * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
                    11107   ; *              interrupt disable time is proportional to the number of tasks waiting on the queue.
                    11108   ; *********************************************************************************************************
                    11109   ; */
                    11110   ; #if OS_Q_POST_OPT_EN > 0u
                    11111   ; INT8U  OSQPostOpt (OS_EVENT  *pevent,
                    11112   ; void      *pmsg,
                    11113   ; INT8U      opt)
                    11114   ; {
                    11115   _OSQPostOpt:
00003B46  4E56 0000 11116          link      A6,#0
00003B4A  48E7 3C00 11117          movem.l   D2/D3/D4/D5,-(A7)
00003B4E  262E 0008 11118          move.l    8(A6),D3
00003B52  282E 000C 11119          move.l    12(A6),D4
00003B56  1A2E 0013 11120          move.b    19(A6),D5
00003B5A  CABC 0000 11121          and.l     #255,D5
00003B5E  00FF      
                    11122   ; OS_Q      *pq;
                    11123   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11124   ; OS_CPU_SR  cpu_sr = 0u;
                    11125   ; #endif
                    11126   ; #if OS_ARG_CHK_EN > 0u
                    11127   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11128   ; return (OS_ERR_PEVENT_NULL);
                    11129   ; }
                    11130   ; #endif
                    11131   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
00003B60  2043      11132          move.l    D3,A0
00003B62  1010      11133          move.b    (A0),D0
00003B64  0C00 0002 11134          cmp.b     #2,D0
00003B68  6706      11135          beq.s     OSQPostOpt_1
                    11136   ; return (OS_ERR_EVENT_TYPE);
00003B6A  7001      11137          moveq     #1,D0
00003B6C  6000 00F6 11138          bra       OSQPostOpt_3
                    11139   OSQPostOpt_1:
                    11140   ; }
                    11141   ; OS_ENTER_CRITICAL();
00003B70  40E7      11142          dc.w      16615
00003B72  007C      11143          dc.w      124
00003B74  0700      11144          dc.w      1792
                    11145   ; if (pevent->OSEventGrp != 0x00u) {                /* See if any task pending on queue              */
00003B76  2043      11146          move.l    D3,A0
00003B78  1028 0008 11147          move.b    8(A0),D0
00003B7C  6700 005A 11148          beq       OSQPostOpt_4
                    11149   ; if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
00003B80  1005      11150          move.b    D5,D0
00003B82  C03C 0001 11151          and.b     #1,D0
00003B86  6724      11152          beq.s     OSQPostOpt_6
                    11153   ; while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on queue       */
                    11154   OSQPostOpt_8:
00003B88  2043      11155          move.l    D3,A0
00003B8A  1028 0008 11156          move.b    8(A0),D0
00003B8E  671A      11157          beq.s     OSQPostOpt_10
                    11158   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
00003B90  42A7      11159          clr.l     -(A7)
00003B92  4878 0004 11160          pea       4
00003B96  2F04      11161          move.l    D4,-(A7)
00003B98  2F03      11162          move.l    D3,-(A7)
00003B9A  4EB8 0FFA 11163          jsr       _OS_EventTaskRdy
00003B9E  DEFC 0010 11164          add.w     #16,A7
00003BA2  C0BC 0000 11165          and.l     #255,D0
00003BA6  00FF      
00003BA8  60DE      11166          bra       OSQPostOpt_8
                    11167   OSQPostOpt_10:
00003BAA  6018      11168          bra.s     OSQPostOpt_7
                    11169   OSQPostOpt_6:
                    11170   ; }
                    11171   ; } else {                                      /* No,  Post to HPT waiting on queue             */
                    11172   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
00003BAC  42A7      11173          clr.l     -(A7)
00003BAE  4878 0004 11174          pea       4
00003BB2  2F04      11175          move.l    D4,-(A7)
00003BB4  2F03      11176          move.l    D3,-(A7)
00003BB6  4EB8 0FFA 11177          jsr       _OS_EventTaskRdy
00003BBA  DEFC 0010 11178          add.w     #16,A7
00003BBE  C0BC 0000 11179          and.l     #255,D0
00003BC2  00FF      
                    11180   OSQPostOpt_7:
                    11181   ; }
                    11182   ; OS_EXIT_CRITICAL();
00003BC4  46DF      11183          dc.w      18143
                    11184   ; if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
00003BC6  1005      11185          move.b    D5,D0
00003BC8  C03C 0004 11186          and.b     #4,D0
00003BCC  6604      11187          bne.s     OSQPostOpt_11
                    11188   ; OS_Sched();                               /* Find highest priority task ready to run       */
00003BCE  4EB8 15DA 11189          jsr       _OS_Sched
                    11190   OSQPostOpt_11:
                    11191   ; }
                    11192   ; return (OS_ERR_NONE);
00003BD2  4200      11193          clr.b     D0
00003BD4  6000 008E 11194          bra       OSQPostOpt_3
                    11195   OSQPostOpt_4:
                    11196   ; }
                    11197   ; pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
00003BD8  2043      11198          move.l    D3,A0
00003BDA  2428 0002 11199          move.l    2(A0),D2
                    11200   ; if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
00003BDE  2042      11201          move.l    D2,A0
00003BE0  2242      11202          move.l    D2,A1
00003BE2  3028 0016 11203          move.w    22(A0),D0
00003BE6  B069 0014 11204          cmp.w     20(A1),D0
00003BEA  6508      11205          blo.s     OSQPostOpt_13
                    11206   ; OS_EXIT_CRITICAL();
00003BEC  46DF      11207          dc.w      18143
                    11208   ; return (OS_ERR_Q_FULL);
00003BEE  701E      11209          moveq     #30,D0
00003BF0  6000 0072 11210          bra       OSQPostOpt_3
                    11211   OSQPostOpt_13:
                    11212   ; }
                    11213   ; if ((opt & OS_POST_OPT_FRONT) != 0x00u) {         /* Do we post to the FRONT of the queue?         */
00003BF4  1005      11214          move.b    D5,D0
00003BF6  C03C 0002 11215          and.b     #2,D0
00003BFA  6700 0030 11216          beq       OSQPostOpt_15
                    11217   ; if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
00003BFE  2042      11218          move.l    D2,A0
00003C00  2242      11219          move.l    D2,A1
00003C02  2028 0010 11220          move.l    16(A0),D0
00003C06  B0A9 0004 11221          cmp.l     4(A1),D0
00003C0A  660A      11222          bne.s     OSQPostOpt_17
                    11223   ; pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
00003C0C  2042      11224          move.l    D2,A0
00003C0E  2242      11225          move.l    D2,A1
00003C10  2368 0008 11226          move.l    8(A0),16(A1)
00003C14  0010      
                    11227   OSQPostOpt_17:
                    11228   ; }
                    11229   ; pq->OSQOut--;
00003C16  2002      11230          move.l    D2,D0
00003C18  0680 0000 11231          add.l     #16,D0
00003C1C  0010      
00003C1E  2040      11232          move.l    D0,A0
00003C20  5990      11233          subq.l    #4,(A0)
                    11234   ; *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
00003C22  2042      11235          move.l    D2,A0
00003C24  2068 0010 11236          move.l    16(A0),A0
00003C28  2084      11237          move.l    D4,(A0)
00003C2A  6028      11238          bra.s     OSQPostOpt_19
                    11239   OSQPostOpt_15:
                    11240   ; } else {                                          /* No,  Post as FIFO                             */
                    11241   ; *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
00003C2C  2002      11242          move.l    D2,D0
00003C2E  0680 0000 11243          add.l     #12,D0
00003C32  000C      
00003C34  2040      11244          move.l    D0,A0
00003C36  2250      11245          move.l    (A0),A1
00003C38  5890      11246          addq.l    #4,(A0)
00003C3A  2284      11247          move.l    D4,(A1)
                    11248   ; if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
00003C3C  2042      11249          move.l    D2,A0
00003C3E  2242      11250          move.l    D2,A1
00003C40  2028 000C 11251          move.l    12(A0),D0
00003C44  B0A9 0008 11252          cmp.l     8(A1),D0
00003C48  660A      11253          bne.s     OSQPostOpt_19
                    11254   ; pq->OSQIn = pq->OSQStart;
00003C4A  2042      11255          move.l    D2,A0
00003C4C  2242      11256          move.l    D2,A1
00003C4E  2368 0004 11257          move.l    4(A0),12(A1)
00003C52  000C      
                    11258   OSQPostOpt_19:
                    11259   ; }
                    11260   ; }
                    11261   ; pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
00003C54  2002      11262          move.l    D2,D0
00003C56  0680 0000 11263          add.l     #22,D0
00003C5A  0016      
00003C5C  2040      11264          move.l    D0,A0
00003C5E  5250      11265          addq.w    #1,(A0)
                    11266   ; OS_EXIT_CRITICAL();
00003C60  46DF      11267          dc.w      18143
                    11268   ; return (OS_ERR_NONE);
00003C62  4200      11269          clr.b     D0
                    11270   OSQPostOpt_3:
00003C64  4CDF 003C 11271          movem.l   (A7)+,D2/D3/D4/D5
00003C68  4E5E      11272          unlk      A6
00003C6A  4E75      11273          rts
                    11274   ; }
                    11275   ; #endif
                    11276   ; /*$PAGE*/
                    11277   ; /*
                    11278   ; *********************************************************************************************************
                    11279   ; *                                        QUERY A MESSAGE QUEUE
                    11280   ; *
                    11281   ; * Description: This function obtains information about a message queue.
                    11282   ; *
                    11283   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11284   ; *
                    11285   ; *              p_q_data      is a pointer to a structure that will contain information about the message
                    11286   ; *                            queue.
                    11287   ; *
                    11288   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    11289   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non queue.
                    11290   ; *              OS_ERR_PEVENT_NULL  If 'pevent'   is a NULL pointer
                    11291   ; *              OS_ERR_PDATA_NULL   If 'p_q_data' is a NULL pointer
                    11292   ; *********************************************************************************************************
                    11293   ; */
                    11294   ; #if OS_Q_QUERY_EN > 0u
                    11295   ; INT8U  OSQQuery (OS_EVENT  *pevent,
                    11296   ; OS_Q_DATA *p_q_data)
                    11297   ; {
                    11298   _OSQQuery:
00003C6C  4E56 FFF8 11299          link      A6,#-8
00003C70  48E7 3C00 11300          movem.l   D2/D3/D4/D5,-(A7)
00003C74  242E 000C 11301          move.l    12(A6),D2
00003C78  282E 0008 11302          move.l    8(A6),D4
                    11303   ; OS_Q       *pq;
                    11304   ; INT8U       i;
                    11305   ; OS_PRIO    *psrc;
                    11306   ; OS_PRIO    *pdest;
                    11307   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    11308   ; OS_CPU_SR   cpu_sr = 0u;
                    11309   ; #endif
                    11310   ; #if OS_ARG_CHK_EN > 0u
                    11311   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    11312   ; return (OS_ERR_PEVENT_NULL);
                    11313   ; }
                    11314   ; if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
                    11315   ; return (OS_ERR_PDATA_NULL);
                    11316   ; }
                    11317   ; #endif
                    11318   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
00003C7C  2044      11319          move.l    D4,A0
00003C7E  1010      11320          move.b    (A0),D0
00003C80  0C00 0002 11321          cmp.b     #2,D0
00003C84  6706      11322          beq.s     OSQQuery_1
                    11323   ; return (OS_ERR_EVENT_TYPE);
00003C86  7001      11324          moveq     #1,D0
00003C88  6000 007A 11325          bra       OSQQuery_3
                    11326   OSQQuery_1:
                    11327   ; }
                    11328   ; OS_ENTER_CRITICAL();
00003C8C  40E7      11329          dc.w      16615
00003C8E  007C      11330          dc.w      124
00003C90  0700      11331          dc.w      1792
                    11332   ; p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
00003C92  2044      11333          move.l    D4,A0
00003C94  2242      11334          move.l    D2,A1
00003C96  1368 0008 11335          move.b    8(A0),16(A1)
00003C9A  0010      
                    11336   ; psrc                 = &pevent->OSEventTbl[0];
00003C9C  700A      11337          moveq     #10,D0
00003C9E  D084      11338          add.l     D4,D0
00003CA0  2D40 FFF8 11339          move.l    D0,-8(A6)
                    11340   ; pdest                = &p_q_data->OSEventTbl[0];
00003CA4  7008      11341          moveq     #8,D0
00003CA6  D082      11342          add.l     D2,D0
00003CA8  2D40 FFFC 11343          move.l    D0,-4(A6)
                    11344   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
00003CAC  4205      11345          clr.b     D5
                    11346   OSQQuery_4:
00003CAE  0C05 0008 11347          cmp.b     #8,D5
00003CB2  6416      11348          bhs.s     OSQQuery_6
                    11349   ; *pdest++ = *psrc++;
00003CB4  206E FFF8 11350          move.l    -8(A6),A0
00003CB8  52AE FFF8 11351          addq.l    #1,-8(A6)
00003CBC  226E FFFC 11352          move.l    -4(A6),A1
00003CC0  52AE FFFC 11353          addq.l    #1,-4(A6)
00003CC4  1290      11354          move.b    (A0),(A1)
00003CC6  5205      11355          addq.b    #1,D5
00003CC8  60E4      11356          bra       OSQQuery_4
                    11357   OSQQuery_6:
                    11358   ; }
                    11359   ; pq = (OS_Q *)pevent->OSEventPtr;
00003CCA  2044      11360          move.l    D4,A0
00003CCC  2628 0002 11361          move.l    2(A0),D3
                    11362   ; if (pq->OSQEntries > 0u) {
00003CD0  2043      11363          move.l    D3,A0
00003CD2  3028 0016 11364          move.w    22(A0),D0
00003CD6  0C40 0000 11365          cmp.w     #0,D0
00003CDA  630C      11366          bls.s     OSQQuery_7
                    11367   ; p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
00003CDC  2043      11368          move.l    D3,A0
00003CDE  2068 0010 11369          move.l    16(A0),A0
00003CE2  2242      11370          move.l    D2,A1
00003CE4  2290      11371          move.l    (A0),(A1)
00003CE6  6004      11372          bra.s     OSQQuery_8
                    11373   OSQQuery_7:
                    11374   ; } else {
                    11375   ; p_q_data->OSMsg = (void *)0;
00003CE8  2042      11376          move.l    D2,A0
00003CEA  4290      11377          clr.l     (A0)
                    11378   OSQQuery_8:
                    11379   ; }
                    11380   ; p_q_data->OSNMsgs = pq->OSQEntries;
00003CEC  2043      11381          move.l    D3,A0
00003CEE  2242      11382          move.l    D2,A1
00003CF0  3368 0016 11383          move.w    22(A0),4(A1)
00003CF4  0004      
                    11384   ; p_q_data->OSQSize = pq->OSQSize;
00003CF6  2043      11385          move.l    D3,A0
00003CF8  2242      11386          move.l    D2,A1
00003CFA  3368 0014 11387          move.w    20(A0),6(A1)
00003CFE  0006      
                    11388   ; OS_EXIT_CRITICAL();
00003D00  46DF      11389          dc.w      18143
                    11390   ; return (OS_ERR_NONE);
00003D02  4200      11391          clr.b     D0
                    11392   OSQQuery_3:
00003D04  4CDF 003C 11393          movem.l   (A7)+,D2/D3/D4/D5
00003D08  4E5E      11394          unlk      A6
00003D0A  4E75      11395          rts
                    11396   ; }
                    11397   ; #endif                                                 /* OS_Q_QUERY_EN                                */
                    11398   ; /*$PAGE*/
                    11399   ; /*
                    11400   ; *********************************************************************************************************
                    11401   ; *                                     QUEUE MODULE INITIALIZATION
                    11402   ; *
                    11403   ; * Description : This function is called by uC/OS-II to initialize the message queue module.  Your
                    11404   ; *               application MUST NOT call this function.
                    11405   ; *
                    11406   ; * Arguments   :  none
                    11407   ; *
                    11408   ; * Returns     : none
                    11409   ; *
                    11410   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    11411   ; *********************************************************************************************************
                    11412   ; */
                    11413   ; void  OS_QInit (void)
                    11414   ; {
                    11415   _OS_QInit:
00003D0C  4E56 FFF8 11416          link      A6,#-8
00003D10  48E7 3020 11417          movem.l   D2/D3/A2,-(A7)
00003D14  45F9 0800 11418          lea       _OSQTbl.L,A2
00003D18  0D1C      
                    11419   ; #if OS_MAX_QS == 1u
                    11420   ; OSQFreeList         = &OSQTbl[0];                /* Only ONE queue!                                */
                    11421   ; OSQFreeList->OSQPtr = (OS_Q *)0;
                    11422   ; #endif
                    11423   ; #if OS_MAX_QS >= 2u
                    11424   ; INT16U   ix;
                    11425   ; INT16U   ix_next;
                    11426   ; OS_Q    *pq1;
                    11427   ; OS_Q    *pq2;
                    11428   ; OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
00003D1A  4878 0060 11429          pea       96
00003D1E  2F0A      11430          move.l    A2,-(A7)
00003D20  4EB8 158E 11431          jsr       _OS_MemClr
00003D24  504F      11432          addq.w    #8,A7
                    11433   ; for (ix = 0u; ix < (OS_MAX_QS - 1u); ix++) {     /* Init. list of free QUEUE control blocks        */
00003D26  4242      11434          clr.w     D2
                    11435   OS_QInit_1:
00003D28  0C42 0003 11436          cmp.w     #3,D2
00003D2C  6400 003C 11437          bhs       OS_QInit_3
                    11438   ; ix_next = ix + 1u;
00003D30  3002      11439          move.w    D2,D0
00003D32  5240      11440          addq.w    #1,D0
00003D34  3D40 FFFA 11441          move.w    D0,-6(A6)
                    11442   ; pq1 = &OSQTbl[ix];
00003D38  200A      11443          move.l    A2,D0
00003D3A  C4BC 0000 11444          and.l     #65535,D2
00003D3E  FFFF      
00003D40  2202      11445          move.l    D2,D1
00003D42  C3FC 0018 11446          muls      #24,D1
00003D46  D081      11447          add.l     D1,D0
00003D48  2600      11448          move.l    D0,D3
                    11449   ; pq2 = &OSQTbl[ix_next];
00003D4A  200A      11450          move.l    A2,D0
00003D4C  322E FFFA 11451          move.w    -6(A6),D1
00003D50  C2BC 0000 11452          and.l     #65535,D1
00003D54  FFFF      
00003D56  C3FC 0018 11453          muls      #24,D1
00003D5A  D081      11454          add.l     D1,D0
00003D5C  2D40 FFFC 11455          move.l    D0,-4(A6)
                    11456   ; pq1->OSQPtr = pq2;
00003D60  2043      11457          move.l    D3,A0
00003D62  20AE FFFC 11458          move.l    -4(A6),(A0)
00003D66  5242      11459          addq.w    #1,D2
00003D68  60BE      11460          bra       OS_QInit_1
                    11461   OS_QInit_3:
                    11462   ; }
                    11463   ; pq1         = &OSQTbl[ix];
00003D6A  200A      11464          move.l    A2,D0
00003D6C  C4BC 0000 11465          and.l     #65535,D2
00003D70  FFFF      
00003D72  2202      11466          move.l    D2,D1
00003D74  C3FC 0018 11467          muls      #24,D1
00003D78  D081      11468          add.l     D1,D0
00003D7A  2600      11469          move.l    D0,D3
                    11470   ; pq1->OSQPtr = (OS_Q *)0;
00003D7C  2043      11471          move.l    D3,A0
00003D7E  4290      11472          clr.l     (A0)
                    11473   ; OSQFreeList = &OSQTbl[0];
00003D80  23CA 0800 11474          move.l    A2,_OSQFreeList.L
00003D84  0D18      
00003D86  4CDF 040C 11475          movem.l   (A7)+,D2/D3/A2
00003D8A  4E5E      11476          unlk      A6
00003D8C  4E75      11477          rts
                    11478   ; /*
                    11479   ; *********************************************************************************************************
                    11480   ; *                                                uC/OS-II
                    11481   ; *                                          The Real-Time Kernel
                    11482   ; *                                          SEMAPHORE MANAGEMENT
                    11483   ; *
                    11484   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    11485   ; *                                           All Rights Reserved
                    11486   ; *
                    11487   ; * File    : OS_SEM.C
                    11488   ; * By      : Jean J. Labrosse
                    11489   ; * Version : V2.92.07
                    11490   ; *
                    11491   ; * LICENSING TERMS:
                    11492   ; * ---------------
                    11493   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    11494   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    11495   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    11496   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    11497   ; * licensing fee.
                    11498   ; *********************************************************************************************************
                    11499   ; */
                    11500   ; #define  MICRIUM_SOURCE
                    11501   ; #ifndef  OS_MASTER_FILE
                    11502   ; #include <ucos_ii.h>
                    11503   ; #endif
                    11504   ; #if OS_SEM_EN > 0u
                    11505   ; /*$PAGE*/
                    11506   ; /*
                    11507   ; *********************************************************************************************************
                    11508   ; *                                          ACCEPT SEMAPHORE
                    11509   ; *
                    11510   ; * Description: This function checks the semaphore to see if a resource is available or, if an event
                    11511   ; *              occurred.  Unlike OSSemPend(), OSSemAccept() does not suspend the calling task if the
                    11512   ; *              resource is not available or the event did not occur.
                    11513   ; *
                    11514   ; * Arguments  : pevent     is a pointer to the event control block
                    11515   ; *
                    11516   ; * Returns    : >  0       if the resource is available or the event did not occur the semaphore is
                    11517   ; *                         decremented to obtain the resource.
                    11518   ; *              == 0       if the resource is not available or the event did not occur or,
                    11519   ; *                         if 'pevent' is a NULL pointer or,
                    11520   ; *                         if you didn't pass a pointer to a semaphore
                    11521   ; *********************************************************************************************************
                    11522   ; */
                    11523   ; #if OS_SEM_ACCEPT_EN > 0u
                    11524   ; INT16U  OSSemAccept (OS_EVENT *pevent)
                    11525   ; {
                    11526   _OSSemAccept:
00003D8E  4E56 0000 11527          link      A6,#0
00003D92  48E7 3000 11528          movem.l   D2/D3,-(A7)
00003D96  262E 0008 11529          move.l    8(A6),D3
                    11530   ; INT16U     cnt;
                    11531   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11532   ; OS_CPU_SR  cpu_sr = 0u;
                    11533   ; #endif
                    11534   ; #if OS_ARG_CHK_EN > 0u
                    11535   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11536   ; return (0u);
                    11537   ; }
                    11538   ; #endif
                    11539   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00003D9A  2043      11540          move.l    D3,A0
00003D9C  1010      11541          move.b    (A0),D0
00003D9E  0C00 0003 11542          cmp.b     #3,D0
00003DA2  6704      11543          beq.s     OSSemAccept_1
                    11544   ; return (0u);
00003DA4  4240      11545          clr.w     D0
00003DA6  601E      11546          bra.s     OSSemAccept_3
                    11547   OSSemAccept_1:
                    11548   ; }
                    11549   ; OS_ENTER_CRITICAL();
00003DA8  40E7      11550          dc.w      16615
00003DAA  007C      11551          dc.w      124
00003DAC  0700      11552          dc.w      1792
                    11553   ; cnt = pevent->OSEventCnt;
00003DAE  2043      11554          move.l    D3,A0
00003DB0  3428 0006 11555          move.w    6(A0),D2
                    11556   ; if (cnt > 0u) {                                   /* See if resource is available                  */
00003DB4  0C42 0000 11557          cmp.w     #0,D2
00003DB8  6308      11558          bls.s     OSSemAccept_4
                    11559   ; pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
00003DBA  2003      11560          move.l    D3,D0
00003DBC  5C80      11561          addq.l    #6,D0
00003DBE  2040      11562          move.l    D0,A0
00003DC0  5350      11563          subq.w    #1,(A0)
                    11564   OSSemAccept_4:
                    11565   ; }
                    11566   ; OS_EXIT_CRITICAL();
00003DC2  46DF      11567          dc.w      18143
                    11568   ; return (cnt);                                     /* Return semaphore count                        */
00003DC4  3002      11569          move.w    D2,D0
                    11570   OSSemAccept_3:
00003DC6  4CDF 000C 11571          movem.l   (A7)+,D2/D3
00003DCA  4E5E      11572          unlk      A6
00003DCC  4E75      11573          rts
                    11574   ; }
                    11575   ; #endif
                    11576   ; /*$PAGE*/
                    11577   ; /*
                    11578   ; *********************************************************************************************************
                    11579   ; *                                         CREATE A SEMAPHORE
                    11580   ; *
                    11581   ; * Description: This function creates a semaphore.
                    11582   ; *
                    11583   ; * Arguments  : cnt           is the initial value for the semaphore.  If the value is 0, no resource is
                    11584   ; *                            available (or no event has occurred).  You initialize the semaphore to a
                    11585   ; *                            non-zero value to specify how many resources are available (e.g. if you have
                    11586   ; *                            10 resources, you would initialize the semaphore to 10).
                    11587   ; *
                    11588   ; * Returns    : != (void *)0  is a pointer to the event control block (OS_EVENT) associated with the
                    11589   ; *                            created semaphore
                    11590   ; *              == (void *)0  if no event control blocks were available
                    11591   ; *********************************************************************************************************
                    11592   ; */
                    11593   ; OS_EVENT  *OSSemCreate (INT16U cnt)
                    11594   ; {
                    11595   _OSSemCreate:
00003DCE  4E56 0000 11596          link      A6,#0
00003DD2  48E7 2020 11597          movem.l   D2/A2,-(A7)
00003DD6  45F9 0800 11598          lea       _OSEventFreeList.L,A2
00003DDA  00E2      
                    11599   ; OS_EVENT  *pevent;
                    11600   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    11601   ; OS_CPU_SR  cpu_sr = 0u;
                    11602   ; #endif
                    11603   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    11604   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    11605   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    11606   ; return ((OS_EVENT *)0);
                    11607   ; }
                    11608   ; #endif
                    11609   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00003DDC  1039 0800 11610          move.b    _OSIntNesting.L,D0
00003DE0  030E      
00003DE2  0C00 0000 11611          cmp.b     #0,D0
00003DE6  6306      11612          bls.s     OSSemCreate_1
                    11613   ; return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
00003DE8  4280      11614          clr.l     D0
00003DEA  6000 0044 11615          bra       OSSemCreate_3
                    11616   OSSemCreate_1:
                    11617   ; }
                    11618   ; OS_ENTER_CRITICAL();
00003DEE  40E7      11619          dc.w      16615
00003DF0  007C      11620          dc.w      124
00003DF2  0700      11621          dc.w      1792
                    11622   ; pevent = OSEventFreeList;                              /* Get next free event control block        */
00003DF4  2412      11623          move.l    (A2),D2
                    11624   ; if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
00003DF6  2012      11625          move.l    (A2),D0
00003DF8  6706      11626          beq.s     OSSemCreate_4
                    11627   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
00003DFA  2052      11628          move.l    (A2),A0
00003DFC  24A8 0002 11629          move.l    2(A0),(A2)
                    11630   OSSemCreate_4:
                    11631   ; }
                    11632   ; OS_EXIT_CRITICAL();
00003E00  46DF      11633          dc.w      18143
                    11634   ; if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
00003E02  4A82      11635          tst.l     D2
00003E04  6728      11636          beq.s     OSSemCreate_6
                    11637   ; pevent->OSEventType    = OS_EVENT_TYPE_SEM;
00003E06  2042      11638          move.l    D2,A0
00003E08  10BC 0003 11639          move.b    #3,(A0)
                    11640   ; pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
00003E0C  2042      11641          move.l    D2,A0
00003E0E  316E 000A 11642          move.w    10(A6),6(A0)
00003E12  0006      
                    11643   ; pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
00003E14  2042      11644          move.l    D2,A0
00003E16  42A8 0002 11645          clr.l     2(A0)
                    11646   ; #if OS_EVENT_NAME_EN > 0u
                    11647   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003E1A  41F9 0000 11648          lea       @ucos_ii_1.L,A0
00003E1E  708C      
00003E20  2242      11649          move.l    D2,A1
00003E22  2348 0012 11650          move.l    A0,18(A1)
                    11651   ; #endif
                    11652   ; OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
00003E26  2F02      11653          move.l    D2,-(A7)
00003E28  4EB8 12C2 11654          jsr       _OS_EventWaitListInit
00003E2C  584F      11655          addq.w    #4,A7
                    11656   OSSemCreate_6:
                    11657   ; }
                    11658   ; return (pevent);
00003E2E  2002      11659          move.l    D2,D0
                    11660   OSSemCreate_3:
00003E30  4CDF 0404 11661          movem.l   (A7)+,D2/A2
00003E34  4E5E      11662          unlk      A6
00003E36  4E75      11663          rts
                    11664   ; }
                    11665   ; /*$PAGE*/
                    11666   ; /*
                    11667   ; *********************************************************************************************************
                    11668   ; *                                         DELETE A SEMAPHORE
                    11669   ; *
                    11670   ; * Description: This function deletes a semaphore and readies all tasks pending on the semaphore.
                    11671   ; *
                    11672   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    11673   ; *                            semaphore.
                    11674   ; *
                    11675   ; *              opt           determines delete options as follows:
                    11676   ; *                            opt == OS_DEL_NO_PEND   Delete semaphore ONLY if no task pending
                    11677   ; *                            opt == OS_DEL_ALWAYS    Deletes the semaphore even if tasks are waiting.
                    11678   ; *                                                    In this case, all the tasks pending will be readied.
                    11679   ; *
                    11680   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    11681   ; *                            OS_ERR_NONE             The call was successful and the semaphore was deleted
                    11682   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the semaphore from an ISR
                    11683   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    11684   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the semaphore
                    11685   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a semaphore
                    11686   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    11687   ; *
                    11688   ; * Returns    : pevent        upon error
                    11689   ; *              (OS_EVENT *)0 if the semaphore was successfully deleted.
                    11690   ; *
                    11691   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    11692   ; *                 the semaphore MUST check the return code of OSSemPend().
                    11693   ; *              2) OSSemAccept() callers will not know that the intended semaphore has been deleted unless
                    11694   ; *                 they check 'pevent' to see that it's a NULL pointer.
                    11695   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    11696   ; *                 time is directly proportional to the number of tasks waiting on the semaphore.
                    11697   ; *              4) Because ALL tasks pending on the semaphore will be readied, you MUST be careful in
                    11698   ; *                 applications where the semaphore is used for mutual exclusion because the resource(s)
                    11699   ; *                 will no longer be guarded by the semaphore.
                    11700   ; *              5) All tasks that were waiting for the semaphore will be readied and returned an 
                    11701   ; *                 OS_ERR_PEND_ABORT if OSSemDel() was called with OS_DEL_ALWAYS
                    11702   ; *********************************************************************************************************
                    11703   ; */
                    11704   ; #if OS_SEM_DEL_EN > 0u
                    11705   ; OS_EVENT  *OSSemDel (OS_EVENT  *pevent,
                    11706   ; INT8U      opt,
                    11707   ; INT8U     *perr)
                    11708   ; {
                    11709   _OSSemDel:
00003E38  4E56 0000 11710          link      A6,#0
00003E3C  48E7 3C20 11711          movem.l   D2/D3/D4/D5/A2,-(A7)
00003E40  242E 0008 11712          move.l    8(A6),D2
00003E44  262E 0010 11713          move.l    16(A6),D3
00003E48  45F9 0800 11714          lea       _OSEventFreeList.L,A2
00003E4C  00E2      
                    11715   ; BOOLEAN    tasks_waiting;
                    11716   ; OS_EVENT  *pevent_return;
                    11717   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    11718   ; OS_CPU_SR  cpu_sr = 0u;
                    11719   ; #endif
                    11720   ; #ifdef OS_SAFETY_CRITICAL
                    11721   ; if (perr == (INT8U *)0) {
                    11722   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    11723   ; return ((OS_EVENT *)0);
                    11724   ; }
                    11725   ; #endif
                    11726   ; #if OS_ARG_CHK_EN > 0u
                    11727   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    11728   ; *perr = OS_ERR_PEVENT_NULL;
                    11729   ; return (pevent);
                    11730   ; }
                    11731   ; #endif
                    11732   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
00003E4E  2042      11733          move.l    D2,A0
00003E50  1010      11734          move.b    (A0),D0
00003E52  0C00 0003 11735          cmp.b     #3,D0
00003E56  670C      11736          beq.s     OSSemDel_1
                    11737   ; *perr = OS_ERR_EVENT_TYPE;
00003E58  2043      11738          move.l    D3,A0
00003E5A  10BC 0001 11739          move.b    #1,(A0)
                    11740   ; return (pevent);
00003E5E  2002      11741          move.l    D2,D0
00003E60  6000 00EA 11742          bra       OSSemDel_3
                    11743   OSSemDel_1:
                    11744   ; }
                    11745   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00003E64  1039 0800 11746          move.b    _OSIntNesting.L,D0
00003E68  030E      
00003E6A  0C00 0000 11747          cmp.b     #0,D0
00003E6E  630C      11748          bls.s     OSSemDel_4
                    11749   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
00003E70  2043      11750          move.l    D3,A0
00003E72  10BC 000F 11751          move.b    #15,(A0)
                    11752   ; return (pevent);
00003E76  2002      11753          move.l    D2,D0
00003E78  6000 00D2 11754          bra       OSSemDel_3
                    11755   OSSemDel_4:
                    11756   ; }
                    11757   ; OS_ENTER_CRITICAL();
00003E7C  40E7      11758          dc.w      16615
00003E7E  007C      11759          dc.w      124
00003E80  0700      11760          dc.w      1792
                    11761   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on semaphore    */
00003E82  2042      11762          move.l    D2,A0
00003E84  1028 0008 11763          move.b    8(A0),D0
00003E88  6704      11764          beq.s     OSSemDel_6
                    11765   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
00003E8A  7A01      11766          moveq     #1,D5
00003E8C  6002      11767          bra.s     OSSemDel_7
                    11768   OSSemDel_6:
                    11769   ; } else {
                    11770   ; tasks_waiting = OS_FALSE;                          /* No                                       */
00003E8E  4205      11771          clr.b     D5
                    11772   OSSemDel_7:
                    11773   ; }
                    11774   ; switch (opt) {
00003E90  102E 000F 11775          move.b    15(A6),D0
00003E94  C0BC 0000 11776          and.l     #255,D0
00003E98  00FF      
00003E9A  0C80 0000 11777          cmp.l     #1,D0
00003E9E  0001      
00003EA0  6700 0048 11778          beq       OSSemDel_11
00003EA4  6200 009A 11779          bhi       OSSemDel_8
00003EA8  4A80      11780          tst.l     D0
00003EAA  6704      11781          beq.s     OSSemDel_10
00003EAC  6000 0092 11782          bra       OSSemDel_8
                    11783   OSSemDel_10:
                    11784   ; case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
                    11785   ; if (tasks_waiting == OS_FALSE) {
00003EB0  4A05      11786          tst.b     D5
00003EB2  6628      11787          bne.s     OSSemDel_13
                    11788   ; #if OS_EVENT_NAME_EN > 0u
                    11789   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003EB4  41F9 0000 11790          lea       @ucos_ii_1.L,A0
00003EB8  708C      
00003EBA  2242      11791          move.l    D2,A1
00003EBC  2348 0012 11792          move.l    A0,18(A1)
                    11793   ; #endif
                    11794   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00003EC0  2042      11795          move.l    D2,A0
00003EC2  4210      11796          clr.b     (A0)
                    11797   ; pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
00003EC4  2042      11798          move.l    D2,A0
00003EC6  2152 0002 11799          move.l    (A2),2(A0)
                    11800   ; pevent->OSEventCnt     = 0u;
00003ECA  2042      11801          move.l    D2,A0
00003ECC  4268 0006 11802          clr.w     6(A0)
                    11803   ; OSEventFreeList        = pevent;          /* Get next free event control block        */
00003ED0  2482      11804          move.l    D2,(A2)
                    11805   ; OS_EXIT_CRITICAL();
00003ED2  46DF      11806          dc.w      18143
                    11807   ; *perr                  = OS_ERR_NONE;
00003ED4  2043      11808          move.l    D3,A0
00003ED6  4210      11809          clr.b     (A0)
                    11810   ; pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
00003ED8  4284      11811          clr.l     D4
00003EDA  600A      11812          bra.s     OSSemDel_14
                    11813   OSSemDel_13:
                    11814   ; } else {
                    11815   ; OS_EXIT_CRITICAL();
00003EDC  46DF      11816          dc.w      18143
                    11817   ; *perr                  = OS_ERR_TASK_WAITING;
00003EDE  2043      11818          move.l    D3,A0
00003EE0  10BC 0049 11819          move.b    #73,(A0)
                    11820   ; pevent_return          = pevent;
00003EE4  2802      11821          move.l    D2,D4
                    11822   OSSemDel_14:
                    11823   ; }
                    11824   ; break;
00003EE6  6000 0062 11825          bra       OSSemDel_9
                    11826   OSSemDel_11:
                    11827   ; case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
                    11828   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for semaphore    */
                    11829   OSSemDel_15:
00003EEA  2042      11830          move.l    D2,A0
00003EEC  1028 0008 11831          move.b    8(A0),D0
00003EF0  671C      11832          beq.s     OSSemDel_17
                    11833   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
00003EF2  4878 0002 11834          pea       2
00003EF6  4878 0001 11835          pea       1
00003EFA  42A7      11836          clr.l     -(A7)
00003EFC  2F02      11837          move.l    D2,-(A7)
00003EFE  4EB8 0FFA 11838          jsr       _OS_EventTaskRdy
00003F02  DEFC 0010 11839          add.w     #16,A7
00003F06  C0BC 0000 11840          and.l     #255,D0
00003F0A  00FF      
00003F0C  60DC      11841          bra       OSSemDel_15
                    11842   OSSemDel_17:
                    11843   ; }
                    11844   ; #if OS_EVENT_NAME_EN > 0u
                    11845   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003F0E  41F9 0000 11846          lea       @ucos_ii_1.L,A0
00003F12  708C      
00003F14  2242      11847          move.l    D2,A1
00003F16  2348 0012 11848          move.l    A0,18(A1)
                    11849   ; #endif
                    11850   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00003F1A  2042      11851          move.l    D2,A0
00003F1C  4210      11852          clr.b     (A0)
                    11853   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
00003F1E  2042      11854          move.l    D2,A0
00003F20  2152 0002 11855          move.l    (A2),2(A0)
                    11856   ; pevent->OSEventCnt     = 0u;
00003F24  2042      11857          move.l    D2,A0
00003F26  4268 0006 11858          clr.w     6(A0)
                    11859   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
00003F2A  2482      11860          move.l    D2,(A2)
                    11861   ; OS_EXIT_CRITICAL();
00003F2C  46DF      11862          dc.w      18143
                    11863   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00003F2E  0C05 0001 11864          cmp.b     #1,D5
00003F32  6604      11865          bne.s     OSSemDel_18
                    11866   ; OS_Sched();                               /* Find highest priority task ready to run  */
00003F34  4EB8 15DA 11867          jsr       _OS_Sched
                    11868   OSSemDel_18:
                    11869   ; }
                    11870   ; *perr                  = OS_ERR_NONE;
00003F38  2043      11871          move.l    D3,A0
00003F3A  4210      11872          clr.b     (A0)
                    11873   ; pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
00003F3C  4284      11874          clr.l     D4
                    11875   ; break;
00003F3E  600A      11876          bra.s     OSSemDel_9
                    11877   OSSemDel_8:
                    11878   ; default:
                    11879   ; OS_EXIT_CRITICAL();
00003F40  46DF      11880          dc.w      18143
                    11881   ; *perr                  = OS_ERR_INVALID_OPT;
00003F42  2043      11882          move.l    D3,A0
00003F44  10BC 0007 11883          move.b    #7,(A0)
                    11884   ; pevent_return          = pevent;
00003F48  2802      11885          move.l    D2,D4
                    11886   ; break;
                    11887   OSSemDel_9:
                    11888   ; }
                    11889   ; return (pevent_return);
00003F4A  2004      11890          move.l    D4,D0
                    11891   OSSemDel_3:
00003F4C  4CDF 043C 11892          movem.l   (A7)+,D2/D3/D4/D5/A2
00003F50  4E5E      11893          unlk      A6
00003F52  4E75      11894          rts
                    11895   ; }
                    11896   ; #endif
                    11897   ; /*$PAGE*/
                    11898   ; /*
                    11899   ; *********************************************************************************************************
                    11900   ; *                                          PEND ON SEMAPHORE
                    11901   ; *
                    11902   ; * Description: This function waits for a semaphore.
                    11903   ; *
                    11904   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    11905   ; *                            semaphore.
                    11906   ; *
                    11907   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    11908   ; *                            wait for the resource up to the amount of time specified by this argument.
                    11909   ; *                            If you specify 0, however, your task will wait forever at the specified
                    11910   ; *                            semaphore or, until the resource becomes available (or the event occurs).
                    11911   ; *
                    11912   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    11913   ; *                            messages are:
                    11914   ; *
                    11915   ; *                            OS_ERR_NONE         The call was successful and your task owns the resource
                    11916   ; *                                                or, the event you are waiting for occurred.
                    11917   ; *                            OS_ERR_TIMEOUT      The semaphore was not received within the specified
                    11918   ; *                                                'timeout'.
                    11919   ; *                            OS_ERR_PEND_ABORT   The wait on the semaphore was aborted.
                    11920   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
                    11921   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    11922   ; *                                                would lead to a suspension.
                    11923   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    11924   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
                    11925   ; *
                    11926   ; * Returns    : none
                    11927   ; *********************************************************************************************************
                    11928   ; */
                    11929   ; /*$PAGE*/
                    11930   ; void  OSSemPend (OS_EVENT  *pevent,
                    11931   ; INT32U     timeout,
                    11932   ; INT8U     *perr)
                    11933   ; {
                    11934   _OSSemPend:
00003F54  4E56 0000 11935          link      A6,#0
00003F58  48E7 3020 11936          movem.l   D2/D3/A2,-(A7)
00003F5C  45F9 0800 11937          lea       _OSTCBCur.L,A2
00003F60  0428      
00003F62  242E 0010 11938          move.l    16(A6),D2
00003F66  262E 0008 11939          move.l    8(A6),D3
                    11940   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11941   ; OS_CPU_SR  cpu_sr = 0u;
                    11942   ; #endif
                    11943   ; #ifdef OS_SAFETY_CRITICAL
                    11944   ; if (perr == (INT8U *)0) {
                    11945   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    11946   ; return;
                    11947   ; }
                    11948   ; #endif
                    11949   ; #if OS_ARG_CHK_EN > 0u
                    11950   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11951   ; *perr = OS_ERR_PEVENT_NULL;
                    11952   ; return;
                    11953   ; }
                    11954   ; #endif
                    11955   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00003F6A  2043      11956          move.l    D3,A0
00003F6C  1010      11957          move.b    (A0),D0
00003F6E  0C00 0003 11958          cmp.b     #3,D0
00003F72  670A      11959          beq.s     OSSemPend_1
                    11960   ; *perr = OS_ERR_EVENT_TYPE;
00003F74  2042      11961          move.l    D2,A0
00003F76  10BC 0001 11962          move.b    #1,(A0)
                    11963   ; return;
00003F7A  6000 00DA 11964          bra       OSSemPend_3
                    11965   OSSemPend_1:
                    11966   ; }
                    11967   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
00003F7E  1039 0800 11968          move.b    _OSIntNesting.L,D0
00003F82  030E      
00003F84  0C00 0000 11969          cmp.b     #0,D0
00003F88  630A      11970          bls.s     OSSemPend_4
                    11971   ; *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
00003F8A  2042      11972          move.l    D2,A0
00003F8C  10BC 0002 11973          move.b    #2,(A0)
                    11974   ; return;
00003F90  6000 00C4 11975          bra       OSSemPend_3
                    11976   OSSemPend_4:
                    11977   ; }
                    11978   ; if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
00003F94  1039 0800 11979          move.b    _OSLockNesting.L,D0
00003F98  0310      
00003F9A  0C00 0000 11980          cmp.b     #0,D0
00003F9E  630A      11981          bls.s     OSSemPend_6
                    11982   ; *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
00003FA0  2042      11983          move.l    D2,A0
00003FA2  10BC 000D 11984          move.b    #13,(A0)
                    11985   ; return;
00003FA6  6000 00AE 11986          bra       OSSemPend_3
                    11987   OSSemPend_6:
                    11988   ; }
                    11989   ; OS_ENTER_CRITICAL();
00003FAA  40E7      11990          dc.w      16615
00003FAC  007C      11991          dc.w      124
00003FAE  0700      11992          dc.w      1792
                    11993   ; if (pevent->OSEventCnt > 0u) {                    /* If sem. is positive, resource available ...   */
00003FB0  2043      11994          move.l    D3,A0
00003FB2  3028 0006 11995          move.w    6(A0),D0
00003FB6  0C40 0000 11996          cmp.w     #0,D0
00003FBA  6312      11997          bls.s     OSSemPend_8
                    11998   ; pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
00003FBC  2003      11999          move.l    D3,D0
00003FBE  5C80      12000          addq.l    #6,D0
00003FC0  2040      12001          move.l    D0,A0
00003FC2  5350      12002          subq.w    #1,(A0)
                    12003   ; OS_EXIT_CRITICAL();
00003FC4  46DF      12004          dc.w      18143
                    12005   ; *perr = OS_ERR_NONE;
00003FC6  2042      12006          move.l    D2,A0
00003FC8  4210      12007          clr.b     (A0)
                    12008   ; return;
00003FCA  6000 008A 12009          bra       OSSemPend_3
                    12010   OSSemPend_8:
                    12011   ; }
                    12012   ; /* Otherwise, must wait until event occurs       */
                    12013   ; OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
00003FCE  2052      12014          move.l    (A2),A0
00003FD0  0028 0001 12015          or.b      #1,50(A0)
00003FD4  0032      
                    12016   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00003FD6  2052      12017          move.l    (A2),A0
00003FD8  4228 0033 12018          clr.b     51(A0)
                    12019   ; OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
00003FDC  2052      12020          move.l    (A2),A0
00003FDE  216E 000C 12021          move.l    12(A6),46(A0)
00003FE2  002E      
                    12022   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
00003FE4  2F03      12023          move.l    D3,-(A7)
00003FE6  4EB8 10DE 12024          jsr       _OS_EventTaskWait
00003FEA  584F      12025          addq.w    #4,A7
                    12026   ; OS_EXIT_CRITICAL();
00003FEC  46DF      12027          dc.w      18143
                    12028   ; OS_Sched();                                       /* Find next highest priority task ready         */
00003FEE  4EB8 15DA 12029          jsr       _OS_Sched
                    12030   ; OS_ENTER_CRITICAL();
00003FF2  40E7      12031          dc.w      16615
00003FF4  007C      12032          dc.w      124
00003FF6  0700      12033          dc.w      1792
                    12034   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
00003FF8  2052      12035          move.l    (A2),A0
00003FFA  1028 0033 12036          move.b    51(A0),D0
00003FFE  C0BC 0000 12037          and.l     #255,D0
00004002  00FF      
00004004  0C80 0000 12038          cmp.l     #1,D0
00004008  0001      
0000400A  6720      12039          beq.s     OSSemPend_14
0000400C  6206      12040          bhi.s     OSSemPend_16
0000400E  4A80      12041          tst.l     D0
00004010  670C      12042          beq.s     OSSemPend_12
00004012  6018      12043          bra.s     OSSemPend_14
                    12044   OSSemPend_16:
00004014  0C80 0000 12045          cmp.l     #2,D0
00004018  0002      
0000401A  6708      12046          beq.s     OSSemPend_13
0000401C  600E      12047          bra.s     OSSemPend_14
                    12048   OSSemPend_12:
                    12049   ; case OS_STAT_PEND_OK:
                    12050   ; *perr = OS_ERR_NONE;
0000401E  2042      12051          move.l    D2,A0
00004020  4210      12052          clr.b     (A0)
                    12053   ; break;
00004022  6018      12054          bra.s     OSSemPend_11
                    12055   OSSemPend_13:
                    12056   ; case OS_STAT_PEND_ABORT:
                    12057   ; *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
00004024  2042      12058          move.l    D2,A0
00004026  10BC 000E 12059          move.b    #14,(A0)
                    12060   ; break;
0000402A  6010      12061          bra.s     OSSemPend_11
                    12062   OSSemPend_14:
                    12063   ; case OS_STAT_PEND_TO:
                    12064   ; default:
                    12065   ; OS_EventTaskRemove(OSTCBCur, pevent);
0000402C  2F03      12066          move.l    D3,-(A7)
0000402E  2F12      12067          move.l    (A2),-(A7)
00004030  4EB8 1200 12068          jsr       _OS_EventTaskRemove
00004034  504F      12069          addq.w    #8,A7
                    12070   ; *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
00004036  2042      12071          move.l    D2,A0
00004038  10BC 000A 12072          move.b    #10,(A0)
                    12073   ; break;
                    12074   OSSemPend_11:
                    12075   ; }
                    12076   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
0000403C  2052      12077          move.l    (A2),A0
0000403E  4228 0032 12078          clr.b     50(A0)
                    12079   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
00004042  2052      12080          move.l    (A2),A0
00004044  4228 0033 12081          clr.b     51(A0)
                    12082   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
00004048  2052      12083          move.l    (A2),A0
0000404A  42A8 001C 12084          clr.l     28(A0)
                    12085   ; #if (OS_EVENT_MULTI_EN > 0u)
                    12086   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
0000404E  2052      12087          move.l    (A2),A0
00004050  42A8 0020 12088          clr.l     32(A0)
                    12089   ; #endif
                    12090   ; OS_EXIT_CRITICAL();
00004054  46DF      12091          dc.w      18143
                    12092   OSSemPend_3:
00004056  4CDF 040C 12093          movem.l   (A7)+,D2/D3/A2
0000405A  4E5E      12094          unlk      A6
0000405C  4E75      12095          rts
                    12096   ; }
                    12097   ; /*$PAGE*/
                    12098   ; /*
                    12099   ; *********************************************************************************************************
                    12100   ; *                                    ABORT WAITING ON A SEMAPHORE
                    12101   ; *
                    12102   ; * Description: This function aborts & readies any tasks currently waiting on a semaphore.  This function
                    12103   ; *              should be used to fault-abort the wait on the semaphore, rather than to normally signal
                    12104   ; *              the semaphore via OSSemPost().
                    12105   ; *
                    12106   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12107   ; *                            semaphore.
                    12108   ; *
                    12109   ; *              opt           determines the type of ABORT performed:
                    12110   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    12111   ; *                                                     semaphore
                    12112   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    12113   ; *                                                     semaphore
                    12114   ; *
                    12115   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    12116   ; *                            messages are:
                    12117   ; *
                    12118   ; *                            OS_ERR_NONE         No tasks were     waiting on the semaphore.
                    12119   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the semaphore was readied
                    12120   ; *                                                and informed of the aborted wait; check return value
                    12121   ; *                                                for the number of tasks whose wait on the semaphore
                    12122   ; *                                                was aborted.
                    12123   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
                    12124   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    12125   ; *
                    12126   ; * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
                    12127   ; *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
                    12128   ; *********************************************************************************************************
                    12129   ; */
                    12130   ; #if OS_SEM_PEND_ABORT_EN > 0u
                    12131   ; INT8U  OSSemPendAbort (OS_EVENT  *pevent,
                    12132   ; INT8U      opt,
                    12133   ; INT8U     *perr)
                    12134   ; {
                    12135   _OSSemPendAbort:
0000405E  4E56 0000 12136          link      A6,#0
00004062  48E7 3800 12137          movem.l   D2/D3/D4,-(A7)
00004066  242E 0008 12138          move.l    8(A6),D2
0000406A  282E 0010 12139          move.l    16(A6),D4
                    12140   ; INT8U      nbr_tasks;
                    12141   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12142   ; OS_CPU_SR  cpu_sr = 0u;
                    12143   ; #endif
                    12144   ; #ifdef OS_SAFETY_CRITICAL
                    12145   ; if (perr == (INT8U *)0) {
                    12146   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12147   ; return (0u);
                    12148   ; }
                    12149   ; #endif
                    12150   ; #if OS_ARG_CHK_EN > 0u
                    12151   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12152   ; *perr = OS_ERR_PEVENT_NULL;
                    12153   ; return (0u);
                    12154   ; }
                    12155   ; #endif
                    12156   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
0000406E  2042      12157          move.l    D2,A0
00004070  1010      12158          move.b    (A0),D0
00004072  0C00 0003 12159          cmp.b     #3,D0
00004076  670C      12160          beq.s     OSSemPendAbort_1
                    12161   ; *perr = OS_ERR_EVENT_TYPE;
00004078  2044      12162          move.l    D4,A0
0000407A  10BC 0001 12163          move.b    #1,(A0)
                    12164   ; return (0u);
0000407E  4200      12165          clr.b     D0
00004080  6000 008C 12166          bra       OSSemPendAbort_3
                    12167   OSSemPendAbort_1:
                    12168   ; }
                    12169   ; OS_ENTER_CRITICAL();
00004084  40E7      12170          dc.w      16615
00004086  007C      12171          dc.w      124
00004088  0700      12172          dc.w      1792
                    12173   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting on semaphore?         */
0000408A  2042      12174          move.l    D2,A0
0000408C  1028 0008 12175          move.b    8(A0),D0
00004090  6700 0074 12176          beq       OSSemPendAbort_4
                    12177   ; nbr_tasks = 0u;
00004094  4203      12178          clr.b     D3
                    12179   ; switch (opt) {
00004096  102E 000F 12180          move.b    15(A6),D0
0000409A  C0BC 0000 12181          and.l     #255,D0
0000409E  00FF      
000040A0  0C80 0000 12182          cmp.l     #1,D0
000040A4  0001      
000040A6  670A      12183          beq.s     OSSemPendAbort_8
000040A8  6200 0030 12184          bhi       OSSemPendAbort_9
000040AC  4A80      12185          tst.l     D0
000040AE  672A      12186          beq.s     OSSemPendAbort_9
000040B0  6028      12187          bra.s     OSSemPendAbort_9
                    12188   OSSemPendAbort_8:
                    12189   ; case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                    12190   ; while (pevent->OSEventGrp != 0u) {   /* Yes, ready ALL tasks waiting on semaphore     */
                    12191   OSSemPendAbort_11:
000040B2  2042      12192          move.l    D2,A0
000040B4  1028 0008 12193          move.b    8(A0),D0
000040B8  671E      12194          beq.s     OSSemPendAbort_13
                    12195   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
000040BA  4878 0002 12196          pea       2
000040BE  4878 0001 12197          pea       1
000040C2  42A7      12198          clr.l     -(A7)
000040C4  2F02      12199          move.l    D2,-(A7)
000040C6  4EB8 0FFA 12200          jsr       _OS_EventTaskRdy
000040CA  DEFC 0010 12201          add.w     #16,A7
000040CE  C0BC 0000 12202          and.l     #255,D0
000040D2  00FF      
                    12203   ; nbr_tasks++;
000040D4  5203      12204          addq.b    #1,D3
000040D6  60DA      12205          bra       OSSemPendAbort_11
                    12206   OSSemPendAbort_13:
                    12207   ; }
                    12208   ; break;
000040D8  601C      12209          bra.s     OSSemPendAbort_7
                    12210   OSSemPendAbort_9:
                    12211   ; case OS_PEND_OPT_NONE:
                    12212   ; default:                                  /* No,  ready HPT       waiting on semaphore     */
                    12213   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
000040DA  4878 0002 12214          pea       2
000040DE  4878 0001 12215          pea       1
000040E2  42A7      12216          clr.l     -(A7)
000040E4  2F02      12217          move.l    D2,-(A7)
000040E6  4EB8 0FFA 12218          jsr       _OS_EventTaskRdy
000040EA  DEFC 0010 12219          add.w     #16,A7
000040EE  C0BC 0000 12220          and.l     #255,D0
000040F2  00FF      
                    12221   ; nbr_tasks++;
000040F4  5203      12222          addq.b    #1,D3
                    12223   ; break;
                    12224   OSSemPendAbort_7:
                    12225   ; }
                    12226   ; OS_EXIT_CRITICAL();
000040F6  46DF      12227          dc.w      18143
                    12228   ; OS_Sched();                                   /* Find HPT ready to run                         */
000040F8  4EB8 15DA 12229          jsr       _OS_Sched
                    12230   ; *perr = OS_ERR_PEND_ABORT;
000040FC  2044      12231          move.l    D4,A0
000040FE  10BC 000E 12232          move.b    #14,(A0)
                    12233   ; return (nbr_tasks);
00004102  1003      12234          move.b    D3,D0
00004104  6008      12235          bra.s     OSSemPendAbort_3
                    12236   OSSemPendAbort_4:
                    12237   ; }
                    12238   ; OS_EXIT_CRITICAL();
00004106  46DF      12239          dc.w      18143
                    12240   ; *perr = OS_ERR_NONE;
00004108  2044      12241          move.l    D4,A0
0000410A  4210      12242          clr.b     (A0)
                    12243   ; return (0u);                                      /* No tasks waiting on semaphore                 */
0000410C  4200      12244          clr.b     D0
                    12245   OSSemPendAbort_3:
0000410E  4CDF 001C 12246          movem.l   (A7)+,D2/D3/D4
00004112  4E5E      12247          unlk      A6
00004114  4E75      12248          rts
                    12249   ; }
                    12250   ; #endif
                    12251   ; /*$PAGE*/
                    12252   ; /*
                    12253   ; *********************************************************************************************************
                    12254   ; *                                         POST TO A SEMAPHORE
                    12255   ; *
                    12256   ; * Description: This function signals a semaphore
                    12257   ; *
                    12258   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12259   ; *                            semaphore.
                    12260   ; *
                    12261   ; * Returns    : OS_ERR_NONE         The call was successful and the semaphore was signaled.
                    12262   ; *              OS_ERR_SEM_OVF      If the semaphore count exceeded its limit. In other words, you have
                    12263   ; *                                  signaled the semaphore more often than you waited on it with either
                    12264   ; *                                  OSSemAccept() or OSSemPend().
                    12265   ; *              OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore
                    12266   ; *              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    12267   ; *********************************************************************************************************
                    12268   ; */
                    12269   ; INT8U  OSSemPost (OS_EVENT *pevent)
                    12270   ; {
                    12271   _OSSemPost:
00004116  4E56 0000 12272          link      A6,#0
0000411A  2F02      12273          move.l    D2,-(A7)
0000411C  242E 0008 12274          move.l    8(A6),D2
                    12275   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12276   ; OS_CPU_SR  cpu_sr = 0u;
                    12277   ; #endif
                    12278   ; #if OS_ARG_CHK_EN > 0u
                    12279   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12280   ; return (OS_ERR_PEVENT_NULL);
                    12281   ; }
                    12282   ; #endif
                    12283   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00004120  2042      12284          move.l    D2,A0
00004122  1010      12285          move.b    (A0),D0
00004124  0C00 0003 12286          cmp.b     #3,D0
00004128  6706      12287          beq.s     OSSemPost_1
                    12288   ; return (OS_ERR_EVENT_TYPE);
0000412A  7001      12289          moveq     #1,D0
0000412C  6000 0050 12290          bra       OSSemPost_3
                    12291   OSSemPost_1:
                    12292   ; }
                    12293   ; OS_ENTER_CRITICAL();
00004130  40E7      12294          dc.w      16615
00004132  007C      12295          dc.w      124
00004134  0700      12296          dc.w      1792
                    12297   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting for semaphore         */
00004136  2042      12298          move.l    D2,A0
00004138  1028 0008 12299          move.b    8(A0),D0
0000413C  6722      12300          beq.s     OSSemPost_4
                    12301   ; /* Ready HPT waiting on event                    */
                    12302   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
0000413E  42A7      12303          clr.l     -(A7)
00004140  4878 0001 12304          pea       1
00004144  42A7      12305          clr.l     -(A7)
00004146  2F02      12306          move.l    D2,-(A7)
00004148  4EB8 0FFA 12307          jsr       _OS_EventTaskRdy
0000414C  DEFC 0010 12308          add.w     #16,A7
00004150  C0BC 0000 12309          and.l     #255,D0
00004154  00FF      
                    12310   ; OS_EXIT_CRITICAL();
00004156  46DF      12311          dc.w      18143
                    12312   ; OS_Sched();                                   /* Find HPT ready to run                         */
00004158  4EB8 15DA 12313          jsr       _OS_Sched
                    12314   ; return (OS_ERR_NONE);
0000415C  4200      12315          clr.b     D0
0000415E  601E      12316          bra.s     OSSemPost_3
                    12317   OSSemPost_4:
                    12318   ; }
                    12319   ; if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
00004160  2042      12320          move.l    D2,A0
00004162  3028 0006 12321          move.w    6(A0),D0
00004166  0C40 FFFF 12322          cmp.w     #65535,D0
0000416A  640E      12323          bhs.s     OSSemPost_6
                    12324   ; pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
0000416C  2002      12325          move.l    D2,D0
0000416E  5C80      12326          addq.l    #6,D0
00004170  2040      12327          move.l    D0,A0
00004172  5250      12328          addq.w    #1,(A0)
                    12329   ; OS_EXIT_CRITICAL();
00004174  46DF      12330          dc.w      18143
                    12331   ; return (OS_ERR_NONE);
00004176  4200      12332          clr.b     D0
00004178  6004      12333          bra.s     OSSemPost_3
                    12334   OSSemPost_6:
                    12335   ; }
                    12336   ; OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
0000417A  46DF      12337          dc.w      18143
                    12338   ; return (OS_ERR_SEM_OVF);
0000417C  7033      12339          moveq     #51,D0
                    12340   OSSemPost_3:
0000417E  241F      12341          move.l    (A7)+,D2
00004180  4E5E      12342          unlk      A6
00004182  4E75      12343          rts
                    12344   ; }
                    12345   ; /*$PAGE*/
                    12346   ; /*
                    12347   ; *********************************************************************************************************
                    12348   ; *                                          QUERY A SEMAPHORE
                    12349   ; *
                    12350   ; * Description: This function obtains information about a semaphore
                    12351   ; *
                    12352   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12353   ; *                            semaphore
                    12354   ; *
                    12355   ; *              p_sem_data    is a pointer to a structure that will contain information about the
                    12356   ; *                            semaphore.
                    12357   ; *
                    12358   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    12359   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non semaphore.
                    12360   ; *              OS_ERR_PEVENT_NULL  If 'pevent'     is a NULL pointer.
                    12361   ; *              OS_ERR_PDATA_NULL   If 'p_sem_data' is a NULL pointer
                    12362   ; *********************************************************************************************************
                    12363   ; */
                    12364   ; #if OS_SEM_QUERY_EN > 0u
                    12365   ; INT8U  OSSemQuery (OS_EVENT     *pevent,
                    12366   ; OS_SEM_DATA  *p_sem_data)
                    12367   ; {
                    12368   _OSSemQuery:
00004184  4E56 FFF8 12369          link      A6,#-8
00004188  48E7 3800 12370          movem.l   D2/D3/D4,-(A7)
0000418C  242E 0008 12371          move.l    8(A6),D2
00004190  282E 000C 12372          move.l    12(A6),D4
                    12373   ; INT8U       i;
                    12374   ; OS_PRIO    *psrc;
                    12375   ; OS_PRIO    *pdest;
                    12376   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    12377   ; OS_CPU_SR   cpu_sr = 0u;
                    12378   ; #endif
                    12379   ; #if OS_ARG_CHK_EN > 0u
                    12380   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    12381   ; return (OS_ERR_PEVENT_NULL);
                    12382   ; }
                    12383   ; if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
                    12384   ; return (OS_ERR_PDATA_NULL);
                    12385   ; }
                    12386   ; #endif
                    12387   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
00004194  2042      12388          move.l    D2,A0
00004196  1010      12389          move.b    (A0),D0
00004198  0C00 0003 12390          cmp.b     #3,D0
0000419C  6706      12391          beq.s     OSSemQuery_1
                    12392   ; return (OS_ERR_EVENT_TYPE);
0000419E  7001      12393          moveq     #1,D0
000041A0  6000 004C 12394          bra       OSSemQuery_3
                    12395   OSSemQuery_1:
                    12396   ; }
                    12397   ; OS_ENTER_CRITICAL();
000041A4  40E7      12398          dc.w      16615
000041A6  007C      12399          dc.w      124
000041A8  0700      12400          dc.w      1792
                    12401   ; p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
000041AA  2042      12402          move.l    D2,A0
000041AC  2244      12403          move.l    D4,A1
000041AE  1368 0008 12404          move.b    8(A0),10(A1)
000041B2  000A      
                    12405   ; psrc                   = &pevent->OSEventTbl[0];
000041B4  700A      12406          moveq     #10,D0
000041B6  D082      12407          add.l     D2,D0
000041B8  2D40 FFF8 12408          move.l    D0,-8(A6)
                    12409   ; pdest                  = &p_sem_data->OSEventTbl[0];
000041BC  7002      12410          moveq     #2,D0
000041BE  D084      12411          add.l     D4,D0
000041C0  2D40 FFFC 12412          move.l    D0,-4(A6)
                    12413   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
000041C4  4203      12414          clr.b     D3
                    12415   OSSemQuery_4:
000041C6  0C03 0008 12416          cmp.b     #8,D3
000041CA  6416      12417          bhs.s     OSSemQuery_6
                    12418   ; *pdest++ = *psrc++;
000041CC  206E FFF8 12419          move.l    -8(A6),A0
000041D0  52AE FFF8 12420          addq.l    #1,-8(A6)
000041D4  226E FFFC 12421          move.l    -4(A6),A1
000041D8  52AE FFFC 12422          addq.l    #1,-4(A6)
000041DC  1290      12423          move.b    (A0),(A1)
000041DE  5203      12424          addq.b    #1,D3
000041E0  60E4      12425          bra       OSSemQuery_4
                    12426   OSSemQuery_6:
                    12427   ; }
                    12428   ; p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
000041E2  2042      12429          move.l    D2,A0
000041E4  2244      12430          move.l    D4,A1
000041E6  32A8 0006 12431          move.w    6(A0),(A1)
                    12432   ; OS_EXIT_CRITICAL();
000041EA  46DF      12433          dc.w      18143
                    12434   ; return (OS_ERR_NONE);
000041EC  4200      12435          clr.b     D0
                    12436   OSSemQuery_3:
000041EE  4CDF 001C 12437          movem.l   (A7)+,D2/D3/D4
000041F2  4E5E      12438          unlk      A6
000041F4  4E75      12439          rts
                    12440   ; }
                    12441   ; #endif                                                     /* OS_SEM_QUERY_EN                          */
                    12442   ; /*$PAGE*/
                    12443   ; /*
                    12444   ; *********************************************************************************************************
                    12445   ; *                                            SET SEMAPHORE
                    12446   ; *
                    12447   ; * Description: This function sets the semaphore count to the value specified as an argument.  Typically,
                    12448   ; *              this value would be 0.
                    12449   ; *
                    12450   ; *              You would typically use this function when a semaphore is used as a signaling mechanism
                    12451   ; *              and, you want to reset the count value.
                    12452   ; *
                    12453   ; * Arguments  : pevent     is a pointer to the event control block
                    12454   ; *
                    12455   ; *              cnt        is the new value for the semaphore count.  You would pass 0 to reset the
                    12456   ; *                         semaphore count.
                    12457   ; *
                    12458   ; *              perr       is a pointer to an error code returned by the function as follows:
                    12459   ; *
                    12460   ; *                            OS_ERR_NONE          The call was successful and the semaphore value was set.
                    12461   ; *                            OS_ERR_EVENT_TYPE    If you didn't pass a pointer to a semaphore.
                    12462   ; *                            OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer.
                    12463   ; *                            OS_ERR_TASK_WAITING  If tasks are waiting on the semaphore.
                    12464   ; *********************************************************************************************************
                    12465   ; */
                    12466   ; #if OS_SEM_SET_EN > 0u
                    12467   ; void  OSSemSet (OS_EVENT  *pevent,
                    12468   ; INT16U     cnt,
                    12469   ; INT8U     *perr)
                    12470   ; {
                    12471   _OSSemSet:
000041F6  4E56 0000 12472          link      A6,#0
000041FA  48E7 3000 12473          movem.l   D2/D3,-(A7)
000041FE  242E 0008 12474          move.l    8(A6),D2
00004202  262E 0010 12475          move.l    16(A6),D3
                    12476   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12477   ; OS_CPU_SR  cpu_sr = 0u;
                    12478   ; #endif
                    12479   ; #ifdef OS_SAFETY_CRITICAL
                    12480   ; if (perr == (INT8U *)0) {
                    12481   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12482   ; return;
                    12483   ; }
                    12484   ; #endif
                    12485   ; #if OS_ARG_CHK_EN > 0u
                    12486   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12487   ; *perr = OS_ERR_PEVENT_NULL;
                    12488   ; return;
                    12489   ; }
                    12490   ; #endif
                    12491   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00004206  2042      12492          move.l    D2,A0
00004208  1010      12493          move.b    (A0),D0
0000420A  0C00 0003 12494          cmp.b     #3,D0
0000420E  670A      12495          beq.s     OSSemSet_1
                    12496   ; *perr = OS_ERR_EVENT_TYPE;
00004210  2043      12497          move.l    D3,A0
00004212  10BC 0001 12498          move.b    #1,(A0)
                    12499   ; return;
00004216  6000 003C 12500          bra       OSSemSet_3
                    12501   OSSemSet_1:
                    12502   ; }
                    12503   ; OS_ENTER_CRITICAL();
0000421A  40E7      12504          dc.w      16615
0000421C  007C      12505          dc.w      124
0000421E  0700      12506          dc.w      1792
                    12507   ; *perr = OS_ERR_NONE;
00004220  2043      12508          move.l    D3,A0
00004222  4210      12509          clr.b     (A0)
                    12510   ; if (pevent->OSEventCnt > 0u) {                    /* See if semaphore already has a count          */
00004224  2042      12511          move.l    D2,A0
00004226  3028 0006 12512          move.w    6(A0),D0
0000422A  0C40 0000 12513          cmp.w     #0,D0
0000422E  630A      12514          bls.s     OSSemSet_4
                    12515   ; pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
00004230  2042      12516          move.l    D2,A0
00004232  316E 000E 12517          move.w    14(A6),6(A0)
00004236  0006      
00004238  6018      12518          bra.s     OSSemSet_7
                    12519   OSSemSet_4:
                    12520   ; } else {                                          /* No                                            */
                    12521   ; if (pevent->OSEventGrp == 0u) {               /*      See if task(s) waiting?                  */
0000423A  2042      12522          move.l    D2,A0
0000423C  1028 0008 12523          move.b    8(A0),D0
00004240  660A      12524          bne.s     OSSemSet_6
                    12525   ; pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
00004242  2042      12526          move.l    D2,A0
00004244  316E 000E 12527          move.w    14(A6),6(A0)
00004248  0006      
0000424A  6006      12528          bra.s     OSSemSet_7
                    12529   OSSemSet_6:
                    12530   ; } else {
                    12531   ; *perr              = OS_ERR_TASK_WAITING;
0000424C  2043      12532          move.l    D3,A0
0000424E  10BC 0049 12533          move.b    #73,(A0)
                    12534   OSSemSet_7:
                    12535   ; }
                    12536   ; }
                    12537   ; OS_EXIT_CRITICAL();
00004252  46DF      12538          dc.w      18143
                    12539   OSSemSet_3:
00004254  4CDF 000C 12540          movem.l   (A7)+,D2/D3
00004258  4E5E      12541          unlk      A6
0000425A  4E75      12542          rts
                    12543   ; /*
                    12544   ; *********************************************************************************************************
                    12545   ; *                                                uC/OS-II
                    12546   ; *                                          The Real-Time Kernel
                    12547   ; *                                            TASK MANAGEMENT
                    12548   ; *
                    12549   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    12550   ; *                                           All Rights Reserved
                    12551   ; *
                    12552   ; * File    : OS_TASK.C
                    12553   ; * By      : Jean J. Labrosse
                    12554   ; * Version : V2.92.07
                    12555   ; *
                    12556   ; * LICENSING TERMS:
                    12557   ; * ---------------
                    12558   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    12559   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    12560   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    12561   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    12562   ; * licensing fee.
                    12563   ; *********************************************************************************************************
                    12564   ; */
                    12565   ; #define  MICRIUM_SOURCE
                    12566   ; #ifndef  OS_MASTER_FILE
                    12567   ; #include <ucos_ii.h>
                    12568   ; #endif
                    12569   ; /*$PAGE*/
                    12570   ; /*
                    12571   ; *********************************************************************************************************
                    12572   ; *                                      CHANGE PRIORITY OF A TASK
                    12573   ; *
                    12574   ; * Description: This function allows you to change the priority of a task dynamically.  Note that the new
                    12575   ; *              priority MUST be available.
                    12576   ; *
                    12577   ; * Arguments  : oldp     is the old priority
                    12578   ; *
                    12579   ; *              newp     is the new priority
                    12580   ; *
                    12581   ; * Returns    : OS_ERR_NONE            is the call was successful
                    12582   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    12583   ; *                                     (i.e. >= OS_LOWEST_PRIO)
                    12584   ; *              OS_ERR_PRIO_EXIST      if the new priority already exist.
                    12585   ; *              OS_ERR_PRIO            there is no task with the specified OLD priority (i.e. the OLD task does
                    12586   ; *                                     not exist.
                    12587   ; *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP.
                    12588   ; *********************************************************************************************************
                    12589   ; */
                    12590   ; #if OS_TASK_CHANGE_PRIO_EN > 0u
                    12591   ; INT8U  OSTaskChangePrio (INT8U  oldprio,
                    12592   ; INT8U  newprio)
                    12593   ; {
                    12594   _OSTaskChangePrio:
0000425C  4E56 FFFC 12595          link      A6,#-4
00004260  48E7 3F38 12596          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4,-(A7)
00004264  47F9 0800 12597          lea       _OSRdyTbl.L,A3
00004268  0318      
0000426A  49F9 0800 12598          lea       _OSTCBPrioTbl.L,A4
0000426E  0438      
                    12599   ; #if (OS_EVENT_EN)
                    12600   ; OS_EVENT  *pevent;
                    12601   ; #if (OS_EVENT_MULTI_EN > 0u)
                    12602   ; OS_EVENT **pevents;
                    12603   ; #endif
                    12604   ; #endif
                    12605   ; OS_TCB    *ptcb;
                    12606   ; INT8U      y_new;
                    12607   ; INT8U      x_new;
                    12608   ; INT8U      y_old;
                    12609   ; OS_PRIO    bity_new;
                    12610   ; OS_PRIO    bitx_new;
                    12611   ; OS_PRIO    bity_old;
                    12612   ; OS_PRIO    bitx_old;
                    12613   ; #if OS_CRITICAL_METHOD == 3u
                    12614   ; OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
                    12615   ; #endif
                    12616   ; /*$PAGE*/
                    12617   ; #if OS_ARG_CHK_EN > 0u
                    12618   ; if (oldprio >= OS_LOWEST_PRIO) {
                    12619   ; if (oldprio != OS_PRIO_SELF) {
                    12620   ; return (OS_ERR_PRIO_INVALID);
                    12621   ; }
                    12622   ; }
                    12623   ; if (newprio >= OS_LOWEST_PRIO) {
                    12624   ; return (OS_ERR_PRIO_INVALID);
                    12625   ; }
                    12626   ; #endif
                    12627   ; OS_ENTER_CRITICAL();
00004270  40E7      12628          dc.w      16615
00004272  007C      12629          dc.w      124
00004274  0700      12630          dc.w      1792
                    12631   ; if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
00004276  102E 000F 12632          move.b    15(A6),D0
0000427A  C0BC 0000 12633          and.l     #255,D0
0000427E  00FF      
00004280  E588      12634          lsl.l     #2,D0
00004282  2034 0800 12635          move.l    0(A4,D0.L),D0
00004286  6708      12636          beq.s     OSTaskChangePrio_1
                    12637   ; OS_EXIT_CRITICAL();
00004288  46DF      12638          dc.w      18143
                    12639   ; return (OS_ERR_PRIO_EXIST);
0000428A  7028      12640          moveq     #40,D0
0000428C  6000 01E0 12641          bra       OSTaskChangePrio_3
                    12642   OSTaskChangePrio_1:
                    12643   ; }
                    12644   ; if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
00004290  102E 000B 12645          move.b    11(A6),D0
00004294  0C00 00FF 12646          cmp.b     #255,D0
00004298  660C      12647          bne.s     OSTaskChangePrio_4
                    12648   ; oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
0000429A  2079 0800 12649          move.l    _OSTCBCur.L,A0
0000429E  0428      
000042A0  1D68 0034 12650          move.b    52(A0),11(A6)
000042A4  000B      
                    12651   OSTaskChangePrio_4:
                    12652   ; }
                    12653   ; ptcb = OSTCBPrioTbl[oldprio];
000042A6  102E 000B 12654          move.b    11(A6),D0
000042AA  C0BC 0000 12655          and.l     #255,D0
000042AE  00FF      
000042B0  E588      12656          lsl.l     #2,D0
000042B2  2634 0800 12657          move.l    0(A4,D0.L),D3
                    12658   ; if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
000042B6  4A83      12659          tst.l     D3
000042B8  6608      12660          bne.s     OSTaskChangePrio_6
                    12661   ; OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
000042BA  46DF      12662          dc.w      18143
                    12663   ; return (OS_ERR_PRIO);
000042BC  7029      12664          moveq     #41,D0
000042BE  6000 01AE 12665          bra       OSTaskChangePrio_3
                    12666   OSTaskChangePrio_6:
                    12667   ; }
                    12668   ; if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
000042C2  0C83 0000 12669          cmp.l     #1,D3
000042C6  0001      
000042C8  6608      12670          bne.s     OSTaskChangePrio_8
                    12671   ; OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
000042CA  46DF      12672          dc.w      18143
                    12673   ; return (OS_ERR_TASK_NOT_EXIST);
000042CC  7043      12674          moveq     #67,D0
000042CE  6000 019E 12675          bra       OSTaskChangePrio_3
                    12676   OSTaskChangePrio_8:
                    12677   ; }
                    12678   ; #if OS_LOWEST_PRIO <= 63u
                    12679   ; y_new                 = (INT8U)(newprio >> 3u);         /* Yes, compute new TCB fields             */
000042D2  102E 000F 12680          move.b    15(A6),D0
000042D6  E608      12681          lsr.b     #3,D0
000042D8  1A00      12682          move.b    D0,D5
                    12683   ; x_new                 = (INT8U)(newprio & 0x07u);
000042DA  102E 000F 12684          move.b    15(A6),D0
000042DE  C03C 0007 12685          and.b     #7,D0
000042E2  1D40 FFFD 12686          move.b    D0,-3(A6)
                    12687   ; #else
                    12688   ; y_new                 = (INT8U)((INT8U)(newprio >> 4u) & 0x0Fu);
                    12689   ; x_new                 = (INT8U)(newprio & 0x0Fu);
                    12690   ; #endif
                    12691   ; bity_new              = (OS_PRIO)(1uL << y_new);
000042E6  7001      12692          moveq     #1,D0
000042E8  CABC 0000 12693          and.l     #255,D5
000042EC  00FF      
000042EE  EBA8      12694          lsl.l     D5,D0
000042F0  1D40 FFFE 12695          move.b    D0,-2(A6)
                    12696   ; bitx_new              = (OS_PRIO)(1uL << x_new);
000042F4  7001      12697          moveq     #1,D0
000042F6  122E FFFD 12698          move.b    -3(A6),D1
000042FA  C2BC 0000 12699          and.l     #255,D1
000042FE  00FF      
00004300  E3A8      12700          lsl.l     D1,D0
00004302  1E00      12701          move.b    D0,D7
                    12702   ; OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
00004304  102E 000B 12703          move.b    11(A6),D0
00004308  C0BC 0000 12704          and.l     #255,D0
0000430C  00FF      
0000430E  E588      12705          lsl.l     #2,D0
00004310  42B4 0800 12706          clr.l     0(A4,D0.L)
                    12707   ; OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
00004314  102E 000F 12708          move.b    15(A6),D0
00004318  C0BC 0000 12709          and.l     #255,D0
0000431C  00FF      
0000431E  E588      12710          lsl.l     #2,D0
00004320  2983 0800 12711          move.l    D3,0(A4,D0.L)
                    12712   ; y_old                 =  ptcb->OSTCBY;
00004324  2043      12713          move.l    D3,A0
00004326  1828 0036 12714          move.b    54(A0),D4
                    12715   ; bity_old              =  ptcb->OSTCBBitY;
0000432A  2043      12716          move.l    D3,A0
0000432C  1D68 0038 12717          move.b    56(A0),-1(A6)
00004330  FFFF      
                    12718   ; bitx_old              =  ptcb->OSTCBBitX;
00004332  2043      12719          move.l    D3,A0
00004334  1C28 0037 12720          move.b    55(A0),D6
                    12721   ; if ((OSRdyTbl[y_old] &   bitx_old) != 0u) {             /* If task is ready make it not            */
00004338  C8BC 0000 12722          and.l     #255,D4
0000433C  00FF      
0000433E  1033 4800 12723          move.b    0(A3,D4.L),D0
00004342  C006      12724          and.b     D6,D0
00004344  673A      12725          beq.s     OSTaskChangePrio_10
                    12726   ; OSRdyTbl[y_old] &= (OS_PRIO)~bitx_old;
00004346  C8BC 0000 12727          and.l     #255,D4
0000434A  00FF      
0000434C  1006      12728          move.b    D6,D0
0000434E  4600      12729          not.b     D0
00004350  C133 4800 12730          and.b     D0,0(A3,D4.L)
                    12731   ; if (OSRdyTbl[y_old] == 0u) {
00004354  C8BC 0000 12732          and.l     #255,D4
00004358  00FF      
0000435A  1033 4800 12733          move.b    0(A3,D4.L),D0
0000435E  660C      12734          bne.s     OSTaskChangePrio_12
                    12735   ; OSRdyGrp &= (OS_PRIO)~bity_old;
00004360  102E FFFF 12736          move.b    -1(A6),D0
00004364  4600      12737          not.b     D0
00004366  C139 0800 12738          and.b     D0,_OSRdyGrp.L
0000436A  0316      
                    12739   OSTaskChangePrio_12:
                    12740   ; }
                    12741   ; OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
0000436C  102E FFFE 12742          move.b    -2(A6),D0
00004370  8139 0800 12743          or.b      D0,_OSRdyGrp.L
00004374  0316      
                    12744   ; OSRdyTbl[y_new] |= bitx_new;
00004376  CABC 0000 12745          and.l     #255,D5
0000437A  00FF      
0000437C  8F33 5800 12746          or.b      D7,0(A3,D5.L)
                    12747   OSTaskChangePrio_10:
                    12748   ; }
                    12749   ; #if (OS_EVENT_EN)
                    12750   ; pevent = ptcb->OSTCBEventPtr;
00004380  2043      12751          move.l    D3,A0
00004382  2428 001C 12752          move.l    28(A0),D2
                    12753   ; if (pevent != (OS_EVENT *)0) {
00004386  4A82      12754          tst.l     D2
00004388  6700 0048 12755          beq       OSTaskChangePrio_14
                    12756   ; pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;    /* Remove old task prio from wait list     */
0000438C  2042      12757          move.l    D2,A0
0000438E  C8BC 0000 12758          and.l     #255,D4
00004392  00FF      
00004394  D1C4      12759          add.l     D4,A0
00004396  1006      12760          move.b    D6,D0
00004398  4600      12761          not.b     D0
0000439A  C128 000A 12762          and.b     D0,10(A0)
                    12763   ; if (pevent->OSEventTbl[y_old] == 0u) {
0000439E  2042      12764          move.l    D2,A0
000043A0  C8BC 0000 12765          and.l     #255,D4
000043A4  00FF      
000043A6  D1C4      12766          add.l     D4,A0
000043A8  1028 000A 12767          move.b    10(A0),D0
000043AC  660C      12768          bne.s     OSTaskChangePrio_16
                    12769   ; pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
000043AE  2042      12770          move.l    D2,A0
000043B0  102E FFFF 12771          move.b    -1(A6),D0
000043B4  4600      12772          not.b     D0
000043B6  C128 0008 12773          and.b     D0,8(A0)
                    12774   OSTaskChangePrio_16:
                    12775   ; }
                    12776   ; pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
000043BA  2042      12777          move.l    D2,A0
000043BC  102E FFFE 12778          move.b    -2(A6),D0
000043C0  8128 0008 12779          or.b      D0,8(A0)
                    12780   ; pevent->OSEventTbl[y_new] |= bitx_new;
000043C4  2042      12781          move.l    D2,A0
000043C6  CABC 0000 12782          and.l     #255,D5
000043CA  00FF      
000043CC  D1C5      12783          add.l     D5,A0
000043CE  8F28 000A 12784          or.b      D7,10(A0)
                    12785   OSTaskChangePrio_14:
                    12786   ; }
                    12787   ; #if (OS_EVENT_MULTI_EN > 0u)
                    12788   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
000043D2  2043      12789          move.l    D3,A0
000043D4  2028 0020 12790          move.l    32(A0),D0
000043D8  6700 005C 12791          beq       OSTaskChangePrio_22
                    12792   ; pevents =  ptcb->OSTCBEventMultiPtr;
000043DC  2043      12793          move.l    D3,A0
000043DE  2468 0020 12794          move.l    32(A0),A2
                    12795   ; pevent  = *pevents;
000043E2  2412      12796          move.l    (A2),D2
                    12797   ; while (pevent != (OS_EVENT *)0) {
                    12798   OSTaskChangePrio_20:
000043E4  4A82      12799          tst.l     D2
000043E6  6700 004E 12800          beq       OSTaskChangePrio_22
                    12801   ; pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;   /* Remove old task prio from wait lists */
000043EA  2042      12802          move.l    D2,A0
000043EC  C8BC 0000 12803          and.l     #255,D4
000043F0  00FF      
000043F2  D1C4      12804          add.l     D4,A0
000043F4  1006      12805          move.b    D6,D0
000043F6  4600      12806          not.b     D0
000043F8  C128 000A 12807          and.b     D0,10(A0)
                    12808   ; if (pevent->OSEventTbl[y_old] == 0u) {
000043FC  2042      12809          move.l    D2,A0
000043FE  C8BC 0000 12810          and.l     #255,D4
00004402  00FF      
00004404  D1C4      12811          add.l     D4,A0
00004406  1028 000A 12812          move.b    10(A0),D0
0000440A  660C      12813          bne.s     OSTaskChangePrio_23
                    12814   ; pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
0000440C  2042      12815          move.l    D2,A0
0000440E  102E FFFF 12816          move.b    -1(A6),D0
00004412  4600      12817          not.b     D0
00004414  C128 0008 12818          and.b     D0,8(A0)
                    12819   OSTaskChangePrio_23:
                    12820   ; }
                    12821   ; pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
00004418  2042      12822          move.l    D2,A0
0000441A  102E FFFE 12823          move.b    -2(A6),D0
0000441E  8128 0008 12824          or.b      D0,8(A0)
                    12825   ; pevent->OSEventTbl[y_new] |= bitx_new;
00004422  2042      12826          move.l    D2,A0
00004424  CABC 0000 12827          and.l     #255,D5
00004428  00FF      
0000442A  D1C5      12828          add.l     D5,A0
0000442C  8F28 000A 12829          or.b      D7,10(A0)
                    12830   ; pevents++;
00004430  584A      12831          addq.w    #4,A2
                    12832   ; pevent                     = *pevents;
00004432  2412      12833          move.l    (A2),D2
00004434  60AE      12834          bra       OSTaskChangePrio_20
                    12835   OSTaskChangePrio_22:
                    12836   ; }
                    12837   ; }
                    12838   ; #endif
                    12839   ; #endif
                    12840   ; ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
00004436  2043      12841          move.l    D3,A0
00004438  116E 000F 12842          move.b    15(A6),52(A0)
0000443C  0034      
                    12843   ; ptcb->OSTCBY    = y_new;
0000443E  2043      12844          move.l    D3,A0
00004440  1145 0036 12845          move.b    D5,54(A0)
                    12846   ; ptcb->OSTCBX    = x_new;
00004444  2043      12847          move.l    D3,A0
00004446  116E FFFD 12848          move.b    -3(A6),53(A0)
0000444A  0035      
                    12849   ; ptcb->OSTCBBitY = bity_new;
0000444C  2043      12850          move.l    D3,A0
0000444E  116E FFFE 12851          move.b    -2(A6),56(A0)
00004452  0038      
                    12852   ; ptcb->OSTCBBitX = bitx_new;
00004454  2043      12853          move.l    D3,A0
00004456  1147 0037 12854          move.b    D7,55(A0)
                    12855   ; OS_EXIT_CRITICAL();
0000445A  46DF      12856          dc.w      18143
                    12857   ; if (OSRunning == OS_TRUE) {
0000445C  1039 0800 12858          move.b    _OSRunning.L,D0
00004460  0320      
00004462  0C00 0001 12859          cmp.b     #1,D0
00004466  6604      12860          bne.s     OSTaskChangePrio_25
                    12861   ; OS_Sched();                                         /* Find new highest priority task          */
00004468  4EB8 15DA 12862          jsr       _OS_Sched
                    12863   OSTaskChangePrio_25:
                    12864   ; }
                    12865   ; return (OS_ERR_NONE);
0000446C  4200      12866          clr.b     D0
                    12867   OSTaskChangePrio_3:
0000446E  4CDF 1CFC 12868          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4
00004472  4E5E      12869          unlk      A6
00004474  4E75      12870          rts
                    12871   ; }
                    12872   ; #endif
                    12873   ; /*$PAGE*/
                    12874   ; /*
                    12875   ; *********************************************************************************************************
                    12876   ; *                                            CREATE A TASK
                    12877   ; *
                    12878   ; * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
                    12879   ; *              be created prior to the start of multitasking or by a running task.  A task cannot be
                    12880   ; *              created by an ISR.
                    12881   ; *
                    12882   ; * Arguments  : task     is a pointer to the task's code
                    12883   ; *
                    12884   ; *              p_arg    is a pointer to an optional data area which can be used to pass parameters to
                    12885   ; *                       the task when the task first executes.  Where the task is concerned it thinks
                    12886   ; *                       it was invoked and passed the argument 'p_arg' as follows:
                    12887   ; *
                    12888   ; *                           void Task (void *p_arg)
                    12889   ; *                           {
                    12890   ; *                               for (;;) {
                    12891   ; *                                   Task code;
                    12892   ; *                               }
                    12893   ; *                           }
                    12894   ; *
                    12895   ; *              ptos     is a pointer to the task's top of stack.  If the configuration constant
                    12896   ; *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    12897   ; *                       memory to low memory).  'pstk' will thus point to the highest (valid) memory
                    12898   ; *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the
                    12899   ; *                       lowest memory location of the stack and the stack will grow with increasing
                    12900   ; *                       memory locations.
                    12901   ; *
                    12902   ; *              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
                    12903   ; *                       lower the number, the higher the priority.
                    12904   ; *
                    12905   ; * Returns    : OS_ERR_NONE                      if the function was successful.
                    12906   ; *              OS_ERR_PRIO_EXIST                if the task priority already exist
                    12907   ; *                                               (each task MUST have a unique priority).
                    12908   ; *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
                    12909   ; *                                               allowed (i.e. >= OS_LOWEST_PRIO)
                    12910   ; *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
                    12911   ; *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
                    12912   ; *                                               operation started.
                    12913   ; *********************************************************************************************************
                    12914   ; */
                    12915   ; #if OS_TASK_CREATE_EN > 0u
                    12916   ; INT8U  OSTaskCreate (void   (*task)(void *p_arg),
                    12917   ; void    *p_arg,
                    12918   ; OS_STK  *ptos,
                    12919   ; INT8U    prio)
                    12920   ; {
                    12921   _OSTaskCreate:
00004476  4E56 FFFC 12922          link      A6,#-4
0000447A  48E7 3020 12923          movem.l   D2/D3/A2,-(A7)
0000447E  142E 0017 12924          move.b    23(A6),D2
00004482  C4BC 0000 12925          and.l     #255,D2
00004486  00FF      
00004488  45F9 0800 12926          lea       _OSTCBPrioTbl.L,A2
0000448C  0438      
                    12927   ; OS_STK     *psp;
                    12928   ; INT8U       err;
                    12929   ; #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
                    12930   ; OS_CPU_SR   cpu_sr = 0u;
                    12931   ; #endif
                    12932   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    12933   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    12934   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12935   ; return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
                    12936   ; }
                    12937   ; #endif
                    12938   ; #if OS_ARG_CHK_EN > 0u
                    12939   ; if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
                    12940   ; return (OS_ERR_PRIO_INVALID);
                    12941   ; }
                    12942   ; #endif
                    12943   ; OS_ENTER_CRITICAL();
0000448E  40E7      12944          dc.w      16615
00004490  007C      12945          dc.w      124
00004492  0700      12946          dc.w      1792
                    12947   ; if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
00004494  1039 0800 12948          move.b    _OSIntNesting.L,D0
00004498  030E      
0000449A  0C00 0000 12949          cmp.b     #0,D0
0000449E  6308      12950          bls.s     OSTaskCreate_1
                    12951   ; OS_EXIT_CRITICAL();
000044A0  46DF      12952          dc.w      18143
                    12953   ; return (OS_ERR_TASK_CREATE_ISR);
000044A2  703C      12954          moveq     #60,D0
000044A4  6000 0096 12955          bra       OSTaskCreate_3
                    12956   OSTaskCreate_1:
                    12957   ; }
                    12958   ; if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
000044A8  C4BC 0000 12959          and.l     #255,D2
000044AC  00FF      
000044AE  2002      12960          move.l    D2,D0
000044B0  E588      12961          lsl.l     #2,D0
000044B2  2032 0800 12962          move.l    0(A2,D0.L),D0
000044B6  6600 0080 12963          bne       OSTaskCreate_4
                    12964   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
000044BA  C4BC 0000 12965          and.l     #255,D2
000044BE  00FF      
000044C0  2002      12966          move.l    D2,D0
000044C2  E588      12967          lsl.l     #2,D0
000044C4  25BC 0000 12968          move.l    #1,0(A2,D0.L)
000044C8  0001 0800 
                    12969   ; /* ... the same thing until task is created.              */
                    12970   ; OS_EXIT_CRITICAL();
000044CC  46DF      12971          dc.w      18143
                    12972   ; psp = OSTaskStkInit(task, p_arg, ptos, 0u);             /* Initialize the task's stack         */
000044CE  42A7      12973          clr.l     -(A7)
000044D0  2F2E 0010 12974          move.l    16(A6),-(A7)
000044D4  2F2E 000C 12975          move.l    12(A6),-(A7)
000044D8  2F2E 0008 12976          move.l    8(A6),-(A7)
000044DC  4EB8 07DC 12977          jsr       _OSTaskStkInit
000044E0  DEFC 0010 12978          add.w     #16,A7
000044E4  2D40 FFFC 12979          move.l    D0,-4(A6)
                    12980   ; err = OS_TCBInit(prio, psp, (OS_STK *)0, 0u, 0u, (void *)0, 0u);
000044E8  42A7      12981          clr.l     -(A7)
000044EA  42A7      12982          clr.l     -(A7)
000044EC  42A7      12983          clr.l     -(A7)
000044EE  42A7      12984          clr.l     -(A7)
000044F0  42A7      12985          clr.l     -(A7)
000044F2  2F2E FFFC 12986          move.l    -4(A6),-(A7)
000044F6  C4BC 0000 12987          and.l     #255,D2
000044FA  00FF      
000044FC  2F02      12988          move.l    D2,-(A7)
000044FE  4EB8 17F4 12989          jsr       _OS_TCBInit
00004502  DEFC 001C 12990          add.w     #28,A7
00004506  1600      12991          move.b    D0,D3
                    12992   ; if (err == OS_ERR_NONE) {
00004508  4A03      12993          tst.b     D3
0000450A  6612      12994          bne.s     OSTaskCreate_6
                    12995   ; if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
0000450C  1039 0800 12996          move.b    _OSRunning.L,D0
00004510  0320      
00004512  0C00 0001 12997          cmp.b     #1,D0
00004516  6604      12998          bne.s     OSTaskCreate_8
                    12999   ; OS_Sched();
00004518  4EB8 15DA 13000          jsr       _OS_Sched
                    13001   OSTaskCreate_8:
0000451C  6016      13002          bra.s     OSTaskCreate_7
                    13003   OSTaskCreate_6:
                    13004   ; }
                    13005   ; } else {
                    13006   ; OS_ENTER_CRITICAL();
0000451E  40E7      13007          dc.w      16615
00004520  007C      13008          dc.w      124
00004522  0700      13009          dc.w      1792
                    13010   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
00004524  C4BC 0000 13011          and.l     #255,D2
00004528  00FF      
0000452A  2002      13012          move.l    D2,D0
0000452C  E588      13013          lsl.l     #2,D0
0000452E  42B2 0800 13014          clr.l     0(A2,D0.L)
                    13015   ; OS_EXIT_CRITICAL();
00004532  46DF      13016          dc.w      18143
                    13017   OSTaskCreate_7:
                    13018   ; }
                    13019   ; return (err);
00004534  1003      13020          move.b    D3,D0
00004536  6004      13021          bra.s     OSTaskCreate_3
                    13022   OSTaskCreate_4:
                    13023   ; }
                    13024   ; OS_EXIT_CRITICAL();
00004538  46DF      13025          dc.w      18143
                    13026   ; return (OS_ERR_PRIO_EXIST);
0000453A  7028      13027          moveq     #40,D0
                    13028   OSTaskCreate_3:
0000453C  4CDF 040C 13029          movem.l   (A7)+,D2/D3/A2
00004540  4E5E      13030          unlk      A6
00004542  4E75      13031          rts
                    13032   ; }
                    13033   ; #endif
                    13034   ; /*$PAGE*/
                    13035   ; /*
                    13036   ; *********************************************************************************************************
                    13037   ; *                                  CREATE A TASK (Extended Version)
                    13038   ; *
                    13039   ; * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
                    13040   ; *              be created prior to the start of multitasking or by a running task.  A task cannot be
                    13041   ; *              created by an ISR.  This function is similar to OSTaskCreate() except that it allows
                    13042   ; *              additional information about a task to be specified.
                    13043   ; *
                    13044   ; * Arguments  : task      is a pointer to the task's code
                    13045   ; *
                    13046   ; *              p_arg     is a pointer to an optional data area which can be used to pass parameters to
                    13047   ; *                        the task when the task first executes.  Where the task is concerned it thinks
                    13048   ; *                        it was invoked and passed the argument 'p_arg' as follows:
                    13049   ; *
                    13050   ; *                            void Task (void *p_arg)
                    13051   ; *                            {
                    13052   ; *                                for (;;) {
                    13053   ; *                                    Task code;
                    13054   ; *                                }
                    13055   ; *                            }
                    13056   ; *
                    13057   ; *              ptos      is a pointer to the task's top of stack.  If the configuration constant
                    13058   ; *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    13059   ; *                        memory to low memory).  'ptos' will thus point to the highest (valid) memory
                    13060   ; *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'ptos' will point to the
                    13061   ; *                        lowest memory location of the stack and the stack will grow with increasing
                    13062   ; *                        memory locations.  'ptos' MUST point to a valid 'free' data item.
                    13063   ; *
                    13064   ; *              prio      is the task's priority.  A unique priority MUST be assigned to each task and the
                    13065   ; *                        lower the number, the higher the priority.
                    13066   ; *
                    13067   ; *              id        is the task's ID (0..65535)
                    13068   ; *
                    13069   ; *              pbos      is a pointer to the task's bottom of stack.  If the configuration constant
                    13070   ; *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    13071   ; *                        memory to low memory).  'pbos' will thus point to the LOWEST (valid) memory
                    13072   ; *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
                    13073   ; *                        HIGHEST memory location of the stack and the stack will grow with increasing
                    13074   ; *                        memory locations.  'pbos' MUST point to a valid 'free' data item.
                    13075   ; *
                    13076   ; *              stk_size  is the size of the stack in number of elements.  If OS_STK is set to INT8U,
                    13077   ; *                        'stk_size' corresponds to the number of bytes available.  If OS_STK is set to
                    13078   ; *                        INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
                    13079   ; *                        OS_STK is set to INT32U, 'stk_size' contains the number of 32-bit entries
                    13080   ; *                        available on the stack.
                    13081   ; *
                    13082   ; *              pext      is a pointer to a user supplied memory location which is used as a TCB extension.
                    13083   ; *                        For example, this user memory can hold the contents of floating-point registers
                    13084   ; *                        during a context switch, the time each task takes to execute, the number of times
                    13085   ; *                        the task has been switched-in, etc.
                    13086   ; *
                    13087   ; *              opt       contains additional information (or options) about the behavior of the task.  The
                    13088   ; *                        LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
                    13089   ; *                        specific.  See OS_TASK_OPT_??? in uCOS-II.H.  Current choices are:
                    13090   ; *
                    13091   ; *                        OS_TASK_OPT_STK_CHK      Stack checking to be allowed for the task
                    13092   ; *                        OS_TASK_OPT_STK_CLR      Clear the stack when the task is created
                    13093   ; *                        OS_TASK_OPT_SAVE_FP      If the CPU has floating-point registers, save them
                    13094   ; *                                                 during a context switch.
                    13095   ; *
                    13096   ; * Returns    : OS_ERR_NONE                      if the function was successful.
                    13097   ; *              OS_ERR_PRIO_EXIST                if the task priority already exist
                    13098   ; *                                               (each task MUST have a unique priority).
                    13099   ; *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
                    13100   ; *                                               allowed (i.e. > OS_LOWEST_PRIO)
                    13101   ; *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
                    13102   ; *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
                    13103   ; *                                               operation started.
                    13104   ; *********************************************************************************************************
                    13105   ; */
                    13106   ; /*$PAGE*/
                    13107   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    13108   ; INT8U  OSTaskCreateExt (void   (*task)(void *p_arg),
                    13109   ; void    *p_arg,
                    13110   ; OS_STK  *ptos,
                    13111   ; INT8U    prio,
                    13112   ; INT16U   id,
                    13113   ; OS_STK  *pbos,
                    13114   ; INT32U   stk_size,
                    13115   ; void    *pext,
                    13116   ; INT16U   opt)
                    13117   ; {
                    13118   _OSTaskCreateExt:
00004544  4E56 FFFC 13119          link      A6,#-4
00004548  48E7 3820 13120          movem.l   D2/D3/D4/A2,-(A7)
0000454C  142E 0017 13121          move.b    23(A6),D2
00004550  C4BC 0000 13122          and.l     #255,D2
00004554  00FF      
00004556  382E 002A 13123          move.w    42(A6),D4
0000455A  C8BC 0000 13124          and.l     #65535,D4
0000455E  FFFF      
00004560  45F9 0800 13125          lea       _OSTCBPrioTbl.L,A2
00004564  0438      
                    13126   ; OS_STK     *psp;
                    13127   ; INT8U       err;
                    13128   ; #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
                    13129   ; OS_CPU_SR   cpu_sr = 0u;
                    13130   ; #endif
                    13131   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    13132   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    13133   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    13134   ; return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
                    13135   ; }
                    13136   ; #endif
                    13137   ; #if OS_ARG_CHK_EN > 0u
                    13138   ; if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
                    13139   ; return (OS_ERR_PRIO_INVALID);
                    13140   ; }
                    13141   ; #endif
                    13142   ; OS_ENTER_CRITICAL();
00004566  40E7      13143          dc.w      16615
00004568  007C      13144          dc.w      124
0000456A  0700      13145          dc.w      1792
                    13146   ; if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
0000456C  1039 0800 13147          move.b    _OSIntNesting.L,D0
00004570  030E      
00004572  0C00 0000 13148          cmp.b     #0,D0
00004576  6308      13149          bls.s     OSTaskCreateExt_1
                    13150   ; OS_EXIT_CRITICAL();
00004578  46DF      13151          dc.w      18143
                    13152   ; return (OS_ERR_TASK_CREATE_ISR);
0000457A  703C      13153          moveq     #60,D0
0000457C  6000 00CC 13154          bra       OSTaskCreateExt_3
                    13155   OSTaskCreateExt_1:
                    13156   ; }
                    13157   ; if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
00004580  C4BC 0000 13158          and.l     #255,D2
00004584  00FF      
00004586  2002      13159          move.l    D2,D0
00004588  E588      13160          lsl.l     #2,D0
0000458A  2032 0800 13161          move.l    0(A2,D0.L),D0
0000458E  6600 00B6 13162          bne       OSTaskCreateExt_4
                    13163   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
00004592  C4BC 0000 13164          and.l     #255,D2
00004596  00FF      
00004598  2002      13165          move.l    D2,D0
0000459A  E588      13166          lsl.l     #2,D0
0000459C  25BC 0000 13167          move.l    #1,0(A2,D0.L)
000045A0  0001 0800 
                    13168   ; /* ... the same thing until task is created.              */
                    13169   ; OS_EXIT_CRITICAL();
000045A4  46DF      13170          dc.w      18143
                    13171   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u)
                    13172   ; OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
000045A6  C8BC 0000 13173          and.l     #65535,D4
000045AA  FFFF      
000045AC  2F04      13174          move.l    D4,-(A7)
000045AE  2F2E 0020 13175          move.l    32(A6),-(A7)
000045B2  2F2E 001C 13176          move.l    28(A6),-(A7)
000045B6  4EB9 0000 13177          jsr       _OS_TaskStkClr
000045BA  4D9E      
000045BC  DEFC 000C 13178          add.w     #12,A7
                    13179   ; #endif
                    13180   ; psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
000045C0  C8BC 0000 13181          and.l     #65535,D4
000045C4  FFFF      
000045C6  2F04      13182          move.l    D4,-(A7)
000045C8  2F2E 0010 13183          move.l    16(A6),-(A7)
000045CC  2F2E 000C 13184          move.l    12(A6),-(A7)
000045D0  2F2E 0008 13185          move.l    8(A6),-(A7)
000045D4  4EB8 07DC 13186          jsr       _OSTaskStkInit
000045D8  DEFC 0010 13187          add.w     #16,A7
000045DC  2D40 FFFC 13188          move.l    D0,-4(A6)
                    13189   ; err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
000045E0  C8BC 0000 13190          and.l     #65535,D4
000045E4  FFFF      
000045E6  2F04      13191          move.l    D4,-(A7)
000045E8  2F2E 0024 13192          move.l    36(A6),-(A7)
000045EC  2F2E 0020 13193          move.l    32(A6),-(A7)
000045F0  322E 001A 13194          move.w    26(A6),D1
000045F4  C2BC 0000 13195          and.l     #65535,D1
000045F8  FFFF      
000045FA  2F01      13196          move.l    D1,-(A7)
000045FC  2F2E 001C 13197          move.l    28(A6),-(A7)
00004600  2F2E FFFC 13198          move.l    -4(A6),-(A7)
00004604  C4BC 0000 13199          and.l     #255,D2
00004608  00FF      
0000460A  2F02      13200          move.l    D2,-(A7)
0000460C  4EB8 17F4 13201          jsr       _OS_TCBInit
00004610  DEFC 001C 13202          add.w     #28,A7
00004614  1600      13203          move.b    D0,D3
                    13204   ; if (err == OS_ERR_NONE) {
00004616  4A03      13205          tst.b     D3
00004618  6612      13206          bne.s     OSTaskCreateExt_6
                    13207   ; if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
0000461A  1039 0800 13208          move.b    _OSRunning.L,D0
0000461E  0320      
00004620  0C00 0001 13209          cmp.b     #1,D0
00004624  6604      13210          bne.s     OSTaskCreateExt_8
                    13211   ; OS_Sched();
00004626  4EB8 15DA 13212          jsr       _OS_Sched
                    13213   OSTaskCreateExt_8:
0000462A  6016      13214          bra.s     OSTaskCreateExt_7
                    13215   OSTaskCreateExt_6:
                    13216   ; }
                    13217   ; } else {
                    13218   ; OS_ENTER_CRITICAL();
0000462C  40E7      13219          dc.w      16615
0000462E  007C      13220          dc.w      124
00004630  0700      13221          dc.w      1792
                    13222   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
00004632  C4BC 0000 13223          and.l     #255,D2
00004636  00FF      
00004638  2002      13224          move.l    D2,D0
0000463A  E588      13225          lsl.l     #2,D0
0000463C  42B2 0800 13226          clr.l     0(A2,D0.L)
                    13227   ; OS_EXIT_CRITICAL();
00004640  46DF      13228          dc.w      18143
                    13229   OSTaskCreateExt_7:
                    13230   ; }
                    13231   ; return (err);
00004642  1003      13232          move.b    D3,D0
00004644  6004      13233          bra.s     OSTaskCreateExt_3
                    13234   OSTaskCreateExt_4:
                    13235   ; }
                    13236   ; OS_EXIT_CRITICAL();
00004646  46DF      13237          dc.w      18143
                    13238   ; return (OS_ERR_PRIO_EXIST);
00004648  7028      13239          moveq     #40,D0
                    13240   OSTaskCreateExt_3:
0000464A  4CDF 041C 13241          movem.l   (A7)+,D2/D3/D4/A2
0000464E  4E5E      13242          unlk      A6
00004650  4E75      13243          rts
                    13244   ; }
                    13245   ; #endif
                    13246   ; /*$PAGE*/
                    13247   ; /*
                    13248   ; *********************************************************************************************************
                    13249   ; *                                            DELETE A TASK
                    13250   ; *
                    13251   ; * Description: This function allows you to delete a task.  The calling task can delete itself by
                    13252   ; *              its own priority number.  The deleted task is returned to the dormant state and can be
                    13253   ; *              re-activated by creating the deleted task again.
                    13254   ; *
                    13255   ; * Arguments  : prio    is the priority of the task to delete.  Note that you can explicitly delete
                    13256   ; *                      the current task without knowing its priority level by setting 'prio' to
                    13257   ; *                      OS_PRIO_SELF.
                    13258   ; *
                    13259   ; * Returns    : OS_ERR_NONE             if the call is successful
                    13260   ; *              OS_ERR_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task
                    13261   ; *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
                    13262   ; *                                      (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    13263   ; *              OS_ERR_TASK_DEL         if the task is assigned to a Mutex PIP.
                    13264   ; *              OS_ERR_TASK_NOT_EXIST   if the task you want to delete does not exist.
                    13265   ; *              OS_ERR_TASK_DEL_ISR     if you tried to delete a task from an ISR
                    13266   ; *
                    13267   ; * Notes      : 1) To reduce interrupt latency, OSTaskDel() 'disables' the task:
                    13268   ; *                    a) by making it not ready
                    13269   ; *                    b) by removing it from any wait lists
                    13270   ; *                    c) by preventing OSTimeTick() from making the task ready to run.
                    13271   ; *                 The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.
                    13272   ; *              2) The function OS_Dummy() is called after OS_EXIT_CRITICAL() because, on most processors,
                    13273   ; *                 the next instruction following the enable interrupt instruction is ignored.
                    13274   ; *              3) An ISR cannot delete a task.
                    13275   ; *              4) The lock nesting counter is incremented because, for a brief instant, if the current
                    13276   ; *                 task is being deleted, the current task would not be able to be rescheduled because it
                    13277   ; *                 is removed from the ready list.  Incrementing the nesting counter prevents another task
                    13278   ; *                 from being schedule.  This means that an ISR would return to the current task which is
                    13279   ; *                 being deleted.  The rest of the deletion would thus be able to be completed.
                    13280   ; *********************************************************************************************************
                    13281   ; */
                    13282   ; #if OS_TASK_DEL_EN > 0u
                    13283   ; INT8U  OSTaskDel (INT8U prio)
                    13284   ; {
                    13285   _OSTaskDel:
00004652  4E56 0000 13286          link      A6,#0
00004656  48E7 3800 13287          movem.l   D2/D3/D4,-(A7)
0000465A  162E 000B 13288          move.b    11(A6),D3
0000465E  C6BC 0000 13289          and.l     #255,D3
00004662  00FF      
                    13290   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    13291   ; OS_FLAG_NODE *pnode;
                    13292   ; #endif
                    13293   ; OS_TCB       *ptcb;
                    13294   ; #if OS_CRITICAL_METHOD == 3u                            /* Allocate storage for CPU status register    */
                    13295   ; OS_CPU_SR     cpu_sr = 0u;
                    13296   ; #endif
                    13297   ; if (OSIntNesting > 0u) {                            /* See if trying to delete from ISR            */
00004664  1039 0800 13298          move.b    _OSIntNesting.L,D0
00004668  030E      
0000466A  0C00 0000 13299          cmp.b     #0,D0
0000466E  6306      13300          bls.s     OSTaskDel_1
                    13301   ; return (OS_ERR_TASK_DEL_ISR);
00004670  7040      13302          moveq     #64,D0
00004672  6000 01A4 13303          bra       OSTaskDel_3
                    13304   OSTaskDel_1:
                    13305   ; }
                    13306   ; if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
00004676  0C03 003F 13307          cmp.b     #63,D3
0000467A  6606      13308          bne.s     OSTaskDel_4
                    13309   ; return (OS_ERR_TASK_DEL_IDLE);
0000467C  703E      13310          moveq     #62,D0
0000467E  6000 0198 13311          bra       OSTaskDel_3
                    13312   OSTaskDel_4:
                    13313   ; }
                    13314   ; #if OS_ARG_CHK_EN > 0u
                    13315   ; if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
                    13316   ; if (prio != OS_PRIO_SELF) {
                    13317   ; return (OS_ERR_PRIO_INVALID);
                    13318   ; }
                    13319   ; }
                    13320   ; #endif
                    13321   ; /*$PAGE*/
                    13322   ; OS_ENTER_CRITICAL();
00004682  40E7      13323          dc.w      16615
00004684  007C      13324          dc.w      124
00004686  0700      13325          dc.w      1792
                    13326   ; if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
00004688  0C03 00FF 13327          cmp.b     #255,D3
0000468C  660A      13328          bne.s     OSTaskDel_6
                    13329   ; prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
0000468E  2079 0800 13330          move.l    _OSTCBCur.L,A0
00004692  0428      
00004694  1628 0034 13331          move.b    52(A0),D3
                    13332   OSTaskDel_6:
                    13333   ; }
                    13334   ; ptcb = OSTCBPrioTbl[prio];
00004698  C6BC 0000 13335          and.l     #255,D3
0000469C  00FF      
0000469E  2003      13336          move.l    D3,D0
000046A0  E588      13337          lsl.l     #2,D0
000046A2  41F9 0800 13338          lea       _OSTCBPrioTbl.L,A0
000046A6  0438      
000046A8  2430 0800 13339          move.l    0(A0,D0.L),D2
                    13340   ; if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
000046AC  4A82      13341          tst.l     D2
000046AE  6608      13342          bne.s     OSTaskDel_8
                    13343   ; OS_EXIT_CRITICAL();
000046B0  46DF      13344          dc.w      18143
                    13345   ; return (OS_ERR_TASK_NOT_EXIST);
000046B2  7043      13346          moveq     #67,D0
000046B4  6000 0162 13347          bra       OSTaskDel_3
                    13348   OSTaskDel_8:
                    13349   ; }
                    13350   ; if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
000046B8  0C82 0000 13351          cmp.l     #1,D2
000046BC  0001      
000046BE  6608      13352          bne.s     OSTaskDel_10
                    13353   ; OS_EXIT_CRITICAL();
000046C0  46DF      13354          dc.w      18143
                    13355   ; return (OS_ERR_TASK_DEL);
000046C2  703D      13356          moveq     #61,D0
000046C4  6000 0152 13357          bra       OSTaskDel_3
                    13358   OSTaskDel_10:
                    13359   ; }
                    13360   ; OSRdyTbl[ptcb->OSTCBY] &= (OS_PRIO)~ptcb->OSTCBBitX;
000046C8  2042      13361          move.l    D2,A0
000046CA  1028 0036 13362          move.b    54(A0),D0
000046CE  C0BC 0000 13363          and.l     #255,D0
000046D2  00FF      
000046D4  41F9 0800 13364          lea       _OSRdyTbl.L,A0
000046D8  0318      
000046DA  2242      13365          move.l    D2,A1
000046DC  1229 0037 13366          move.b    55(A1),D1
000046E0  4601      13367          not.b     D1
000046E2  C330 0800 13368          and.b     D1,0(A0,D0.L)
                    13369   ; if (OSRdyTbl[ptcb->OSTCBY] == 0u) {                 /* Make task not ready                         */
000046E6  2042      13370          move.l    D2,A0
000046E8  1028 0036 13371          move.b    54(A0),D0
000046EC  C0BC 0000 13372          and.l     #255,D0
000046F0  00FF      
000046F2  41F9 0800 13373          lea       _OSRdyTbl.L,A0
000046F6  0318      
000046F8  1030 0800 13374          move.b    0(A0,D0.L),D0
000046FC  660E      13375          bne.s     OSTaskDel_12
                    13376   ; OSRdyGrp           &= (OS_PRIO)~ptcb->OSTCBBitY;
000046FE  2042      13377          move.l    D2,A0
00004700  1028 0038 13378          move.b    56(A0),D0
00004704  4600      13379          not.b     D0
00004706  C139 0800 13380          and.b     D0,_OSRdyGrp.L
0000470A  0316      
                    13381   OSTaskDel_12:
                    13382   ; }
                    13383   ; #if (OS_EVENT_EN)
                    13384   ; if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
0000470C  2042      13385          move.l    D2,A0
0000470E  2028 001C 13386          move.l    28(A0),D0
00004712  670E      13387          beq.s     OSTaskDel_14
                    13388   ; OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
00004714  2042      13389          move.l    D2,A0
00004716  2F28 001C 13390          move.l    28(A0),-(A7)
0000471A  2F02      13391          move.l    D2,-(A7)
0000471C  4EB8 1200 13392          jsr       _OS_EventTaskRemove
00004720  504F      13393          addq.w    #8,A7
                    13394   OSTaskDel_14:
                    13395   ; }
                    13396   ; #if (OS_EVENT_MULTI_EN > 0u)
                    13397   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
00004722  2042      13398          move.l    D2,A0
00004724  2028 0020 13399          move.l    32(A0),D0
00004728  670E      13400          beq.s     OSTaskDel_16
                    13401   ; OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
0000472A  2042      13402          move.l    D2,A0
0000472C  2F28 0020 13403          move.l    32(A0),-(A7)
00004730  2F02      13404          move.l    D2,-(A7)
00004732  4EB8 1252 13405          jsr       _OS_EventTaskRemoveMulti
00004736  504F      13406          addq.w    #8,A7
                    13407   OSTaskDel_16:
                    13408   ; }
                    13409   ; #endif
                    13410   ; #endif
                    13411   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    13412   ; pnode = ptcb->OSTCBFlagNode;
00004738  2042      13413          move.l    D2,A0
0000473A  2828 0028 13414          move.l    40(A0),D4
                    13415   ; if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
0000473E  4A84      13416          tst.l     D4
00004740  6708      13417          beq.s     OSTaskDel_18
                    13418   ; OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
00004742  2F04      13419          move.l    D4,-(A7)
00004744  4EB8 240A 13420          jsr       _OS_FlagUnlink
00004748  584F      13421          addq.w    #4,A7
                    13422   OSTaskDel_18:
                    13423   ; }
                    13424   ; #endif
                    13425   ; ptcb->OSTCBDly      = 0u;                           /* Prevent OSTimeTick() from updating          */
0000474A  2042      13426          move.l    D2,A0
0000474C  42A8 002E 13427          clr.l     46(A0)
                    13428   ; ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
00004750  2042      13429          move.l    D2,A0
00004752  4228 0032 13430          clr.b     50(A0)
                    13431   ; ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
00004756  2042      13432          move.l    D2,A0
00004758  4228 0033 13433          clr.b     51(A0)
                    13434   ; if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
0000475C  1039 0800 13435          move.b    _OSLockNesting.L,D0
00004760  0310      
00004762  0C00 00FF 13436          cmp.b     #255,D0
00004766  6406      13437          bhs.s     OSTaskDel_20
                    13438   ; OSLockNesting++;
00004768  5239 0800 13439          addq.b    #1,_OSLockNesting.L
0000476C  0310      
                    13440   OSTaskDel_20:
                    13441   ; }
                    13442   ; OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
0000476E  46DF      13443          dc.w      18143
                    13444   ; OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
00004770  4EB8 0FF8 13445          jsr       _OS_Dummy
                    13446   ; OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
00004774  40E7      13447          dc.w      16615
00004776  007C      13448          dc.w      124
00004778  0700      13449          dc.w      1792
                    13450   ; if (OSLockNesting > 0u) {                           /* Remove context switch lock                  */
0000477A  1039 0800 13451          move.b    _OSLockNesting.L,D0
0000477E  0310      
00004780  0C00 0000 13452          cmp.b     #0,D0
00004784  6306      13453          bls.s     OSTaskDel_22
                    13454   ; OSLockNesting--;
00004786  5339 0800 13455          subq.b    #1,_OSLockNesting.L
0000478A  0310      
                    13456   OSTaskDel_22:
                    13457   ; }
                    13458   ; OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
0000478C  2F02      13459          move.l    D2,-(A7)
0000478E  4EB8 08C6 13460          jsr       _OSTaskDelHook
00004792  584F      13461          addq.w    #4,A7
                    13462   ; OSTaskCtr--;                                        /* One less task being managed                 */
00004794  5339 0800 13463          subq.b    #1,_OSTaskCtr.L
00004798  0322      
                    13464   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
0000479A  C6BC 0000 13465          and.l     #255,D3
0000479E  00FF      
000047A0  2003      13466          move.l    D3,D0
000047A2  E588      13467          lsl.l     #2,D0
000047A4  41F9 0800 13468          lea       _OSTCBPrioTbl.L,A0
000047A8  0438      
000047AA  42B0 0800 13469          clr.l     0(A0,D0.L)
                    13470   ; if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
000047AE  2042      13471          move.l    D2,A0
000047B0  2028 0018 13472          move.l    24(A0),D0
000047B4  6616      13473          bne.s     OSTaskDel_24
                    13474   ; ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
000047B6  2042      13475          move.l    D2,A0
000047B8  2068 0014 13476          move.l    20(A0),A0
000047BC  42A8 0018 13477          clr.l     24(A0)
                    13478   ; OSTCBList                  = ptcb->OSTCBNext;
000047C0  2042      13479          move.l    D2,A0
000047C2  23E8 0014 13480          move.l    20(A0),_OSTCBList.L
000047C6  0800 0434 
000047CA  601C      13481          bra.s     OSTaskDel_25
                    13482   OSTaskDel_24:
                    13483   ; } else {
                    13484   ; ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
000047CC  2042      13485          move.l    D2,A0
000047CE  2242      13486          move.l    D2,A1
000047D0  2269 0018 13487          move.l    24(A1),A1
000047D4  2368 0014 13488          move.l    20(A0),20(A1)
000047D8  0014      
                    13489   ; ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
000047DA  2042      13490          move.l    D2,A0
000047DC  2242      13491          move.l    D2,A1
000047DE  2269 0014 13492          move.l    20(A1),A1
000047E2  2368 0018 13493          move.l    24(A0),24(A1)
000047E6  0018      
                    13494   OSTaskDel_25:
                    13495   ; }
                    13496   ; ptcb->OSTCBNext     = OSTCBFreeList;                /* Return TCB to free TCB list                 */
000047E8  2042      13497          move.l    D2,A0
000047EA  2179 0800 13498          move.l    _OSTCBFreeList.L,20(A0)
000047EE  042C 0014 
                    13499   ; OSTCBFreeList       = ptcb;
000047F2  23C2 0800 13500          move.l    D2,_OSTCBFreeList.L
000047F6  042C      
                    13501   ; #if OS_TASK_NAME_EN > 0u
                    13502   ; ptcb->OSTCBTaskName = (INT8U *)(void *)"?";
000047F8  41F9 0000 13503          lea       @ucos_ii_1.L,A0
000047FC  708C      
000047FE  2242      13504          move.l    D2,A1
00004800  2348 004E 13505          move.l    A0,78(A1)
                    13506   ; #endif
                    13507   ; OS_EXIT_CRITICAL();
00004804  46DF      13508          dc.w      18143
                    13509   ; if (OSRunning == OS_TRUE) {
00004806  1039 0800 13510          move.b    _OSRunning.L,D0
0000480A  0320      
0000480C  0C00 0001 13511          cmp.b     #1,D0
00004810  6604      13512          bne.s     OSTaskDel_26
                    13513   ; OS_Sched();                                     /* Find new highest priority task              */
00004812  4EB8 15DA 13514          jsr       _OS_Sched
                    13515   OSTaskDel_26:
                    13516   ; }
                    13517   ; return (OS_ERR_NONE);
00004816  4200      13518          clr.b     D0
                    13519   OSTaskDel_3:
00004818  4CDF 001C 13520          movem.l   (A7)+,D2/D3/D4
0000481C  4E5E      13521          unlk      A6
0000481E  4E75      13522          rts
                    13523   ; }
                    13524   ; #endif
                    13525   ; /*$PAGE*/
                    13526   ; /*
                    13527   ; *********************************************************************************************************
                    13528   ; *                                  REQUEST THAT A TASK DELETE ITSELF
                    13529   ; *
                    13530   ; * Description: This function is used to:
                    13531   ; *                   a) notify a task to delete itself.
                    13532   ; *                   b) to see if a task requested that the current task delete itself.
                    13533   ; *              This function is a little tricky to understand.  Basically, you have a task that needs
                    13534   ; *              to be deleted however, this task has resources that it has allocated (memory buffers,
                    13535   ; *              semaphores, mailboxes, queues etc.).  The task cannot be deleted otherwise these
                    13536   ; *              resources would not be freed.  The requesting task calls OSTaskDelReq() to indicate that
                    13537   ; *              the task needs to be deleted.  Deleting of the task is however, deferred to the task to
                    13538   ; *              be deleted.  For example, suppose that task #10 needs to be deleted.  The requesting task
                    13539   ; *              example, task #5, would call OSTaskDelReq(10).  When task #10 gets to execute, it calls
                    13540   ; *              this function by specifying OS_PRIO_SELF and monitors the returned value.  If the return
                    13541   ; *              value is OS_ERR_TASK_DEL_REQ, another task requested a task delete.  Task #10 would look like
                    13542   ; *              this:
                    13543   ; *
                    13544   ; *                   void Task(void *p_arg)
                    13545   ; *                   {
                    13546   ; *                       .
                    13547   ; *                       .
                    13548   ; *                       while (1) {
                    13549   ; *                           OSTimeDly(1);
                    13550   ; *                           if (OSTaskDelReq(OS_PRIO_SELF) == OS_ERR_TASK_DEL_REQ) {
                    13551   ; *                               Release any owned resources;
                    13552   ; *                               De-allocate any dynamic memory;
                    13553   ; *                               OSTaskDel(OS_PRIO_SELF);
                    13554   ; *                           }
                    13555   ; *                       }
                    13556   ; *                   }
                    13557   ; *
                    13558   ; * Arguments  : prio    is the priority of the task to request the delete from
                    13559   ; *
                    13560   ; * Returns    : OS_ERR_NONE            if the task exist and the request has been registered
                    13561   ; *              OS_ERR_TASK_NOT_EXIST  if the task has been deleted.  This allows the caller to know whether
                    13562   ; *                                     the request has been executed.
                    13563   ; *              OS_ERR_TASK_DEL        if the task is assigned to a Mutex.
                    13564   ; *              OS_ERR_TASK_DEL_IDLE   if you requested to delete uC/OS-II's idle task
                    13565   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    13566   ; *                                     (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    13567   ; *              OS_ERR_TASK_DEL_REQ    if a task (possibly another task) requested that the running task be
                    13568   ; *                                     deleted.
                    13569   ; *********************************************************************************************************
                    13570   ; */
                    13571   ; /*$PAGE*/
                    13572   ; #if OS_TASK_DEL_EN > 0u
                    13573   ; INT8U  OSTaskDelReq (INT8U prio)
                    13574   ; {
                    13575   _OSTaskDelReq:
00004820  4E56 FFFC 13576          link      A6,#-4
00004824  48E7 3000 13577          movem.l   D2/D3,-(A7)
00004828  162E 000B 13578          move.b    11(A6),D3
0000482C  C6BC 0000 13579          and.l     #255,D3
00004830  00FF      
                    13580   ; INT8U      stat;
                    13581   ; OS_TCB    *ptcb;
                    13582   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    13583   ; OS_CPU_SR  cpu_sr = 0u;
                    13584   ; #endif
                    13585   ; if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
00004832  0C03 003F 13586          cmp.b     #63,D3
00004836  6606      13587          bne.s     OSTaskDelReq_1
                    13588   ; return (OS_ERR_TASK_DEL_IDLE);
00004838  703E      13589          moveq     #62,D0
0000483A  6000 0062 13590          bra       OSTaskDelReq_3
                    13591   OSTaskDelReq_1:
                    13592   ; }
                    13593   ; #if OS_ARG_CHK_EN > 0u
                    13594   ; if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
                    13595   ; if (prio != OS_PRIO_SELF) {
                    13596   ; return (OS_ERR_PRIO_INVALID);
                    13597   ; }
                    13598   ; }
                    13599   ; #endif
                    13600   ; if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
0000483E  0C03 00FF 13601          cmp.b     #255,D3
00004842  661C      13602          bne.s     OSTaskDelReq_4
                    13603   ; OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
00004844  40E7      13604          dc.w      16615
00004846  007C      13605          dc.w      124
00004848  0700      13606          dc.w      1792
                    13607   ; stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
0000484A  2079 0800 13608          move.l    _OSTCBCur.L,A0
0000484E  0428      
00004850  1D68 0039 13609          move.b    57(A0),-1(A6)
00004854  FFFF      
                    13610   ; OS_EXIT_CRITICAL();
00004856  46DF      13611          dc.w      18143
                    13612   ; return (stat);
00004858  102E FFFF 13613          move.b    -1(A6),D0
0000485C  6000 0040 13614          bra       OSTaskDelReq_3
                    13615   OSTaskDelReq_4:
                    13616   ; }
                    13617   ; OS_ENTER_CRITICAL();
00004860  40E7      13618          dc.w      16615
00004862  007C      13619          dc.w      124
00004864  0700      13620          dc.w      1792
                    13621   ; ptcb = OSTCBPrioTbl[prio];
00004866  C6BC 0000 13622          and.l     #255,D3
0000486A  00FF      
0000486C  2003      13623          move.l    D3,D0
0000486E  E588      13624          lsl.l     #2,D0
00004870  41F9 0800 13625          lea       _OSTCBPrioTbl.L,A0
00004874  0438      
00004876  2430 0800 13626          move.l    0(A0,D0.L),D2
                    13627   ; if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
0000487A  4A82      13628          tst.l     D2
0000487C  6606      13629          bne.s     OSTaskDelReq_6
                    13630   ; OS_EXIT_CRITICAL();
0000487E  46DF      13631          dc.w      18143
                    13632   ; return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
00004880  7043      13633          moveq     #67,D0
00004882  601A      13634          bra.s     OSTaskDelReq_3
                    13635   OSTaskDelReq_6:
                    13636   ; }
                    13637   ; if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
00004884  0C82 0000 13638          cmp.l     #1,D2
00004888  0001      
0000488A  6606      13639          bne.s     OSTaskDelReq_8
                    13640   ; OS_EXIT_CRITICAL();
0000488C  46DF      13641          dc.w      18143
                    13642   ; return (OS_ERR_TASK_DEL);
0000488E  703D      13643          moveq     #61,D0
00004890  600C      13644          bra.s     OSTaskDelReq_3
                    13645   OSTaskDelReq_8:
                    13646   ; }
                    13647   ; ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
00004892  2042      13648          move.l    D2,A0
00004894  117C 003F 13649          move.b    #63,57(A0)
00004898  0039      
                    13650   ; OS_EXIT_CRITICAL();
0000489A  46DF      13651          dc.w      18143
                    13652   ; return (OS_ERR_NONE);
0000489C  4200      13653          clr.b     D0
                    13654   OSTaskDelReq_3:
0000489E  4CDF 000C 13655          movem.l   (A7)+,D2/D3
000048A2  4E5E      13656          unlk      A6
000048A4  4E75      13657          rts
                    13658   ; }
                    13659   ; #endif
                    13660   ; /*$PAGE*/
                    13661   ; /*
                    13662   ; *********************************************************************************************************
                    13663   ; *                                       GET THE NAME OF A TASK
                    13664   ; *
                    13665   ; * Description: This function is called to obtain the name of a task.
                    13666   ; *
                    13667   ; * Arguments  : prio      is the priority of the task that you want to obtain the name from.
                    13668   ; *
                    13669   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the task.
                    13670   ; *
                    13671   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    13672   ; *
                    13673   ; *                        OS_ERR_NONE                if the requested task is resumed
                    13674   ; *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
                    13675   ; *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
                    13676   ; *                                                   A higher value than the idle task or not OS_PRIO_SELF.
                    13677   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    13678   ; *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
                    13679   ; *
                    13680   ; *
                    13681   ; * Returns    : The length of the string or 0 if the task does not exist.
                    13682   ; *********************************************************************************************************
                    13683   ; */
                    13684   ; #if OS_TASK_NAME_EN > 0u
                    13685   ; INT8U  OSTaskNameGet (INT8U    prio,
                    13686   ; INT8U  **pname,
                    13687   ; INT8U   *perr)
                    13688   ; {
                    13689   _OSTaskNameGet:
000048A6  4E56 FFFC 13690          link      A6,#-4
000048AA  48E7 3800 13691          movem.l   D2/D3/D4,-(A7)
000048AE  262E 0010 13692          move.l    16(A6),D3
000048B2  182E 000B 13693          move.b    11(A6),D4
000048B6  C8BC 0000 13694          and.l     #255,D4
000048BA  00FF      
                    13695   ; OS_TCB    *ptcb;
                    13696   ; INT8U      len;
                    13697   ; #if OS_CRITICAL_METHOD == 3u                             /* Allocate storage for CPU status register   */
                    13698   ; OS_CPU_SR  cpu_sr = 0u;
                    13699   ; #endif
                    13700   ; #ifdef OS_SAFETY_CRITICAL
                    13701   ; if (perr == (INT8U *)0) {
                    13702   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    13703   ; return (0u);
                    13704   ; }
                    13705   ; #endif
                    13706   ; #if OS_ARG_CHK_EN > 0u
                    13707   ; if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
                    13708   ; if (prio != OS_PRIO_SELF) {
                    13709   ; *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
                    13710   ; return (0u);
                    13711   ; }
                    13712   ; }
                    13713   ; if (pname == (INT8U **)0) {                          /* Is 'pname' a NULL pointer?                 */
                    13714   ; *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
                    13715   ; return (0u);
                    13716   ; }
                    13717   ; #endif
                    13718   ; if (OSIntNesting > 0u) {                              /* See if trying to call from an ISR          */
000048BC  1039 0800 13719          move.b    _OSIntNesting.L,D0
000048C0  030E      
000048C2  0C00 0000 13720          cmp.b     #0,D0
000048C6  630C      13721          bls.s     OSTaskNameGet_1
                    13722   ; *perr = OS_ERR_NAME_GET_ISR;
000048C8  2043      13723          move.l    D3,A0
000048CA  10BC 0011 13724          move.b    #17,(A0)
                    13725   ; return (0u);
000048CE  4200      13726          clr.b     D0
000048D0  6000 0076 13727          bra       OSTaskNameGet_3
                    13728   OSTaskNameGet_1:
                    13729   ; }
                    13730   ; OS_ENTER_CRITICAL();
000048D4  40E7      13731          dc.w      16615
000048D6  007C      13732          dc.w      124
000048D8  0700      13733          dc.w      1792
                    13734   ; if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
000048DA  0C04 00FF 13735          cmp.b     #255,D4
000048DE  660A      13736          bne.s     OSTaskNameGet_4
                    13737   ; prio = OSTCBCur->OSTCBPrio;
000048E0  2079 0800 13738          move.l    _OSTCBCur.L,A0
000048E4  0428      
000048E6  1828 0034 13739          move.b    52(A0),D4
                    13740   OSTaskNameGet_4:
                    13741   ; }
                    13742   ; ptcb = OSTCBPrioTbl[prio];
000048EA  C8BC 0000 13743          and.l     #255,D4
000048EE  00FF      
000048F0  2004      13744          move.l    D4,D0
000048F2  E588      13745          lsl.l     #2,D0
000048F4  41F9 0800 13746          lea       _OSTCBPrioTbl.L,A0
000048F8  0438      
000048FA  2430 0800 13747          move.l    0(A0,D0.L),D2
                    13748   ; if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
000048FE  4A82      13749          tst.l     D2
00004900  660E      13750          bne.s     OSTaskNameGet_6
                    13751   ; OS_EXIT_CRITICAL();                              /* No                                         */
00004902  46DF      13752          dc.w      18143
                    13753   ; *perr = OS_ERR_TASK_NOT_EXIST;
00004904  2043      13754          move.l    D3,A0
00004906  10BC 0043 13755          move.b    #67,(A0)
                    13756   ; return (0u);
0000490A  4200      13757          clr.b     D0
0000490C  6000 003A 13758          bra       OSTaskNameGet_3
                    13759   OSTaskNameGet_6:
                    13760   ; }
                    13761   ; if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
00004910  0C82 0000 13762          cmp.l     #1,D2
00004914  0001      
00004916  660C      13763          bne.s     OSTaskNameGet_8
                    13764   ; OS_EXIT_CRITICAL();                              /* Yes                                        */
00004918  46DF      13765          dc.w      18143
                    13766   ; *perr = OS_ERR_TASK_NOT_EXIST;
0000491A  2043      13767          move.l    D3,A0
0000491C  10BC 0043 13768          move.b    #67,(A0)
                    13769   ; return (0u);
00004920  4200      13770          clr.b     D0
00004922  6024      13771          bra.s     OSTaskNameGet_3
                    13772   OSTaskNameGet_8:
                    13773   ; }
                    13774   ; *pname = ptcb->OSTCBTaskName;
00004924  2042      13775          move.l    D2,A0
00004926  226E 000C 13776          move.l    12(A6),A1
0000492A  22A8 004E 13777          move.l    78(A0),(A1)
                    13778   ; len    = OS_StrLen(*pname);
0000492E  206E 000C 13779          move.l    12(A6),A0
00004932  2F10      13780          move.l    (A0),-(A7)
00004934  4EB8 1684 13781          jsr       _OS_StrLen
00004938  584F      13782          addq.w    #4,A7
0000493A  1D40 FFFF 13783          move.b    D0,-1(A6)
                    13784   ; OS_EXIT_CRITICAL();
0000493E  46DF      13785          dc.w      18143
                    13786   ; *perr  = OS_ERR_NONE;
00004940  2043      13787          move.l    D3,A0
00004942  4210      13788          clr.b     (A0)
                    13789   ; return (len);
00004944  102E FFFF 13790          move.b    -1(A6),D0
                    13791   OSTaskNameGet_3:
00004948  4CDF 001C 13792          movem.l   (A7)+,D2/D3/D4
0000494C  4E5E      13793          unlk      A6
0000494E  4E75      13794          rts
                    13795   ; }
                    13796   ; #endif
                    13797   ; /*$PAGE*/
                    13798   ; /*
                    13799   ; *********************************************************************************************************
                    13800   ; *                                       ASSIGN A NAME TO A TASK
                    13801   ; *
                    13802   ; * Description: This function is used to set the name of a task.
                    13803   ; *
                    13804   ; * Arguments  : prio      is the priority of the task that you want the assign a name to.
                    13805   ; *
                    13806   ; *              pname     is a pointer to an ASCII string that contains the name of the task.
                    13807   ; *
                    13808   ; *              perr       is a pointer to an error code that can contain one of the following values:
                    13809   ; *
                    13810   ; *                        OS_ERR_NONE                if the requested task is resumed
                    13811   ; *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
                    13812   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    13813   ; *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
                    13814   ; *                                                   A higher value than the idle task or not OS_PRIO_SELF.
                    13815   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    13816   ; *
                    13817   ; * Returns    : None
                    13818   ; *********************************************************************************************************
                    13819   ; */
                    13820   ; #if OS_TASK_NAME_EN > 0u
                    13821   ; void  OSTaskNameSet (INT8U   prio,
                    13822   ; INT8U  *pname,
                    13823   ; INT8U  *perr)
                    13824   ; {
                    13825   _OSTaskNameSet:
00004950  4E56 0000 13826          link      A6,#0
00004954  48E7 3800 13827          movem.l   D2/D3/D4,-(A7)
00004958  262E 0010 13828          move.l    16(A6),D3
0000495C  182E 000B 13829          move.b    11(A6),D4
00004960  C8BC 0000 13830          and.l     #255,D4
00004964  00FF      
                    13831   ; OS_TCB    *ptcb;
                    13832   ; #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
                    13833   ; OS_CPU_SR  cpu_sr = 0u;
                    13834   ; #endif
                    13835   ; #ifdef OS_SAFETY_CRITICAL
                    13836   ; if (perr == (INT8U *)0) {
                    13837   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    13838   ; return;
                    13839   ; }
                    13840   ; #endif
                    13841   ; #if OS_ARG_CHK_EN > 0u
                    13842   ; if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
                    13843   ; if (prio != OS_PRIO_SELF) {
                    13844   ; *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
                    13845   ; return;
                    13846   ; }
                    13847   ; }
                    13848   ; if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
                    13849   ; *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
                    13850   ; return;
                    13851   ; }
                    13852   ; #endif
                    13853   ; if (OSIntNesting > 0u) {                         /* See if trying to call from an ISR              */
00004966  1039 0800 13854          move.b    _OSIntNesting.L,D0
0000496A  030E      
0000496C  0C00 0000 13855          cmp.b     #0,D0
00004970  630A      13856          bls.s     OSTaskNameSet_1
                    13857   ; *perr = OS_ERR_NAME_SET_ISR;
00004972  2043      13858          move.l    D3,A0
00004974  10BC 0012 13859          move.b    #18,(A0)
                    13860   ; return;
00004978  6000 005A 13861          bra       OSTaskNameSet_3
                    13862   OSTaskNameSet_1:
                    13863   ; }
                    13864   ; OS_ENTER_CRITICAL();
0000497C  40E7      13865          dc.w      16615
0000497E  007C      13866          dc.w      124
00004980  0700      13867          dc.w      1792
                    13868   ; if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
00004982  0C04 00FF 13869          cmp.b     #255,D4
00004986  660A      13870          bne.s     OSTaskNameSet_4
                    13871   ; prio = OSTCBCur->OSTCBPrio;
00004988  2079 0800 13872          move.l    _OSTCBCur.L,A0
0000498C  0428      
0000498E  1828 0034 13873          move.b    52(A0),D4
                    13874   OSTaskNameSet_4:
                    13875   ; }
                    13876   ; ptcb = OSTCBPrioTbl[prio];
00004992  C8BC 0000 13877          and.l     #255,D4
00004996  00FF      
00004998  2004      13878          move.l    D4,D0
0000499A  E588      13879          lsl.l     #2,D0
0000499C  41F9 0800 13880          lea       _OSTCBPrioTbl.L,A0
000049A0  0438      
000049A2  2430 0800 13881          move.l    0(A0,D0.L),D2
                    13882   ; if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
000049A6  4A82      13883          tst.l     D2
000049A8  660A      13884          bne.s     OSTaskNameSet_6
                    13885   ; OS_EXIT_CRITICAL();                          /* No                                             */
000049AA  46DF      13886          dc.w      18143
                    13887   ; *perr = OS_ERR_TASK_NOT_EXIST;
000049AC  2043      13888          move.l    D3,A0
000049AE  10BC 0043 13889          move.b    #67,(A0)
                    13890   ; return;
000049B2  6020      13891          bra.s     OSTaskNameSet_3
                    13892   OSTaskNameSet_6:
                    13893   ; }
                    13894   ; if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
000049B4  0C82 0000 13895          cmp.l     #1,D2
000049B8  0001      
000049BA  660A      13896          bne.s     OSTaskNameSet_8
                    13897   ; OS_EXIT_CRITICAL();                          /* Yes                                            */
000049BC  46DF      13898          dc.w      18143
                    13899   ; *perr = OS_ERR_TASK_NOT_EXIST;
000049BE  2043      13900          move.l    D3,A0
000049C0  10BC 0043 13901          move.b    #67,(A0)
                    13902   ; return;
000049C4  600E      13903          bra.s     OSTaskNameSet_3
                    13904   OSTaskNameSet_8:
                    13905   ; }
                    13906   ; ptcb->OSTCBTaskName = pname;
000049C6  2042      13907          move.l    D2,A0
000049C8  216E 000C 13908          move.l    12(A6),78(A0)
000049CC  004E      
                    13909   ; OS_EXIT_CRITICAL();
000049CE  46DF      13910          dc.w      18143
                    13911   ; *perr               = OS_ERR_NONE;
000049D0  2043      13912          move.l    D3,A0
000049D2  4210      13913          clr.b     (A0)
                    13914   OSTaskNameSet_3:
000049D4  4CDF 001C 13915          movem.l   (A7)+,D2/D3/D4
000049D8  4E5E      13916          unlk      A6
000049DA  4E75      13917          rts
                    13918   ; }
                    13919   ; #endif
                    13920   ; /*$PAGE*/
                    13921   ; /*
                    13922   ; *********************************************************************************************************
                    13923   ; *                                       RESUME A SUSPENDED TASK
                    13924   ; *
                    13925   ; * Description: This function is called to resume a previously suspended task.  This is the only call that
                    13926   ; *              will remove an explicit task suspension.
                    13927   ; *
                    13928   ; * Arguments  : prio     is the priority of the task to resume.
                    13929   ; *
                    13930   ; * Returns    : OS_ERR_NONE                if the requested task is resumed
                    13931   ; *              OS_ERR_PRIO_INVALID        if the priority you specify is higher that the maximum allowed
                    13932   ; *                                         (i.e. >= OS_LOWEST_PRIO)
                    13933   ; *              OS_ERR_TASK_RESUME_PRIO    if the task to resume does not exist
                    13934   ; *              OS_ERR_TASK_NOT_EXIST      if the task is assigned to a Mutex PIP
                    13935   ; *              OS_ERR_TASK_NOT_SUSPENDED  if the task to resume has not been suspended
                    13936   ; *********************************************************************************************************
                    13937   ; */
                    13938   ; #if OS_TASK_SUSPEND_EN > 0u
                    13939   ; INT8U  OSTaskResume (INT8U prio)
                    13940   ; {
                    13941   _OSTaskResume:
000049DC  4E56 0000 13942          link      A6,#0
000049E0  2F02      13943          move.l    D2,-(A7)
                    13944   ; OS_TCB    *ptcb;
                    13945   ; #if OS_CRITICAL_METHOD == 3u                                  /* Storage for CPU status register       */
                    13946   ; OS_CPU_SR  cpu_sr = 0u;
                    13947   ; #endif
                    13948   ; #if OS_ARG_CHK_EN > 0u
                    13949   ; if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
                    13950   ; return (OS_ERR_PRIO_INVALID);
                    13951   ; }
                    13952   ; #endif
                    13953   ; OS_ENTER_CRITICAL();
000049E2  40E7      13954          dc.w      16615
000049E4  007C      13955          dc.w      124
000049E6  0700      13956          dc.w      1792
                    13957   ; ptcb = OSTCBPrioTbl[prio];
000049E8  102E 000B 13958          move.b    11(A6),D0
000049EC  C0BC 0000 13959          and.l     #255,D0
000049F0  00FF      
000049F2  E588      13960          lsl.l     #2,D0
000049F4  41F9 0800 13961          lea       _OSTCBPrioTbl.L,A0
000049F8  0438      
000049FA  2430 0800 13962          move.l    0(A0,D0.L),D2
                    13963   ; if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
000049FE  4A82      13964          tst.l     D2
00004A00  6608      13965          bne.s     OSTaskResume_1
                    13966   ; OS_EXIT_CRITICAL();
00004A02  46DF      13967          dc.w      18143
                    13968   ; return (OS_ERR_TASK_RESUME_PRIO);
00004A04  7046      13969          moveq     #70,D0
00004A06  6000 0088 13970          bra       OSTaskResume_3
                    13971   OSTaskResume_1:
                    13972   ; }
                    13973   ; if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
00004A0A  0C82 0000 13974          cmp.l     #1,D2
00004A0E  0001      
00004A10  6608      13975          bne.s     OSTaskResume_4
                    13976   ; OS_EXIT_CRITICAL();
00004A12  46DF      13977          dc.w      18143
                    13978   ; return (OS_ERR_TASK_NOT_EXIST);
00004A14  7043      13979          moveq     #67,D0
00004A16  6000 0078 13980          bra       OSTaskResume_3
                    13981   OSTaskResume_4:
                    13982   ; }
                    13983   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
00004A1A  2042      13984          move.l    D2,A0
00004A1C  1028 0032 13985          move.b    50(A0),D0
00004A20  C03C 0008 13986          and.b     #8,D0
00004A24  6700 0066 13987          beq       OSTaskResume_6
                    13988   ; ptcb->OSTCBStat &= (INT8U)~(INT8U)OS_STAT_SUSPEND;    /* Remove suspension                     */
00004A28  2042      13989          move.l    D2,A0
00004A2A  7008      13990          moveq     #8,D0
00004A2C  4600      13991          not.b     D0
00004A2E  C128 0032 13992          and.b     D0,50(A0)
                    13993   ; if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
00004A32  2042      13994          move.l    D2,A0
00004A34  1028 0032 13995          move.b    50(A0),D0
00004A38  6600 004C 13996          bne       OSTaskResume_8
                    13997   ; if (ptcb->OSTCBDly == 0u) {
00004A3C  2042      13998          move.l    D2,A0
00004A3E  2028 002E 13999          move.l    46(A0),D0
00004A42  6600 003E 14000          bne       OSTaskResume_10
                    14001   ; OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
00004A46  2042      14002          move.l    D2,A0
00004A48  1028 0038 14003          move.b    56(A0),D0
00004A4C  8139 0800 14004          or.b      D0,_OSRdyGrp.L
00004A50  0316      
                    14005   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00004A52  2042      14006          move.l    D2,A0
00004A54  1028 0036 14007          move.b    54(A0),D0
00004A58  C0BC 0000 14008          and.l     #255,D0
00004A5C  00FF      
00004A5E  41F9 0800 14009          lea       _OSRdyTbl.L,A0
00004A62  0318      
00004A64  2242      14010          move.l    D2,A1
00004A66  1229 0037 14011          move.b    55(A1),D1
00004A6A  8330 0800 14012          or.b      D1,0(A0,D0.L)
                    14013   ; OS_EXIT_CRITICAL();
00004A6E  46DF      14014          dc.w      18143
                    14015   ; if (OSRunning == OS_TRUE) {
00004A70  1039 0800 14016          move.b    _OSRunning.L,D0
00004A74  0320      
00004A76  0C00 0001 14017          cmp.b     #1,D0
00004A7A  6604      14018          bne.s     OSTaskResume_12
                    14019   ; OS_Sched();                               /* Find new highest priority task        */
00004A7C  4EB8 15DA 14020          jsr       _OS_Sched
                    14021   OSTaskResume_12:
00004A80  6002      14022          bra.s     OSTaskResume_11
                    14023   OSTaskResume_10:
                    14024   ; }
                    14025   ; } else {
                    14026   ; OS_EXIT_CRITICAL();
00004A82  46DF      14027          dc.w      18143
                    14028   OSTaskResume_11:
00004A84  6002      14029          bra.s     OSTaskResume_9
                    14030   OSTaskResume_8:
                    14031   ; }
                    14032   ; } else {                                              /* Must be pending on event              */
                    14033   ; OS_EXIT_CRITICAL();
00004A86  46DF      14034          dc.w      18143
                    14035   OSTaskResume_9:
                    14036   ; }
                    14037   ; return (OS_ERR_NONE);
00004A88  4200      14038          clr.b     D0
00004A8A  6004      14039          bra.s     OSTaskResume_3
                    14040   OSTaskResume_6:
                    14041   ; }
                    14042   ; OS_EXIT_CRITICAL();
00004A8C  46DF      14043          dc.w      18143
                    14044   ; return (OS_ERR_TASK_NOT_SUSPENDED);
00004A8E  7044      14045          moveq     #68,D0
                    14046   OSTaskResume_3:
00004A90  241F      14047          move.l    (A7)+,D2
00004A92  4E5E      14048          unlk      A6
00004A94  4E75      14049          rts
                    14050   ; }
                    14051   ; #endif
                    14052   ; /*$PAGE*/
                    14053   ; /*
                    14054   ; *********************************************************************************************************
                    14055   ; *                                           STACK CHECKING
                    14056   ; *
                    14057   ; * Description: This function is called to check the amount of free memory left on the specified task's
                    14058   ; *              stack.
                    14059   ; *
                    14060   ; * Arguments  : prio          is the task priority
                    14061   ; *
                    14062   ; *              p_stk_data    is a pointer to a data structure of type OS_STK_DATA.
                    14063   ; *
                    14064   ; * Returns    : OS_ERR_NONE            upon success
                    14065   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    14066   ; *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14067   ; *              OS_ERR_TASK_NOT_EXIST  if the desired task has not been created or is assigned to a Mutex PIP
                    14068   ; *              OS_ERR_TASK_OPT        if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
                    14069   ; *              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
                    14070   ; *********************************************************************************************************
                    14071   ; */
                    14072   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    14073   ; INT8U  OSTaskStkChk (INT8U         prio,
                    14074   ; OS_STK_DATA  *p_stk_data)
                    14075   ; {
                    14076   _OSTaskStkChk:
00004A96  4E56 FFF8 14077          link      A6,#-8
00004A9A  48E7 3C00 14078          movem.l   D2/D3/D4/D5,-(A7)
00004A9E  282E 000C 14079          move.l    12(A6),D4
00004AA2  1A2E 000B 14080          move.b    11(A6),D5
00004AA6  CABC 0000 14081          and.l     #255,D5
00004AAA  00FF      
                    14082   ; OS_TCB    *ptcb;
                    14083   ; OS_STK    *pchk;
                    14084   ; INT32U     nfree;
                    14085   ; INT32U     size;
                    14086   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    14087   ; OS_CPU_SR  cpu_sr = 0u;
                    14088   ; #endif
                    14089   ; #if OS_ARG_CHK_EN > 0u
                    14090   ; if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
                    14091   ; if (prio != OS_PRIO_SELF) {
                    14092   ; return (OS_ERR_PRIO_INVALID);
                    14093   ; }
                    14094   ; }
                    14095   ; if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
                    14096   ; return (OS_ERR_PDATA_NULL);
                    14097   ; }
                    14098   ; #endif
                    14099   ; p_stk_data->OSFree = 0u;                           /* Assume failure, set to 0 size                */
00004AAC  2044      14100          move.l    D4,A0
00004AAE  4290      14101          clr.l     (A0)
                    14102   ; p_stk_data->OSUsed = 0u;
00004AB0  2044      14103          move.l    D4,A0
00004AB2  42A8 0004 14104          clr.l     4(A0)
                    14105   ; OS_ENTER_CRITICAL();
00004AB6  40E7      14106          dc.w      16615
00004AB8  007C      14107          dc.w      124
00004ABA  0700      14108          dc.w      1792
                    14109   ; if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
00004ABC  0C05 00FF 14110          cmp.b     #255,D5
00004AC0  660A      14111          bne.s     OSTaskStkChk_1
                    14112   ; prio = OSTCBCur->OSTCBPrio;
00004AC2  2079 0800 14113          move.l    _OSTCBCur.L,A0
00004AC6  0428      
00004AC8  1A28 0034 14114          move.b    52(A0),D5
                    14115   OSTaskStkChk_1:
                    14116   ; }
                    14117   ; ptcb = OSTCBPrioTbl[prio];
00004ACC  CABC 0000 14118          and.l     #255,D5
00004AD0  00FF      
00004AD2  2005      14119          move.l    D5,D0
00004AD4  E588      14120          lsl.l     #2,D0
00004AD6  41F9 0800 14121          lea       _OSTCBPrioTbl.L,A0
00004ADA  0438      
00004ADC  2430 0800 14122          move.l    0(A0,D0.L),D2
                    14123   ; if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
00004AE0  4A82      14124          tst.l     D2
00004AE2  6608      14125          bne.s     OSTaskStkChk_3
                    14126   ; OS_EXIT_CRITICAL();
00004AE4  46DF      14127          dc.w      18143
                    14128   ; return (OS_ERR_TASK_NOT_EXIST);
00004AE6  7043      14129          moveq     #67,D0
00004AE8  6000 005C 14130          bra       OSTaskStkChk_5
                    14131   OSTaskStkChk_3:
                    14132   ; }
                    14133   ; if (ptcb == OS_TCB_RESERVED) {
00004AEC  0C82 0000 14134          cmp.l     #1,D2
00004AF0  0001      
00004AF2  6608      14135          bne.s     OSTaskStkChk_6
                    14136   ; OS_EXIT_CRITICAL();
00004AF4  46DF      14137          dc.w      18143
                    14138   ; return (OS_ERR_TASK_NOT_EXIST);
00004AF6  7043      14139          moveq     #67,D0
00004AF8  6000 004C 14140          bra       OSTaskStkChk_5
                    14141   OSTaskStkChk_6:
                    14142   ; }
                    14143   ; if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0u) { /* Make sure stack checking option is set      */
00004AFC  2042      14144          move.l    D2,A0
00004AFE  3028 0010 14145          move.w    16(A0),D0
00004B02  C07C 0001 14146          and.w     #1,D0
00004B06  6608      14147          bne.s     OSTaskStkChk_8
                    14148   ; OS_EXIT_CRITICAL();
00004B08  46DF      14149          dc.w      18143
                    14150   ; return (OS_ERR_TASK_OPT);
00004B0A  7045      14151          moveq     #69,D0
00004B0C  6000 0038 14152          bra       OSTaskStkChk_5
                    14153   OSTaskStkChk_8:
                    14154   ; }
                    14155   ; nfree = 0u;
00004B10  4283      14156          clr.l     D3
                    14157   ; size  = ptcb->OSTCBStkSize;
00004B12  2042      14158          move.l    D2,A0
00004B14  2D68 000C 14159          move.l    12(A0),-4(A6)
00004B18  FFFC      
                    14160   ; pchk  = ptcb->OSTCBStkBottom;
00004B1A  2042      14161          move.l    D2,A0
00004B1C  2D68 0008 14162          move.l    8(A0),-8(A6)
00004B20  FFF8      
                    14163   ; OS_EXIT_CRITICAL();
00004B22  46DF      14164          dc.w      18143
                    14165   ; #if OS_STK_GROWTH == 1u
                    14166   ; while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
                    14167   OSTaskStkChk_10:
00004B24  206E FFF8 14168          move.l    -8(A6),A0
00004B28  54AE FFF8 14169          addq.l    #2,-8(A6)
00004B2C  3010      14170          move.w    (A0),D0
00004B2E  6604      14171          bne.s     OSTaskStkChk_12
                    14172   ; nfree++;
00004B30  5283      14173          addq.l    #1,D3
00004B32  60F0      14174          bra       OSTaskStkChk_10
                    14175   OSTaskStkChk_12:
                    14176   ; }
                    14177   ; #else
                    14178   ; while (*pchk-- == (OS_STK)0) {
                    14179   ; nfree++;
                    14180   ; }
                    14181   ; #endif
                    14182   ; p_stk_data->OSFree = nfree;                       /* Store   number of free entries on the stk     */
00004B34  2044      14183          move.l    D4,A0
00004B36  2083      14184          move.l    D3,(A0)
                    14185   ; p_stk_data->OSUsed = size - nfree;                /* Compute number of entries used on the stk     */
00004B38  202E FFFC 14186          move.l    -4(A6),D0
00004B3C  9083      14187          sub.l     D3,D0
00004B3E  2044      14188          move.l    D4,A0
00004B40  2140 0004 14189          move.l    D0,4(A0)
                    14190   ; return (OS_ERR_NONE);
00004B44  4200      14191          clr.b     D0
                    14192   OSTaskStkChk_5:
00004B46  4CDF 003C 14193          movem.l   (A7)+,D2/D3/D4/D5
00004B4A  4E5E      14194          unlk      A6
00004B4C  4E75      14195          rts
                    14196   ; }
                    14197   ; #endif
                    14198   ; /*$PAGE*/
                    14199   ; /*
                    14200   ; *********************************************************************************************************
                    14201   ; *                                           SUSPEND A TASK
                    14202   ; *
                    14203   ; * Description: This function is called to suspend a task.  The task can be the calling task if the
                    14204   ; *              priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SELF.
                    14205   ; *
                    14206   ; * Arguments  : prio     is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the
                    14207   ; *                       calling task will suspend itself and rescheduling will occur.
                    14208   ; *
                    14209   ; * Returns    : OS_ERR_NONE               if the requested task is suspended
                    14210   ; *              OS_ERR_TASK_SUSPEND_IDLE  if you attempted to suspend the idle task which is not allowed.
                    14211   ; *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
                    14212   ; *                                        (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14213   ; *              OS_ERR_TASK_SUSPEND_PRIO  if the task to suspend does not exist
                    14214   ; *              OS_ERR_TASK_NOT_EXITS     if the task is assigned to a Mutex PIP
                    14215   ; *
                    14216   ; * Note       : You should use this function with great care.  If you suspend a task that is waiting for
                    14217   ; *              an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from
                    14218   ; *              running when the event arrives.
                    14219   ; *********************************************************************************************************
                    14220   ; */
                    14221   ; #if OS_TASK_SUSPEND_EN > 0u
                    14222   ; INT8U  OSTaskSuspend (INT8U prio)
                    14223   ; {
                    14224   _OSTaskSuspend:
00004B4E  4E56 0000 14225          link      A6,#0
00004B52  48E7 3C00 14226          movem.l   D2/D3/D4/D5,-(A7)
00004B56  182E 000B 14227          move.b    11(A6),D4
00004B5A  C8BC 0000 14228          and.l     #255,D4
00004B5E  00FF      
                    14229   ; BOOLEAN    self;
                    14230   ; OS_TCB    *ptcb;
                    14231   ; INT8U      y;
                    14232   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14233   ; OS_CPU_SR  cpu_sr = 0u;
                    14234   ; #endif
                    14235   ; #if OS_ARG_CHK_EN > 0u
                    14236   ; if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
                    14237   ; return (OS_ERR_TASK_SUSPEND_IDLE);
                    14238   ; }
                    14239   ; if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
                    14240   ; if (prio != OS_PRIO_SELF) {
                    14241   ; return (OS_ERR_PRIO_INVALID);
                    14242   ; }
                    14243   ; }
                    14244   ; #endif
                    14245   ; OS_ENTER_CRITICAL();
00004B60  40E7      14246          dc.w      16615
00004B62  007C      14247          dc.w      124
00004B64  0700      14248          dc.w      1792
                    14249   ; if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
00004B66  0C04 00FF 14250          cmp.b     #255,D4
00004B6A  660E      14251          bne.s     OSTaskSuspend_1
                    14252   ; prio = OSTCBCur->OSTCBPrio;
00004B6C  2079 0800 14253          move.l    _OSTCBCur.L,A0
00004B70  0428      
00004B72  1828 0034 14254          move.b    52(A0),D4
                    14255   ; self = OS_TRUE;
00004B76  7601      14256          moveq     #1,D3
00004B78  6012      14257          bra.s     OSTaskSuspend_4
                    14258   OSTaskSuspend_1:
                    14259   ; } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
00004B7A  2079 0800 14260          move.l    _OSTCBCur.L,A0
00004B7E  0428      
00004B80  B828 0034 14261          cmp.b     52(A0),D4
00004B84  6604      14262          bne.s     OSTaskSuspend_3
                    14263   ; self = OS_TRUE;
00004B86  7601      14264          moveq     #1,D3
00004B88  6002      14265          bra.s     OSTaskSuspend_4
                    14266   OSTaskSuspend_3:
                    14267   ; } else {
                    14268   ; self = OS_FALSE;                                        /* No suspending another task          */
00004B8A  4203      14269          clr.b     D3
                    14270   OSTaskSuspend_4:
                    14271   ; }
                    14272   ; ptcb = OSTCBPrioTbl[prio];
00004B8C  C8BC 0000 14273          and.l     #255,D4
00004B90  00FF      
00004B92  2004      14274          move.l    D4,D0
00004B94  E588      14275          lsl.l     #2,D0
00004B96  41F9 0800 14276          lea       _OSTCBPrioTbl.L,A0
00004B9A  0438      
00004B9C  2430 0800 14277          move.l    0(A0,D0.L),D2
                    14278   ; if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
00004BA0  4A82      14279          tst.l     D2
00004BA2  6608      14280          bne.s     OSTaskSuspend_5
                    14281   ; OS_EXIT_CRITICAL();
00004BA4  46DF      14282          dc.w      18143
                    14283   ; return (OS_ERR_TASK_SUSPEND_PRIO);
00004BA6  7048      14284          moveq     #72,D0
00004BA8  6000 0066 14285          bra       OSTaskSuspend_7
                    14286   OSTaskSuspend_5:
                    14287   ; }
                    14288   ; if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
00004BAC  0C82 0000 14289          cmp.l     #1,D2
00004BB0  0001      
00004BB2  6608      14290          bne.s     OSTaskSuspend_8
                    14291   ; OS_EXIT_CRITICAL();
00004BB4  46DF      14292          dc.w      18143
                    14293   ; return (OS_ERR_TASK_NOT_EXIST);
00004BB6  7043      14294          moveq     #67,D0
00004BB8  6000 0056 14295          bra       OSTaskSuspend_7
                    14296   OSTaskSuspend_8:
                    14297   ; }
                    14298   ; y            = ptcb->OSTCBY;
00004BBC  2042      14299          move.l    D2,A0
00004BBE  1A28 0036 14300          move.b    54(A0),D5
                    14301   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;                   /* Make task not ready                 */
00004BC2  CABC 0000 14302          and.l     #255,D5
00004BC6  00FF      
00004BC8  41F9 0800 14303          lea       _OSRdyTbl.L,A0
00004BCC  0318      
00004BCE  2242      14304          move.l    D2,A1
00004BD0  1029 0037 14305          move.b    55(A1),D0
00004BD4  4600      14306          not.b     D0
00004BD6  C130 5800 14307          and.b     D0,0(A0,D5.L)
                    14308   ; if (OSRdyTbl[y] == 0u) {
00004BDA  CABC 0000 14309          and.l     #255,D5
00004BDE  00FF      
00004BE0  41F9 0800 14310          lea       _OSRdyTbl.L,A0
00004BE4  0318      
00004BE6  1030 5800 14311          move.b    0(A0,D5.L),D0
00004BEA  660E      14312          bne.s     OSTaskSuspend_10
                    14313   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00004BEC  2042      14314          move.l    D2,A0
00004BEE  1028 0038 14315          move.b    56(A0),D0
00004BF2  4600      14316          not.b     D0
00004BF4  C139 0800 14317          and.b     D0,_OSRdyGrp.L
00004BF8  0316      
                    14318   OSTaskSuspend_10:
                    14319   ; }
                    14320   ; ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
00004BFA  2042      14321          move.l    D2,A0
00004BFC  0028 0008 14322          or.b      #8,50(A0)
00004C00  0032      
                    14323   ; OS_EXIT_CRITICAL();
00004C02  46DF      14324          dc.w      18143
                    14325   ; if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
00004C04  0C03 0001 14326          cmp.b     #1,D3
00004C08  6604      14327          bne.s     OSTaskSuspend_12
                    14328   ; OS_Sched();                                             /* Find new highest priority task      */
00004C0A  4EB8 15DA 14329          jsr       _OS_Sched
                    14330   OSTaskSuspend_12:
                    14331   ; }
                    14332   ; return (OS_ERR_NONE);
00004C0E  4200      14333          clr.b     D0
                    14334   OSTaskSuspend_7:
00004C10  4CDF 003C 14335          movem.l   (A7)+,D2/D3/D4/D5
00004C14  4E5E      14336          unlk      A6
00004C16  4E75      14337          rts
                    14338   ; }
                    14339   ; #endif
                    14340   ; /*$PAGE*/
                    14341   ; /*
                    14342   ; *********************************************************************************************************
                    14343   ; *                                            QUERY A TASK
                    14344   ; *
                    14345   ; * Description: This function is called to obtain a copy of the desired task's TCB.
                    14346   ; *
                    14347   ; * Arguments  : prio         is the priority of the task to obtain information from.
                    14348   ; *
                    14349   ; *              p_task_data  is a pointer to where the desired task's OS_TCB will be stored.
                    14350   ; *
                    14351   ; * Returns    : OS_ERR_NONE            if the requested task is suspended
                    14352   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    14353   ; *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14354   ; *              OS_ERR_PRIO            if the desired task has not been created
                    14355   ; *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP
                    14356   ; *              OS_ERR_PDATA_NULL      if 'p_task_data' is a NULL pointer
                    14357   ; *********************************************************************************************************
                    14358   ; */
                    14359   ; #if OS_TASK_QUERY_EN > 0u
                    14360   ; INT8U  OSTaskQuery (INT8U    prio,
                    14361   ; OS_TCB  *p_task_data)
                    14362   ; {
                    14363   _OSTaskQuery:
00004C18  4E56 0000 14364          link      A6,#0
00004C1C  48E7 3000 14365          movem.l   D2/D3,-(A7)
00004C20  162E 000B 14366          move.b    11(A6),D3
00004C24  C6BC 0000 14367          and.l     #255,D3
00004C28  00FF      
                    14368   ; OS_TCB    *ptcb;
                    14369   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14370   ; OS_CPU_SR  cpu_sr = 0u;
                    14371   ; #endif
                    14372   ; #if OS_ARG_CHK_EN > 0u
                    14373   ; if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
                    14374   ; if (prio != OS_PRIO_SELF) {
                    14375   ; return (OS_ERR_PRIO_INVALID);
                    14376   ; }
                    14377   ; }
                    14378   ; if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
                    14379   ; return (OS_ERR_PDATA_NULL);
                    14380   ; }
                    14381   ; #endif
                    14382   ; OS_ENTER_CRITICAL();
00004C2A  40E7      14383          dc.w      16615
00004C2C  007C      14384          dc.w      124
00004C2E  0700      14385          dc.w      1792
                    14386   ; if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
00004C30  0C03 00FF 14387          cmp.b     #255,D3
00004C34  660A      14388          bne.s     OSTaskQuery_1
                    14389   ; prio = OSTCBCur->OSTCBPrio;
00004C36  2079 0800 14390          move.l    _OSTCBCur.L,A0
00004C3A  0428      
00004C3C  1628 0034 14391          move.b    52(A0),D3
                    14392   OSTaskQuery_1:
                    14393   ; }
                    14394   ; ptcb = OSTCBPrioTbl[prio];
00004C40  C6BC 0000 14395          and.l     #255,D3
00004C44  00FF      
00004C46  2003      14396          move.l    D3,D0
00004C48  E588      14397          lsl.l     #2,D0
00004C4A  41F9 0800 14398          lea       _OSTCBPrioTbl.L,A0
00004C4E  0438      
00004C50  2430 0800 14399          move.l    0(A0,D0.L),D2
                    14400   ; if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
00004C54  4A82      14401          tst.l     D2
00004C56  6606      14402          bne.s     OSTaskQuery_3
                    14403   ; OS_EXIT_CRITICAL();
00004C58  46DF      14404          dc.w      18143
                    14405   ; return (OS_ERR_PRIO);
00004C5A  7029      14406          moveq     #41,D0
00004C5C  6024      14407          bra.s     OSTaskQuery_5
                    14408   OSTaskQuery_3:
                    14409   ; }
                    14410   ; if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
00004C5E  0C82 0000 14411          cmp.l     #1,D2
00004C62  0001      
00004C64  6606      14412          bne.s     OSTaskQuery_6
                    14413   ; OS_EXIT_CRITICAL();
00004C66  46DF      14414          dc.w      18143
                    14415   ; return (OS_ERR_TASK_NOT_EXIST);
00004C68  7043      14416          moveq     #67,D0
00004C6A  6016      14417          bra.s     OSTaskQuery_5
                    14418   OSTaskQuery_6:
                    14419   ; }
                    14420   ; /* Copy TCB into user storage area                    */
                    14421   ; OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
00004C6C  4878 0056 14422          pea       86
00004C70  2F02      14423          move.l    D2,-(A7)
00004C72  2F2E 000C 14424          move.l    12(A6),-(A7)
00004C76  4EB8 15B0 14425          jsr       _OS_MemCopy
00004C7A  DEFC 000C 14426          add.w     #12,A7
                    14427   ; OS_EXIT_CRITICAL();
00004C7E  46DF      14428          dc.w      18143
                    14429   ; return (OS_ERR_NONE);
00004C80  4200      14430          clr.b     D0
                    14431   OSTaskQuery_5:
00004C82  4CDF 000C 14432          movem.l   (A7)+,D2/D3
00004C86  4E5E      14433          unlk      A6
00004C88  4E75      14434          rts
                    14435   ; }
                    14436   ; #endif
                    14437   ; /*$PAGE*/
                    14438   ; /*
                    14439   ; *********************************************************************************************************
                    14440   ; *                              GET THE CURRENT VALUE OF A TASK REGISTER
                    14441   ; *
                    14442   ; * Description: This function is called to obtain the current value of a task register.  Task registers
                    14443   ; *              are application specific and can be used to store task specific values such as 'error
                    14444   ; *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
                    14445   ; *
                    14446   ; * Arguments  : prio      is the priority of the task you want to get the task register from.  If you
                    14447   ; *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
                    14448   ; *
                    14449   ; *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
                    14450   ; *                        than OS_TASK_REG_TBL_SIZE
                    14451   ; *
                    14452   ; *              perr      is a pointer to a variable that will hold an error code related to this call.
                    14453   ; *
                    14454   ; *                        OS_ERR_NONE            if the call was successful
                    14455   ; *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
                    14456   ; *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
                    14457   ; *
                    14458   ; * Returns    : The current value of the task's register or 0 if an error is detected.
                    14459   ; *
                    14460   ; * Note(s)    : The maximum number of task variables is 254
                    14461   ; *********************************************************************************************************
                    14462   ; */
                    14463   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    14464   ; INT32U  OSTaskRegGet (INT8U   prio,
                    14465   ; INT8U   id,
                    14466   ; INT8U  *perr)
                    14467   ; {
                    14468   _OSTaskRegGet:
00004C8A  4E56 FFFC 14469          link      A6,#-4
00004C8E  2F02      14470          move.l    D2,-(A7)
                    14471   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14472   ; OS_CPU_SR  cpu_sr = 0u;
                    14473   ; #endif
                    14474   ; INT32U     value;
                    14475   ; OS_TCB    *ptcb;
                    14476   ; #ifdef OS_SAFETY_CRITICAL
                    14477   ; if (perr == (INT8U *)0) {
                    14478   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14479   ; return (0u);
                    14480   ; }
                    14481   ; #endif
                    14482   ; #if OS_ARG_CHK_EN > 0u
                    14483   ; if (prio >= OS_LOWEST_PRIO) {
                    14484   ; if (prio != OS_PRIO_SELF) {
                    14485   ; *perr = OS_ERR_PRIO_INVALID;
                    14486   ; return (0u);
                    14487   ; }
                    14488   ; }
                    14489   ; if (id >= OS_TASK_REG_TBL_SIZE) {
                    14490   ; *perr = OS_ERR_ID_INVALID;
                    14491   ; return (0u);
                    14492   ; }
                    14493   ; #endif
                    14494   ; OS_ENTER_CRITICAL();
00004C90  40E7      14495          dc.w      16615
00004C92  007C      14496          dc.w      124
00004C94  0700      14497          dc.w      1792
                    14498   ; if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
00004C96  102E 000B 14499          move.b    11(A6),D0
00004C9A  0C00 00FF 14500          cmp.b     #255,D0
00004C9E  6608      14501          bne.s     OSTaskRegGet_1
                    14502   ; ptcb = OSTCBCur;
00004CA0  2439 0800 14503          move.l    _OSTCBCur.L,D2
00004CA4  0428      
00004CA6  6016      14504          bra.s     OSTaskRegGet_2
                    14505   OSTaskRegGet_1:
                    14506   ; } else {
                    14507   ; ptcb = OSTCBPrioTbl[prio];
00004CA8  102E 000B 14508          move.b    11(A6),D0
00004CAC  C0BC 0000 14509          and.l     #255,D0
00004CB0  00FF      
00004CB2  E588      14510          lsl.l     #2,D0
00004CB4  41F9 0800 14511          lea       _OSTCBPrioTbl.L,A0
00004CB8  0438      
00004CBA  2430 0800 14512          move.l    0(A0,D0.L),D2
                    14513   OSTaskRegGet_2:
                    14514   ; }
                    14515   ; value = ptcb->OSTCBRegTbl[id];
00004CBE  2042      14516          move.l    D2,A0
00004CC0  102E 000F 14517          move.b    15(A6),D0
00004CC4  C0BC 0000 14518          and.l     #255,D0
00004CC8  00FF      
00004CCA  E588      14519          lsl.l     #2,D0
00004CCC  D1C0      14520          add.l     D0,A0
00004CCE  2D68 0052 14521          move.l    82(A0),-4(A6)
00004CD2  FFFC      
                    14522   ; OS_EXIT_CRITICAL();
00004CD4  46DF      14523          dc.w      18143
                    14524   ; *perr = OS_ERR_NONE;
00004CD6  206E 0010 14525          move.l    16(A6),A0
00004CDA  4210      14526          clr.b     (A0)
                    14527   ; return (value);
00004CDC  202E FFFC 14528          move.l    -4(A6),D0
00004CE0  241F      14529          move.l    (A7)+,D2
00004CE2  4E5E      14530          unlk      A6
00004CE4  4E75      14531          rts
                    14532   ; }
                    14533   ; #endif
                    14534   ; /*$PAGE*/
                    14535   ; /*
                    14536   ; ************************************************************************************************************************
                    14537   ; *                                    ALLOCATE THE NEXT AVAILABLE TASK REGISTER ID
                    14538   ; *
                    14539   ; * Description: This function is called to obtain a task register ID.  This function thus allows task registers IDs to be
                    14540   ; *              allocated dynamically instead of statically.
                    14541   ; *
                    14542   ; * Arguments  : p_err       is a pointer to a variable that will hold an error code related to this call.
                    14543   ; *
                    14544   ; *                            OS_ERR_NONE               if the call was successful
                    14545   ; *                            OS_ERR_NO_MORE_ID_AVAIL   if you are attempting to assign more task register IDs than you 
                    14546   ; *                                                           have available through OS_TASK_REG_TBL_SIZE.
                    14547   ; *
                    14548   ; * Returns    : The next available task register 'id' or OS_TASK_REG_TBL_SIZE if an error is detected.
                    14549   ; ************************************************************************************************************************
                    14550   ; */
                    14551   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    14552   ; INT8U  OSTaskRegGetID (INT8U  *perr)
                    14553   ; {
                    14554   _OSTaskRegGetID:
00004CE6  4E56 FFFC 14555          link      A6,#-4
                    14556   ; #if OS_CRITICAL_METHOD == 3u                                    /* Allocate storage for CPU status register           */
                    14557   ; OS_CPU_SR  cpu_sr = 0u;
                    14558   ; #endif
                    14559   ; INT8U      id;
                    14560   ; #ifdef OS_SAFETY_CRITICAL
                    14561   ; if (perr == (INT8U *)0) {
                    14562   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14563   ; return ((INT8U)OS_TASK_REG_TBL_SIZE);
                    14564   ; }
                    14565   ; #endif
                    14566   ; OS_ENTER_CRITICAL();
00004CEA  40E7      14567          dc.w      16615
00004CEC  007C      14568          dc.w      124
00004CEE  0700      14569          dc.w      1792
                    14570   ; if (OSTaskRegNextAvailID >= OS_TASK_REG_TBL_SIZE) {         /* See if we exceeded the number of IDs available     */
00004CF0  1039 0800 14571          move.b    _OSTaskRegNextAvailID.L,D0
00004CF4  0D7C      
00004CF6  0C00 0001 14572          cmp.b     #1,D0
00004CFA  650E      14573          blo.s     OSTaskRegGetID_1
                    14574   ; *perr = OS_ERR_NO_MORE_ID_AVAIL;                         /* Yes, cannot allocate more task register IDs        */
00004CFC  206E 0008 14575          move.l    8(A6),A0
00004D00  10BC 0096 14576          move.b    #150,(A0)
                    14577   ; OS_EXIT_CRITICAL();
00004D04  46DF      14578          dc.w      18143
                    14579   ; return ((INT8U)OS_TASK_REG_TBL_SIZE);
00004D06  7001      14580          moveq     #1,D0
00004D08  601A      14581          bra.s     OSTaskRegGetID_3
                    14582   OSTaskRegGetID_1:
                    14583   ; }
                    14584   ; id   = OSTaskRegNextAvailID;                                /* Assign the next available ID                       */
00004D0A  1D79 0800 14585          move.b    _OSTaskRegNextAvailID.L,-1(A6)
00004D0E  0D7C FFFF 
                    14586   ; OSTaskRegNextAvailID++;                                     /* Increment available ID for next request            */
00004D12  5239 0800 14587          addq.b    #1,_OSTaskRegNextAvailID.L
00004D16  0D7C      
                    14588   ; OS_EXIT_CRITICAL();
00004D18  46DF      14589          dc.w      18143
                    14590   ; *perr = OS_ERR_NONE;
00004D1A  206E 0008 14591          move.l    8(A6),A0
00004D1E  4210      14592          clr.b     (A0)
                    14593   ; return (id);
00004D20  102E FFFF 14594          move.b    -1(A6),D0
                    14595   OSTaskRegGetID_3:
00004D24  4E5E      14596          unlk      A6
00004D26  4E75      14597          rts
                    14598   ; }
                    14599   ; #endif
                    14600   ; /*$PAGE*/
                    14601   ; /*
                    14602   ; *********************************************************************************************************
                    14603   ; *                              SET THE CURRENT VALUE OF A TASK VARIABLE
                    14604   ; *
                    14605   ; * Description: This function is called to change the current value of a task register.  Task registers
                    14606   ; *              are application specific and can be used to store task specific values such as 'error
                    14607   ; *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
                    14608   ; *
                    14609   ; * Arguments  : prio      is the priority of the task you want to set the task register for.  If you
                    14610   ; *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
                    14611   ; *
                    14612   ; *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
                    14613   ; *                        than OS_TASK_REG_TBL_SIZE
                    14614   ; *
                    14615   ; *              value     is the desired value for the task register.
                    14616   ; *
                    14617   ; *              perr      is a pointer to a variable that will hold an error code related to this call.
                    14618   ; *
                    14619   ; *                        OS_ERR_NONE            if the call was successful
                    14620   ; *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
                    14621   ; *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
                    14622   ; *
                    14623   ; * Returns    : The current value of the task's variable or 0 if an error is detected.
                    14624   ; *
                    14625   ; * Note(s)    : The maximum number of task variables is 254
                    14626   ; *********************************************************************************************************
                    14627   ; */
                    14628   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    14629   ; void  OSTaskRegSet (INT8U    prio,
                    14630   ; INT8U    id,
                    14631   ; INT32U   value,
                    14632   ; INT8U   *perr)
                    14633   ; {
                    14634   _OSTaskRegSet:
00004D28  4E56 0000 14635          link      A6,#0
00004D2C  2F02      14636          move.l    D2,-(A7)
                    14637   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14638   ; OS_CPU_SR  cpu_sr = 0u;
                    14639   ; #endif
                    14640   ; OS_TCB    *ptcb;
                    14641   ; #ifdef OS_SAFETY_CRITICAL
                    14642   ; if (perr == (INT8U *)0) {
                    14643   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14644   ; return;
                    14645   ; }
                    14646   ; #endif
                    14647   ; #if OS_ARG_CHK_EN > 0u
                    14648   ; if (prio >= OS_LOWEST_PRIO) {
                    14649   ; if (prio != OS_PRIO_SELF) {
                    14650   ; *perr = OS_ERR_PRIO_INVALID;
                    14651   ; return;
                    14652   ; }
                    14653   ; }
                    14654   ; if (id >= OS_TASK_REG_TBL_SIZE) {
                    14655   ; *perr = OS_ERR_ID_INVALID;
                    14656   ; return;
                    14657   ; }
                    14658   ; #endif
                    14659   ; OS_ENTER_CRITICAL();
00004D2E  40E7      14660          dc.w      16615
00004D30  007C      14661          dc.w      124
00004D32  0700      14662          dc.w      1792
                    14663   ; if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
00004D34  102E 000B 14664          move.b    11(A6),D0
00004D38  0C00 00FF 14665          cmp.b     #255,D0
00004D3C  6608      14666          bne.s     OSTaskRegSet_1
                    14667   ; ptcb = OSTCBCur;
00004D3E  2439 0800 14668          move.l    _OSTCBCur.L,D2
00004D42  0428      
00004D44  6016      14669          bra.s     OSTaskRegSet_2
                    14670   OSTaskRegSet_1:
                    14671   ; } else {
                    14672   ; ptcb = OSTCBPrioTbl[prio];
00004D46  102E 000B 14673          move.b    11(A6),D0
00004D4A  C0BC 0000 14674          and.l     #255,D0
00004D4E  00FF      
00004D50  E588      14675          lsl.l     #2,D0
00004D52  41F9 0800 14676          lea       _OSTCBPrioTbl.L,A0
00004D56  0438      
00004D58  2430 0800 14677          move.l    0(A0,D0.L),D2
                    14678   OSTaskRegSet_2:
                    14679   ; }
                    14680   ; ptcb->OSTCBRegTbl[id] = value;
00004D5C  2042      14681          move.l    D2,A0
00004D5E  102E 000F 14682          move.b    15(A6),D0
00004D62  C0BC 0000 14683          and.l     #255,D0
00004D66  00FF      
00004D68  E588      14684          lsl.l     #2,D0
00004D6A  D1C0      14685          add.l     D0,A0
00004D6C  216E 0010 14686          move.l    16(A6),82(A0)
00004D70  0052      
                    14687   ; OS_EXIT_CRITICAL();
00004D72  46DF      14688          dc.w      18143
                    14689   ; *perr                 = OS_ERR_NONE;
00004D74  206E 0014 14690          move.l    20(A6),A0
00004D78  4210      14691          clr.b     (A0)
00004D7A  241F      14692          move.l    (A7)+,D2
00004D7C  4E5E      14693          unlk      A6
00004D7E  4E75      14694          rts
                    14695   ; }
                    14696   ; #endif
                    14697   ; /*$PAGE*/
                    14698   ; /*
                    14699   ; *********************************************************************************************************
                    14700   ; *                                    CATCH ACCIDENTAL TASK RETURN
                    14701   ; *
                    14702   ; * Description: This function is called if a task accidentally returns without deleting itself.  In other
                    14703   ; *              words, a task should either be an infinite loop or delete itself if it's done.
                    14704   ; *
                    14705   ; * Arguments  : none
                    14706   ; *
                    14707   ; * Returns    : none
                    14708   ; *
                    14709   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    14710   ; *********************************************************************************************************
                    14711   ; */
                    14712   ; void  OS_TaskReturn (void)
                    14713   ; {
                    14714   _OS_TaskReturn:
                    14715   ; OSTaskReturnHook(OSTCBCur);                   /* Call hook to let user decide on what to do        */
00004D80  2F39 0800 14716          move.l    _OSTCBCur.L,-(A7)
00004D84  0428      
00004D86  4EB8 08D2 14717          jsr       _OSTaskReturnHook
00004D8A  584F      14718          addq.w    #4,A7
                    14719   ; #if OS_TASK_DEL_EN > 0u
                    14720   ; (void)OSTaskDel(OS_PRIO_SELF);                /* Delete task if it accidentally returns!           */
00004D8C  4878 00FF 14721          pea       255
00004D90  4EB8 4652 14722          jsr       _OSTaskDel
00004D94  584F      14723          addq.w    #4,A7
00004D96  C0BC 0000 14724          and.l     #255,D0
00004D9A  00FF      
00004D9C  4E75      14725          rts
                    14726   ; #else
                    14727   ; for (;;) {
                    14728   ; OSTimeDly(OS_TICKS_PER_SEC);
                    14729   ; }
                    14730   ; #endif
                    14731   ; }
                    14732   ; /*$PAGE*/
                    14733   ; /*
                    14734   ; *********************************************************************************************************
                    14735   ; *                                          CLEAR TASK STACK
                    14736   ; *
                    14737   ; * Description: This function is used to clear the stack of a task (i.e. write all zeros)
                    14738   ; *
                    14739   ; * Arguments  : pbos     is a pointer to the task's bottom of stack.  If the configuration constant
                    14740   ; *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    14741   ; *                       memory to low memory).  'pbos' will thus point to the lowest (valid) memory
                    14742   ; *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
                    14743   ; *                       highest memory location of the stack and the stack will grow with increasing
                    14744   ; *                       memory locations.  'pbos' MUST point to a valid 'free' data item.
                    14745   ; *
                    14746   ; *              size     is the number of 'stack elements' to clear.
                    14747   ; *
                    14748   ; *              opt      contains additional information (or options) about the behavior of the task.  The
                    14749   ; *                       LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
                    14750   ; *                       specific.  See OS_TASK_OPT_??? in uCOS-II.H.
                    14751   ; *
                    14752   ; * Returns    : none
                    14753   ; *********************************************************************************************************
                    14754   ; */
                    14755   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    14756   ; void  OS_TaskStkClr (OS_STK  *pbos,
                    14757   ; INT32U   size,
                    14758   ; INT16U   opt)
                    14759   ; {
                    14760   _OS_TaskStkClr:
00004D9E  4E56 0000 14761          link      A6,#0
                    14762   ; if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000u) {      /* See if stack checking has been enabled       */
00004DA2  302E 0012 14763          move.w    18(A6),D0
00004DA6  C07C 0001 14764          and.w     #1,D0
00004DAA  6726      14765          beq.s     OS_TaskStkClr_7
                    14766   ; if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000u) {  /* See if stack needs to be cleared             */
00004DAC  302E 0012 14767          move.w    18(A6),D0
00004DB0  C07C 0002 14768          and.w     #2,D0
00004DB4  671C      14769          beq.s     OS_TaskStkClr_7
                    14770   ; #if OS_STK_GROWTH == 1u
                    14771   ; while (size > 0u) {                        /* Stack grows from HIGH to LOW memory          */
                    14772   OS_TaskStkClr_5:
00004DB6  202E 000C 14773          move.l    12(A6),D0
00004DBA  0C80 0000 14774          cmp.l     #0,D0
00004DBE  0000      
00004DC0  6310      14775          bls.s     OS_TaskStkClr_7
                    14776   ; size--;
00004DC2  53AE 000C 14777          subq.l    #1,12(A6)
                    14778   ; *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
00004DC6  206E 0008 14779          move.l    8(A6),A0
00004DCA  54AE 0008 14780          addq.l    #2,8(A6)
00004DCE  4250      14781          clr.w     (A0)
00004DD0  60E4      14782          bra       OS_TaskStkClr_5
                    14783   OS_TaskStkClr_7:
00004DD2  4E5E      14784          unlk      A6
00004DD4  4E75      14785          rts
                    14786   ; /*
                    14787   ; *********************************************************************************************************
                    14788   ; *                                                uC/OS-II
                    14789   ; *                                          The Real-Time Kernel
                    14790   ; *                                             TIME MANAGEMENT
                    14791   ; *
                    14792   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    14793   ; *                                           All Rights Reserved
                    14794   ; *
                    14795   ; * File    : OS_TIME.C
                    14796   ; * By      : Jean J. Labrosse
                    14797   ; * Version : V2.92.07
                    14798   ; *
                    14799   ; * LICENSING TERMS:
                    14800   ; * ---------------
                    14801   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    14802   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    14803   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    14804   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    14805   ; * licensing fee.
                    14806   ; *********************************************************************************************************
                    14807   ; */
                    14808   ; #define  MICRIUM_SOURCE
                    14809   ; #ifndef  OS_MASTER_FILE
                    14810   ; #include <ucos_ii.h>
                    14811   ; #endif
                    14812   ; /*
                    14813   ; *********************************************************************************************************
                    14814   ; *                                        DELAY TASK 'n' TICKS
                    14815   ; *
                    14816   ; * Description: This function is called to delay execution of the currently running task until the
                    14817   ; *              specified number of system ticks expires.  This, of course, directly equates to delaying
                    14818   ; *              the current task for some time to expire.  No delay will result If the specified delay is
                    14819   ; *              0.  If the specified delay is greater than 0 then, a context switch will result.
                    14820   ; *
                    14821   ; * Arguments  : ticks     is the time delay that the task will be suspended in number of clock 'ticks'.
                    14822   ; *                        Note that by specifying 0, the task will not be delayed.
                    14823   ; *
                    14824   ; * Returns    : none
                    14825   ; *********************************************************************************************************
                    14826   ; */
                    14827   ; void  OSTimeDly (INT32U ticks)
                    14828   ; {
                    14829   _OSTimeDly:
00004DD6  4E56 0000 14830          link      A6,#0
00004DDA  48E7 2020 14831          movem.l   D2/A2,-(A7)
00004DDE  45F9 0800 14832          lea       _OSTCBCur.L,A2
00004DE2  0428      
                    14833   ; INT8U      y;
                    14834   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14835   ; OS_CPU_SR  cpu_sr = 0u;
                    14836   ; #endif
                    14837   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00004DE4  1039 0800 14838          move.b    _OSIntNesting.L,D0
00004DE8  030E      
00004DEA  0C00 0000 14839          cmp.b     #0,D0
00004DEE  6304      14840          bls.s     OSTimeDly_1
                    14841   ; return;
00004DF0  6000 0072 14842          bra       OSTimeDly_6
                    14843   OSTimeDly_1:
                    14844   ; }
                    14845   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
00004DF4  1039 0800 14846          move.b    _OSLockNesting.L,D0
00004DF8  0310      
00004DFA  0C00 0000 14847          cmp.b     #0,D0
00004DFE  6304      14848          bls.s     OSTimeDly_4
                    14849   ; return;
00004E00  6000 0062 14850          bra       OSTimeDly_6
                    14851   OSTimeDly_4:
                    14852   ; }
                    14853   ; if (ticks > 0u) {                            /* 0 means no delay!                                  */
00004E04  202E 0008 14854          move.l    8(A6),D0
00004E08  0C80 0000 14855          cmp.l     #0,D0
00004E0C  0000      
00004E0E  6300 0054 14856          bls       OSTimeDly_6
                    14857   ; OS_ENTER_CRITICAL();
00004E12  40E7      14858          dc.w      16615
00004E14  007C      14859          dc.w      124
00004E16  0700      14860          dc.w      1792
                    14861   ; y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
00004E18  2052      14862          move.l    (A2),A0
00004E1A  1428 0036 14863          move.b    54(A0),D2
                    14864   ; OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
00004E1E  C4BC 0000 14865          and.l     #255,D2
00004E22  00FF      
00004E24  41F9 0800 14866          lea       _OSRdyTbl.L,A0
00004E28  0318      
00004E2A  2252      14867          move.l    (A2),A1
00004E2C  1029 0037 14868          move.b    55(A1),D0
00004E30  4600      14869          not.b     D0
00004E32  C130 2800 14870          and.b     D0,0(A0,D2.L)
                    14871   ; if (OSRdyTbl[y] == 0u) {
00004E36  C4BC 0000 14872          and.l     #255,D2
00004E3A  00FF      
00004E3C  41F9 0800 14873          lea       _OSRdyTbl.L,A0
00004E40  0318      
00004E42  1030 2800 14874          move.b    0(A0,D2.L),D0
00004E46  660E      14875          bne.s     OSTimeDly_8
                    14876   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00004E48  2052      14877          move.l    (A2),A0
00004E4A  1028 0038 14878          move.b    56(A0),D0
00004E4E  4600      14879          not.b     D0
00004E50  C139 0800 14880          and.b     D0,_OSRdyGrp.L
00004E54  0316      
                    14881   OSTimeDly_8:
                    14882   ; }
                    14883   ; OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
00004E56  2052      14884          move.l    (A2),A0
00004E58  216E 0008 14885          move.l    8(A6),46(A0)
00004E5C  002E      
                    14886   ; OS_EXIT_CRITICAL();
00004E5E  46DF      14887          dc.w      18143
                    14888   ; OS_Sched();                              /* Find next task to run!                             */
00004E60  4EB8 15DA 14889          jsr       _OS_Sched
                    14890   OSTimeDly_6:
00004E64  4CDF 0404 14891          movem.l   (A7)+,D2/A2
00004E68  4E5E      14892          unlk      A6
00004E6A  4E75      14893          rts
                    14894   ; }
                    14895   ; }
                    14896   ; /*$PAGE*/
                    14897   ; /*
                    14898   ; *********************************************************************************************************
                    14899   ; *                                    DELAY TASK FOR SPECIFIED TIME
                    14900   ; *
                    14901   ; * Description: This function is called to delay execution of the currently running task until some time
                    14902   ; *              expires.  This call allows you to specify the delay time in HOURS, MINUTES, SECONDS and
                    14903   ; *              MILLISECONDS instead of ticks.
                    14904   ; *
                    14905   ; * Arguments  : hours     specifies the number of hours that the task will be delayed (max. is 255)
                    14906   ; *              minutes   specifies the number of minutes (max. 59)
                    14907   ; *              seconds   specifies the number of seconds (max. 59)
                    14908   ; *              ms        specifies the number of milliseconds (max. 999)
                    14909   ; *
                    14910   ; * Returns    : OS_ERR_NONE
                    14911   ; *              OS_ERR_TIME_INVALID_MINUTES
                    14912   ; *              OS_ERR_TIME_INVALID_SECONDS
                    14913   ; *              OS_ERR_TIME_INVALID_MS
                    14914   ; *              OS_ERR_TIME_ZERO_DLY
                    14915   ; *              OS_ERR_TIME_DLY_ISR
                    14916   ; *
                    14917   ; * Note(s)    : The resolution on the milliseconds depends on the tick rate.  For example, you can't do
                    14918   ; *              a 10 mS delay if the ticker interrupts every 100 mS.  In this case, the delay would be
                    14919   ; *              set to 0.  The actual delay is rounded to the nearest tick.
                    14920   ; *********************************************************************************************************
                    14921   ; */
                    14922   ; #if OS_TIME_DLY_HMSM_EN > 0u
                    14923   ; INT8U  OSTimeDlyHMSM (INT8U   hours,
                    14924   ; INT8U   minutes,
                    14925   ; INT8U   seconds,
                    14926   ; INT16U  ms)
                    14927   ; {
                    14928   _OSTimeDlyHMSM:
00004E6C  4E56 FFFC 14929          link      A6,#-4
                    14930   ; INT32U ticks;
                    14931   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00004E70  1039 0800 14932          move.b    _OSIntNesting.L,D0
00004E74  030E      
00004E76  0C00 0000 14933          cmp.b     #0,D0
00004E7A  6306      14934          bls.s     OSTimeDlyHMSM_1
                    14935   ; return (OS_ERR_TIME_DLY_ISR);
00004E7C  7055      14936          moveq     #85,D0
00004E7E  6000 00A4 14937          bra       OSTimeDlyHMSM_3
                    14938   OSTimeDlyHMSM_1:
                    14939   ; }
                    14940   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
00004E82  1039 0800 14941          move.b    _OSLockNesting.L,D0
00004E86  0310      
00004E88  0C00 0000 14942          cmp.b     #0,D0
00004E8C  6306      14943          bls.s     OSTimeDlyHMSM_4
                    14944   ; return (OS_ERR_SCHED_LOCKED);
00004E8E  7032      14945          moveq     #50,D0
00004E90  6000 0092 14946          bra       OSTimeDlyHMSM_3
                    14947   OSTimeDlyHMSM_4:
                    14948   ; }
                    14949   ; #if OS_ARG_CHK_EN > 0u
                    14950   ; if (hours == 0u) {
                    14951   ; if (minutes == 0u) {
                    14952   ; if (seconds == 0u) {
                    14953   ; if (ms == 0u) {
                    14954   ; return (OS_ERR_TIME_ZERO_DLY);
                    14955   ; }
                    14956   ; }
                    14957   ; }
                    14958   ; }
                    14959   ; if (minutes > 59u) {
                    14960   ; return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
                    14961   ; }
                    14962   ; if (seconds > 59u) {
                    14963   ; return (OS_ERR_TIME_INVALID_SECONDS);
                    14964   ; }
                    14965   ; if (ms > 999u) {
                    14966   ; return (OS_ERR_TIME_INVALID_MS);
                    14967   ; }
                    14968   ; #endif
                    14969   ; /* Compute the total number of clock ticks required.. */
                    14970   ; /* .. (rounded to the nearest tick)                   */
                    14971   ; ticks = ((INT32U)hours * 3600uL + (INT32U)minutes * 60uL + (INT32U)seconds) * OS_TICKS_PER_SEC
00004E94  102E 000B 14972          move.b    11(A6),D0
00004E98  C0BC 0000 14973          and.l     #255,D0
00004E9C  00FF      
00004E9E  2F00      14974          move.l    D0,-(A7)
00004EA0  4878 0E10 14975          pea       3600
00004EA4  4EB9 0000 14976          jsr       ULMUL
00004EA8  6640      
00004EAA  2017      14977          move.l    (A7),D0
00004EAC  504F      14978          addq.w    #8,A7
00004EAE  122E 000F 14979          move.b    15(A6),D1
00004EB2  C2BC 0000 14980          and.l     #255,D1
00004EB6  00FF      
00004EB8  2F01      14981          move.l    D1,-(A7)
00004EBA  4878 003C 14982          pea       60
00004EBE  4EB9 0000 14983          jsr       ULMUL
00004EC2  6640      
00004EC4  2217      14984          move.l    (A7),D1
00004EC6  504F      14985          addq.w    #8,A7
00004EC8  D081      14986          add.l     D1,D0
00004ECA  122E 0013 14987          move.b    19(A6),D1
00004ECE  C2BC 0000 14988          and.l     #255,D1
00004ED2  00FF      
00004ED4  D081      14989          add.l     D1,D0
00004ED6  2F00      14990          move.l    D0,-(A7)
00004ED8  4878 0064 14991          pea       100
00004EDC  4EB9 0000 14992          jsr       ULMUL
00004EE0  6640      
00004EE2  2017      14993          move.l    (A7),D0
00004EE4  504F      14994          addq.w    #8,A7
00004EE6  322E 0016 14995          move.w    22(A6),D1
00004EEA  C2BC 0000 14996          and.l     #65535,D1
00004EEE  FFFF      
00004EF0  5A81      14997          addq.l    #5,D1
00004EF2  2F01      14998          move.l    D1,-(A7)
00004EF4  4878 0064 14999          pea       100
00004EF8  4EB9 0000 15000          jsr       ULMUL
00004EFC  6640      
00004EFE  2217      15001          move.l    (A7),D1
00004F00  504F      15002          addq.w    #8,A7
00004F02  2F01      15003          move.l    D1,-(A7)
00004F04  4878 03E8 15004          pea       1000
00004F08  4EB9 0000 15005          jsr       ULDIV
00004F0C  66E0      
00004F0E  2217      15006          move.l    (A7),D1
00004F10  504F      15007          addq.w    #8,A7
00004F12  D081      15008          add.l     D1,D0
00004F14  2D40 FFFC 15009          move.l    D0,-4(A6)
                    15010   ; + OS_TICKS_PER_SEC * ((INT32U)ms + 500uL / OS_TICKS_PER_SEC) / 1000uL;
                    15011   ; OSTimeDly(ticks);
00004F18  2F2E FFFC 15012          move.l    -4(A6),-(A7)
00004F1C  4EB8 4DD6 15013          jsr       _OSTimeDly
00004F20  584F      15014          addq.w    #4,A7
                    15015   ; return (OS_ERR_NONE);
00004F22  4200      15016          clr.b     D0
                    15017   OSTimeDlyHMSM_3:
00004F24  4E5E      15018          unlk      A6
00004F26  4E75      15019          rts
                    15020   ; }
                    15021   ; #endif
                    15022   ; /*$PAGE*/
                    15023   ; /*
                    15024   ; *********************************************************************************************************
                    15025   ; *                                        RESUME A DELAYED TASK
                    15026   ; *
                    15027   ; * Description: This function is used resume a task that has been delayed through a call to either
                    15028   ; *              OSTimeDly() or OSTimeDlyHMSM().  Note that you can call this function to resume a
                    15029   ; *              task that is waiting for an event with timeout.  This would make the task look
                    15030   ; *              like a timeout occurred.
                    15031   ; *
                    15032   ; * Arguments  : prio                      specifies the priority of the task to resume
                    15033   ; *
                    15034   ; * Returns    : OS_ERR_NONE               Task has been resumed
                    15035   ; *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
                    15036   ; *                                        (i.e. >= OS_LOWEST_PRIO)
                    15037   ; *              OS_ERR_TIME_NOT_DLY       Task is not waiting for time to expire
                    15038   ; *              OS_ERR_TASK_NOT_EXIST     The desired task has not been created or has been assigned to a Mutex.
                    15039   ; *********************************************************************************************************
                    15040   ; */
                    15041   ; #if OS_TIME_DLY_RESUME_EN > 0u
                    15042   ; INT8U  OSTimeDlyResume (INT8U prio)
                    15043   ; {
                    15044   _OSTimeDlyResume:
00004F28  4E56 0000 15045          link      A6,#0
00004F2C  2F02      15046          move.l    D2,-(A7)
                    15047   ; OS_TCB    *ptcb;
                    15048   ; #if OS_CRITICAL_METHOD == 3u                                   /* Storage for CPU status register      */
                    15049   ; OS_CPU_SR  cpu_sr = 0u;
                    15050   ; #endif
                    15051   ; if (prio >= OS_LOWEST_PRIO) {
00004F2E  102E 000B 15052          move.b    11(A6),D0
00004F32  0C00 003F 15053          cmp.b     #63,D0
00004F36  6506      15054          blo.s     OSTimeDlyResume_1
                    15055   ; return (OS_ERR_PRIO_INVALID);
00004F38  702A      15056          moveq     #42,D0
00004F3A  6000 00B4 15057          bra       OSTimeDlyResume_3
                    15058   OSTimeDlyResume_1:
                    15059   ; }
                    15060   ; OS_ENTER_CRITICAL();
00004F3E  40E7      15061          dc.w      16615
00004F40  007C      15062          dc.w      124
00004F42  0700      15063          dc.w      1792
                    15064   ; ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
00004F44  102E 000B 15065          move.b    11(A6),D0
00004F48  C0BC 0000 15066          and.l     #255,D0
00004F4C  00FF      
00004F4E  E588      15067          lsl.l     #2,D0
00004F50  41F9 0800 15068          lea       _OSTCBPrioTbl.L,A0
00004F54  0438      
00004F56  2430 0800 15069          move.l    0(A0,D0.L),D2
                    15070   ; if (ptcb == (OS_TCB *)0) {
00004F5A  4A82      15071          tst.l     D2
00004F5C  6608      15072          bne.s     OSTimeDlyResume_4
                    15073   ; OS_EXIT_CRITICAL();
00004F5E  46DF      15074          dc.w      18143
                    15075   ; return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
00004F60  7043      15076          moveq     #67,D0
00004F62  6000 008C 15077          bra       OSTimeDlyResume_3
                    15078   OSTimeDlyResume_4:
                    15079   ; }
                    15080   ; if (ptcb == OS_TCB_RESERVED) {
00004F66  0C82 0000 15081          cmp.l     #1,D2
00004F6A  0001      
00004F6C  6608      15082          bne.s     OSTimeDlyResume_6
                    15083   ; OS_EXIT_CRITICAL();
00004F6E  46DF      15084          dc.w      18143
                    15085   ; return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
00004F70  7043      15086          moveq     #67,D0
00004F72  6000 007C 15087          bra       OSTimeDlyResume_3
                    15088   OSTimeDlyResume_6:
                    15089   ; }
                    15090   ; if (ptcb->OSTCBDly == 0u) {                                /* See if task is delayed               */
00004F76  2042      15091          move.l    D2,A0
00004F78  2028 002E 15092          move.l    46(A0),D0
00004F7C  6608      15093          bne.s     OSTimeDlyResume_8
                    15094   ; OS_EXIT_CRITICAL();
00004F7E  46DF      15095          dc.w      18143
                    15096   ; return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
00004F80  7050      15097          moveq     #80,D0
00004F82  6000 006C 15098          bra       OSTimeDlyResume_3
                    15099   OSTimeDlyResume_8:
                    15100   ; }
                    15101   ; ptcb->OSTCBDly = 0u;                                       /* Clear the time delay                 */
00004F86  2042      15102          move.l    D2,A0
00004F88  42A8 002E 15103          clr.l     46(A0)
                    15104   ; if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
00004F8C  2042      15105          move.l    D2,A0
00004F8E  1028 0032 15106          move.b    50(A0),D0
00004F92  C03C 0037 15107          and.b     #55,D0
00004F96  6712      15108          beq.s     OSTimeDlyResume_10
                    15109   ; ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
00004F98  2042      15110          move.l    D2,A0
00004F9A  0228 00C8 15111          and.b     #-56,50(A0)
00004F9E  0032      
                    15112   ; ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
00004FA0  2042      15113          move.l    D2,A0
00004FA2  117C 0001 15114          move.b    #1,51(A0)
00004FA6  0033      
00004FA8  6006      15115          bra.s     OSTimeDlyResume_11
                    15116   OSTimeDlyResume_10:
                    15117   ; } else {
                    15118   ; ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
00004FAA  2042      15119          move.l    D2,A0
00004FAC  4228 0033 15120          clr.b     51(A0)
                    15121   OSTimeDlyResume_11:
                    15122   ; }
                    15123   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
00004FB0  2042      15124          move.l    D2,A0
00004FB2  1028 0032 15125          move.b    50(A0),D0
00004FB6  C03C 0008 15126          and.b     #8,D0
00004FBA  6630      15127          bne.s     OSTimeDlyResume_12
                    15128   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
00004FBC  2042      15129          move.l    D2,A0
00004FBE  1028 0038 15130          move.b    56(A0),D0
00004FC2  8139 0800 15131          or.b      D0,_OSRdyGrp.L
00004FC6  0316      
                    15132   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00004FC8  2042      15133          move.l    D2,A0
00004FCA  1028 0036 15134          move.b    54(A0),D0
00004FCE  C0BC 0000 15135          and.l     #255,D0
00004FD2  00FF      
00004FD4  41F9 0800 15136          lea       _OSRdyTbl.L,A0
00004FD8  0318      
00004FDA  2242      15137          move.l    D2,A1
00004FDC  1229 0037 15138          move.b    55(A1),D1
00004FE0  8330 0800 15139          or.b      D1,0(A0,D0.L)
                    15140   ; OS_EXIT_CRITICAL();
00004FE4  46DF      15141          dc.w      18143
                    15142   ; OS_Sched();                                            /* See if this is new highest priority  */
00004FE6  4EB8 15DA 15143          jsr       _OS_Sched
00004FEA  6002      15144          bra.s     OSTimeDlyResume_13
                    15145   OSTimeDlyResume_12:
                    15146   ; } else {
                    15147   ; OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
00004FEC  46DF      15148          dc.w      18143
                    15149   OSTimeDlyResume_13:
                    15150   ; }
                    15151   ; return (OS_ERR_NONE);
00004FEE  4200      15152          clr.b     D0
                    15153   OSTimeDlyResume_3:
00004FF0  241F      15154          move.l    (A7)+,D2
00004FF2  4E5E      15155          unlk      A6
00004FF4  4E75      15156          rts
                    15157   ; }
                    15158   ; #endif
                    15159   ; /*$PAGE*/
                    15160   ; /*
                    15161   ; *********************************************************************************************************
                    15162   ; *                                       GET CURRENT SYSTEM TIME
                    15163   ; *
                    15164   ; * Description: This function is used by your application to obtain the current value of the 32-bit
                    15165   ; *              counter which keeps track of the number of clock ticks.
                    15166   ; *
                    15167   ; * Arguments  : none
                    15168   ; *
                    15169   ; * Returns    : The current value of OSTime
                    15170   ; *********************************************************************************************************
                    15171   ; */
                    15172   ; #if OS_TIME_GET_SET_EN > 0u
                    15173   ; INT32U  OSTimeGet (void)
                    15174   ; {
                    15175   _OSTimeGet:
00004FF6  4E56 FFFC 15176          link      A6,#-4
                    15177   ; INT32U     ticks;
                    15178   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15179   ; OS_CPU_SR  cpu_sr = 0u;
                    15180   ; #endif
                    15181   ; OS_ENTER_CRITICAL();
00004FFA  40E7      15182          dc.w      16615
00004FFC  007C      15183          dc.w      124
00004FFE  0700      15184          dc.w      1792
                    15185   ; ticks = OSTime;
00005000  2D79 0800 15186          move.l    _OSTime.L,-4(A6)
00005004  0D7E FFFC 
                    15187   ; OS_EXIT_CRITICAL();
00005008  46DF      15188          dc.w      18143
                    15189   ; return (ticks);
0000500A  202E FFFC 15190          move.l    -4(A6),D0
0000500E  4E5E      15191          unlk      A6
00005010  4E75      15192          rts
                    15193   ; }
                    15194   ; #endif
                    15195   ; /*
                    15196   ; *********************************************************************************************************
                    15197   ; *                                          SET SYSTEM CLOCK
                    15198   ; *
                    15199   ; * Description: This function sets the 32-bit counter which keeps track of the number of clock ticks.
                    15200   ; *
                    15201   ; * Arguments  : ticks      specifies the new value that OSTime needs to take.
                    15202   ; *
                    15203   ; * Returns    : none
                    15204   ; *********************************************************************************************************
                    15205   ; */
                    15206   ; #if OS_TIME_GET_SET_EN > 0u
                    15207   ; void  OSTimeSet (INT32U ticks)
                    15208   ; {
                    15209   _OSTimeSet:
00005012  4E56 0000 15210          link      A6,#0
                    15211   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15212   ; OS_CPU_SR  cpu_sr = 0u;
                    15213   ; #endif
                    15214   ; OS_ENTER_CRITICAL();
00005016  40E7      15215          dc.w      16615
00005018  007C      15216          dc.w      124
0000501A  0700      15217          dc.w      1792
                    15218   ; OSTime = ticks;
0000501C  23EE 0008 15219          move.l    8(A6),_OSTime.L
00005020  0800 0D7E 
                    15220   ; OS_EXIT_CRITICAL();
00005024  46DF      15221          dc.w      18143
00005026  4E5E      15222          unlk      A6
00005028  4E75      15223          rts
                    15224   ; /*
                    15225   ; *********************************************************************************************************
                    15226   ; *                                                uC/OS-II
                    15227   ; *                                          The Real-Time Kernel
                    15228   ; *                                            TIMER MANAGEMENT
                    15229   ; *
                    15230   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    15231   ; *                                           All Rights Reserved
                    15232   ; *
                    15233   ; *
                    15234   ; * File    : OS_TMR.C
                    15235   ; * By      : Jean J. Labrosse
                    15236   ; * Version : V2.92.07
                    15237   ; *
                    15238   ; * LICENSING TERMS:
                    15239   ; * ---------------
                    15240   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    15241   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    15242   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    15243   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    15244   ; * licensing fee.
                    15245   ; *********************************************************************************************************
                    15246   ; */
                    15247   ; #define  MICRIUM_SOURCE
                    15248   ; #ifndef  OS_MASTER_FILE
                    15249   ; #include <ucos_ii.h>
                    15250   ; #endif
                    15251   ; /*
                    15252   ; *********************************************************************************************************
                    15253   ; *                                                        NOTES
                    15254   ; *
                    15255   ; * 1) Your application MUST define the following #define constants:
                    15256   ; *
                    15257   ; *    OS_TASK_TMR_PRIO          The priority of the Timer management task
                    15258   ; *    OS_TASK_TMR_STK_SIZE      The size     of the Timer management task's stack
                    15259   ; *
                    15260   ; * 2) You must call OSTmrSignal() to notify the Timer management task that it's time to update the timers.
                    15261   ; *********************************************************************************************************
                    15262   ; */
                    15263   ; /*
                    15264   ; *********************************************************************************************************
                    15265   ; *                                              CONSTANTS
                    15266   ; *********************************************************************************************************
                    15267   ; */
                    15268   ; #define  OS_TMR_LINK_DLY       0u
                    15269   ; #define  OS_TMR_LINK_PERIODIC  1u
                    15270   ; /*
                    15271   ; *********************************************************************************************************
                    15272   ; *                                          LOCAL PROTOTYPES
                    15273   ; *********************************************************************************************************
                    15274   ; */
                    15275   ; #if OS_TMR_EN > 0u
                    15276   ; static  OS_TMR  *OSTmr_Alloc         (void);
                    15277   ; static  void     OSTmr_Free          (OS_TMR *ptmr);
                    15278   ; static  void     OSTmr_InitTask      (void);
                    15279   ; static  void     OSTmr_Link          (OS_TMR *ptmr, INT8U type);
                    15280   ; static  void     OSTmr_Unlink        (OS_TMR *ptmr);
                    15281   ; static  void     OSTmr_Task          (void   *p_arg);
                    15282   ; #endif
                    15283   ; /*$PAGE*/
                    15284   ; /*
                    15285   ; *********************************************************************************************************
                    15286   ; *                                           CREATE A TIMER
                    15287   ; *
                    15288   ; * Description: This function is called by your application code to create a timer.
                    15289   ; *
                    15290   ; * Arguments  : dly           Initial delay.
                    15291   ; *                            If the timer is configured for ONE-SHOT mode, this is the timeout used.
                    15292   ; *                            If the timer is configured for PERIODIC mode, this is the first timeout to 
                    15293   ; *                               wait for before the timer starts entering periodic mode.
                    15294   ; *
                    15295   ; *              period        The 'period' being repeated for the timer.
                    15296   ; *                               If you specified 'OS_TMR_OPT_PERIODIC' as an option, when the timer 
                    15297   ; *                               expires, it will automatically restart with the same period.
                    15298   ; *
                    15299   ; *              opt           Specifies either:
                    15300   ; *                               OS_TMR_OPT_ONE_SHOT       The timer counts down only once
                    15301   ; *                               OS_TMR_OPT_PERIODIC       The timer counts down and then reloads itself
                    15302   ; *
                    15303   ; *              callback      Is a pointer to a callback function that will be called when the timer expires. 
                    15304   ; *                               The callback function must be declared as follows:
                    15305   ; *
                    15306   ; *                               void MyCallback (OS_TMR *ptmr, void *p_arg);
                    15307   ; *
                    15308   ; *              callback_arg  Is an argument (a pointer) that is passed to the callback function when it is called.
                    15309   ; *
                    15310   ; *              pname         Is a pointer to an ASCII string that is used to name the timer.  Names are 
                    15311   ; *                               useful for debugging.
                    15312   ; *
                    15313   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15314   ; *                               OS_ERR_NONE
                    15315   ; *                               OS_ERR_TMR_INVALID_DLY     you specified an invalid delay
                    15316   ; *                               OS_ERR_TMR_INVALID_PERIOD  you specified an invalid period
                    15317   ; *                               OS_ERR_TMR_INVALID_OPT     you specified an invalid option
                    15318   ; *                               OS_ERR_TMR_ISR             if the call was made from an ISR
                    15319   ; *                               OS_ERR_TMR_NON_AVAIL       if there are no free timers from the timer pool
                    15320   ; *
                    15321   ; * Returns    : A pointer to an OS_TMR data structure.
                    15322   ; *              This is the 'handle' that your application will use to reference the timer created.
                    15323   ; *********************************************************************************************************
                    15324   ; */
                    15325   ; #if OS_TMR_EN > 0u
                    15326   ; OS_TMR  *OSTmrCreate (INT32U           dly,
                    15327   ; INT32U           period,
                    15328   ; INT8U            opt,
                    15329   ; OS_TMR_CALLBACK  callback,
                    15330   ; void            *callback_arg,
                    15331   ; INT8U           *pname,
                    15332   ; INT8U           *perr)
                    15333   ; {
                    15334   _OSTmrCreate:
0000502A  4E56 0000 15335          link      A6,#0
0000502E  48E7 3000 15336          movem.l   D2/D3,-(A7)
00005032  262E 0020 15337          move.l    32(A6),D3
                    15338   ; OS_TMR   *ptmr;
                    15339   ; #ifdef OS_SAFETY_CRITICAL
                    15340   ; if (perr == (INT8U *)0) {
                    15341   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15342   ; return ((OS_TMR *)0);
                    15343   ; }
                    15344   ; #endif
                    15345   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    15346   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    15347   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15348   ; return ((OS_TMR *)0);
                    15349   ; }
                    15350   ; #endif
                    15351   ; #if OS_ARG_CHK_EN > 0u
                    15352   ; switch (opt) {                                          /* Validate arguments                                     */
                    15353   ; case OS_TMR_OPT_PERIODIC:
                    15354   ; if (period == 0u) {
                    15355   ; *perr = OS_ERR_TMR_INVALID_PERIOD;
                    15356   ; return ((OS_TMR *)0);
                    15357   ; }
                    15358   ; break;
                    15359   ; case OS_TMR_OPT_ONE_SHOT:
                    15360   ; if (dly == 0u) {
                    15361   ; *perr = OS_ERR_TMR_INVALID_DLY;
                    15362   ; return ((OS_TMR *)0);
                    15363   ; }
                    15364   ; break;
                    15365   ; default:
                    15366   ; *perr = OS_ERR_TMR_INVALID_OPT;
                    15367   ; return ((OS_TMR *)0);
                    15368   ; }
                    15369   ; #endif
                    15370   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
00005036  1039 0800 15371          move.b    _OSIntNesting.L,D0
0000503A  030E      
0000503C  0C00 0000 15372          cmp.b     #0,D0
00005040  630C      15373          bls.s     OSTmrCreate_1
                    15374   ; *perr  = OS_ERR_TMR_ISR;
00005042  2043      15375          move.l    D3,A0
00005044  10BC 008B 15376          move.b    #139,(A0)
                    15377   ; return ((OS_TMR *)0);
00005048  4280      15378          clr.l     D0
0000504A  6000 0078 15379          bra       OSTmrCreate_3
                    15380   OSTmrCreate_1:
                    15381   ; }
                    15382   ; OSSchedLock();
0000504E  4EB8 0E2A 15383          jsr       _OSSchedLock
                    15384   ; ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
00005052  4EB9 0000 15385          jsr       @ucos_ii_OSTmr_Alloc
00005056  55C2      
00005058  2400      15386          move.l    D0,D2
                    15387   ; if (ptmr == (OS_TMR *)0) {
0000505A  4A82      15388          tst.l     D2
0000505C  6610      15389          bne.s     OSTmrCreate_4
                    15390   ; OSSchedUnlock();
0000505E  4EB8 0E5A 15391          jsr       _OSSchedUnlock
                    15392   ; *perr = OS_ERR_TMR_NON_AVAIL;
00005062  2043      15393          move.l    D3,A0
00005064  10BC 0086 15394          move.b    #134,(A0)
                    15395   ; return ((OS_TMR *)0);
00005068  4280      15396          clr.l     D0
0000506A  6000 0058 15397          bra       OSTmrCreate_3
                    15398   OSTmrCreate_4:
                    15399   ; }
                    15400   ; ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
0000506E  2042      15401          move.l    D2,A0
00005070  117C 0001 15402          move.b    #1,35(A0)
00005074  0023      
                    15403   ; ptmr->OSTmrDly         = dly;
00005076  2042      15404          move.l    D2,A0
00005078  216E 0008 15405          move.l    8(A6),22(A0)
0000507C  0016      
                    15406   ; ptmr->OSTmrPeriod      = period;
0000507E  2042      15407          move.l    D2,A0
00005080  216E 000C 15408          move.l    12(A6),26(A0)
00005084  001A      
                    15409   ; ptmr->OSTmrOpt         = opt;
00005086  2042      15410          move.l    D2,A0
00005088  116E 0013 15411          move.b    19(A6),34(A0)
0000508C  0022      
                    15412   ; ptmr->OSTmrCallback    = callback;
0000508E  2042      15413          move.l    D2,A0
00005090  216E 0014 15414          move.l    20(A6),2(A0)
00005094  0002      
                    15415   ; ptmr->OSTmrCallbackArg = callback_arg;
00005096  2042      15416          move.l    D2,A0
00005098  216E 0018 15417          move.l    24(A6),6(A0)
0000509C  0006      
                    15418   ; #if OS_TMR_CFG_NAME_EN > 0u
                    15419   ; if (pname == (INT8U *)0) {                              /* Is 'pname' a NULL pointer?                             */
0000509E  202E 001C 15420          move.l    28(A6),D0
000050A2  660E      15421          bne.s     OSTmrCreate_6
                    15422   ; ptmr->OSTmrName    = (INT8U *)(void *)"?";
000050A4  41F9 0000 15423          lea       @ucos_ii_1.L,A0
000050A8  708C      
000050AA  2242      15424          move.l    D2,A1
000050AC  2348 001E 15425          move.l    A0,30(A1)
000050B0  6008      15426          bra.s     OSTmrCreate_7
                    15427   OSTmrCreate_6:
                    15428   ; } else {
                    15429   ; ptmr->OSTmrName    = pname;
000050B2  2042      15430          move.l    D2,A0
000050B4  216E 001C 15431          move.l    28(A6),30(A0)
000050B8  001E      
                    15432   OSTmrCreate_7:
                    15433   ; }
                    15434   ; #endif
                    15435   ; OSSchedUnlock();
000050BA  4EB8 0E5A 15436          jsr       _OSSchedUnlock
                    15437   ; *perr = OS_ERR_NONE;
000050BE  2043      15438          move.l    D3,A0
000050C0  4210      15439          clr.b     (A0)
                    15440   ; return (ptmr);
000050C2  2002      15441          move.l    D2,D0
                    15442   OSTmrCreate_3:
000050C4  4CDF 000C 15443          movem.l   (A7)+,D2/D3
000050C8  4E5E      15444          unlk      A6
000050CA  4E75      15445          rts
                    15446   ; }
                    15447   ; #endif
                    15448   ; /*$PAGE*/
                    15449   ; /*
                    15450   ; *********************************************************************************************************
                    15451   ; *                                           DELETE A TIMER
                    15452   ; *
                    15453   ; * Description: This function is called by your application code to delete a timer.
                    15454   ; *
                    15455   ; * Arguments  : ptmr          Is a pointer to the timer to stop and delete.
                    15456   ; *
                    15457   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15458   ; *                               OS_ERR_NONE
                    15459   ; *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
                    15460   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    15461   ; *                               OS_ERR_TMR_ISR            if the function was called from an ISR
                    15462   ; *                               OS_ERR_TMR_INACTIVE       if the timer was not created
                    15463   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    15464   ; *
                    15465   ; * Returns    : OS_TRUE       If the call was successful
                    15466   ; *              OS_FALSE      If not
                    15467   ; *********************************************************************************************************
                    15468   ; */
                    15469   ; #if OS_TMR_EN > 0u
                    15470   ; BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                    15471   ; INT8U   *perr)
                    15472   ; {
                    15473   _OSTmrDel:
000050CC  4E56 0000 15474          link      A6,#0
000050D0  48E7 3020 15475          movem.l   D2/D3/A2,-(A7)
000050D4  242E 000C 15476          move.l    12(A6),D2
000050D8  262E 0008 15477          move.l    8(A6),D3
000050DC  45F8 0E5A 15478          lea       _OSSchedUnlock.L,A2
                    15479   ; #ifdef OS_SAFETY_CRITICAL
                    15480   ; if (perr == (INT8U *)0) {
                    15481   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15482   ; return (OS_FALSE);
                    15483   ; }
                    15484   ; #endif
                    15485   ; #if OS_ARG_CHK_EN > 0u
                    15486   ; if (ptmr == (OS_TMR *)0) {
                    15487   ; *perr = OS_ERR_TMR_INVALID;
                    15488   ; return (OS_FALSE);
                    15489   ; }
                    15490   ; #endif
                    15491   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
000050E0  2043      15492          move.l    D3,A0
000050E2  1010      15493          move.b    (A0),D0
000050E4  0C00 0064 15494          cmp.b     #100,D0
000050E8  670C      15495          beq.s     OSTmrDel_1
                    15496   ; *perr = OS_ERR_TMR_INVALID_TYPE;
000050EA  2042      15497          move.l    D2,A0
000050EC  10BC 0089 15498          move.b    #137,(A0)
                    15499   ; return (OS_FALSE);
000050F0  4200      15500          clr.b     D0
000050F2  6000 0090 15501          bra       OSTmrDel_3
                    15502   OSTmrDel_1:
                    15503   ; }
                    15504   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
000050F6  1039 0800 15505          move.b    _OSIntNesting.L,D0
000050FA  030E      
000050FC  0C00 0000 15506          cmp.b     #0,D0
00005100  630C      15507          bls.s     OSTmrDel_4
                    15508   ; *perr  = OS_ERR_TMR_ISR;
00005102  2042      15509          move.l    D2,A0
00005104  10BC 008B 15510          move.b    #139,(A0)
                    15511   ; return (OS_FALSE);
00005108  4200      15512          clr.b     D0
0000510A  6000 0078 15513          bra       OSTmrDel_3
                    15514   OSTmrDel_4:
                    15515   ; }
                    15516   ; OSSchedLock();
0000510E  4EB8 0E2A 15517          jsr       _OSSchedLock
                    15518   ; switch (ptmr->OSTmrState) {
00005112  2043      15519          move.l    D3,A0
00005114  1028 0023 15520          move.b    35(A0),D0
00005118  C0BC 0000 15521          and.l     #255,D0
0000511C  00FF      
0000511E  0C80 0000 15522          cmp.l     #4,D0
00005122  0004      
00005124  6400 0054 15523          bhs       OSTmrDel_6
00005128  E380      15524          asl.l     #1,D0
0000512A  303B 0806 15525          move.w    OSTmrDel_8(PC,D0.L),D0
0000512E  4EFB 0002 15526          jmp       OSTmrDel_8(PC,D0.W)
                    15527   OSTmrDel_8:
00005132  003C      15528          dc.w      OSTmrDel_12-OSTmrDel_8
00005134  0028      15529          dc.w      OSTmrDel_10-OSTmrDel_8
00005136  0028      15530          dc.w      OSTmrDel_10-OSTmrDel_8
00005138  0008      15531          dc.w      OSTmrDel_9-OSTmrDel_8
                    15532   OSTmrDel_9:
                    15533   ; case OS_TMR_STATE_RUNNING:
                    15534   ; OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
0000513A  2F03      15535          move.l    D3,-(A7)
0000513C  4EB9 0000 15536          jsr       @ucos_ii_OSTmr_Unlink
00005140  58B8      
00005142  584F      15537          addq.w    #4,A7
                    15538   ; OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
00005144  2F03      15539          move.l    D3,-(A7)
00005146  4EB9 0000 15540          jsr       @ucos_ii_OSTmr_Free
0000514A  55FC      
0000514C  584F      15541          addq.w    #4,A7
                    15542   ; OSSchedUnlock();
0000514E  4E92      15543          jsr       (A2)
                    15544   ; *perr = OS_ERR_NONE;
00005150  2042      15545          move.l    D2,A0
00005152  4210      15546          clr.b     (A0)
                    15547   ; return (OS_TRUE);
00005154  7001      15548          moveq     #1,D0
00005156  6000 002C 15549          bra       OSTmrDel_3
                    15550   OSTmrDel_10:
                    15551   ; case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
                    15552   ; case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
                    15553   ; OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
0000515A  2F03      15554          move.l    D3,-(A7)
0000515C  4EB9 0000 15555          jsr       @ucos_ii_OSTmr_Free
00005160  55FC      
00005162  584F      15556          addq.w    #4,A7
                    15557   ; OSSchedUnlock();
00005164  4E92      15558          jsr       (A2)
                    15559   ; *perr = OS_ERR_NONE;
00005166  2042      15560          move.l    D2,A0
00005168  4210      15561          clr.b     (A0)
                    15562   ; return (OS_TRUE);
0000516A  7001      15563          moveq     #1,D0
0000516C  6016      15564          bra.s     OSTmrDel_3
                    15565   OSTmrDel_12:
                    15566   ; case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
                    15567   ; OSSchedUnlock();
0000516E  4E92      15568          jsr       (A2)
                    15569   ; *perr = OS_ERR_TMR_INACTIVE;
00005170  2042      15570          move.l    D2,A0
00005172  10BC 0087 15571          move.b    #135,(A0)
                    15572   ; return (OS_FALSE);
00005176  4200      15573          clr.b     D0
00005178  600A      15574          bra.s     OSTmrDel_3
                    15575   OSTmrDel_6:
                    15576   ; default:
                    15577   ; OSSchedUnlock();
0000517A  4E92      15578          jsr       (A2)
                    15579   ; *perr = OS_ERR_TMR_INVALID_STATE;
0000517C  2042      15580          move.l    D2,A0
0000517E  10BC 008D 15581          move.b    #141,(A0)
                    15582   ; return (OS_FALSE);
00005182  4200      15583          clr.b     D0
                    15584   OSTmrDel_3:
00005184  4CDF 040C 15585          movem.l   (A7)+,D2/D3/A2
00005188  4E5E      15586          unlk      A6
0000518A  4E75      15587          rts
                    15588   ; }
                    15589   ; }
                    15590   ; #endif
                    15591   ; /*$PAGE*/
                    15592   ; /*
                    15593   ; *********************************************************************************************************
                    15594   ; *                                       GET THE NAME OF A TIMER
                    15595   ; *
                    15596   ; * Description: This function is called to obtain the name of a timer.
                    15597   ; *
                    15598   ; * Arguments  : ptmr          Is a pointer to the timer to obtain the name for
                    15599   ; *
                    15600   ; *              pdest         Is a pointer to pointer to where the name of the timer will be placed.
                    15601   ; *
                    15602   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15603   ; *                               OS_ERR_NONE               The call was successful
                    15604   ; *                               OS_ERR_TMR_INVALID_DEST   'pdest' is a NULL pointer
                    15605   ; *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
                    15606   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    15607   ; *                               OS_ERR_NAME_GET_ISR       if the call was made from an ISR
                    15608   ; *                               OS_ERR_TMR_INACTIVE       'ptmr'  points to a timer that is not active
                    15609   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    15610   ; *
                    15611   ; * Returns    : The length of the string or 0 if the timer does not exist.
                    15612   ; *********************************************************************************************************
                    15613   ; */
                    15614   ; #if OS_TMR_EN > 0u && OS_TMR_CFG_NAME_EN > 0u
                    15615   ; INT8U  OSTmrNameGet (OS_TMR   *ptmr,
                    15616   ; INT8U   **pdest,
                    15617   ; INT8U    *perr)
                    15618   ; {
                    15619   _OSTmrNameGet:
0000518C  4E56 FFFC 15620          link      A6,#-4
00005190  48E7 3020 15621          movem.l   D2/D3/A2,-(A7)
00005194  242E 0010 15622          move.l    16(A6),D2
00005198  45F8 0E5A 15623          lea       _OSSchedUnlock.L,A2
0000519C  262E 0008 15624          move.l    8(A6),D3
                    15625   ; INT8U  len;
                    15626   ; #ifdef OS_SAFETY_CRITICAL
                    15627   ; if (perr == (INT8U *)0) {
                    15628   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15629   ; return (0u);
                    15630   ; }
                    15631   ; #endif
                    15632   ; #if OS_ARG_CHK_EN > 0u
                    15633   ; if (pdest == (INT8U **)0) {
                    15634   ; *perr = OS_ERR_TMR_INVALID_DEST;
                    15635   ; return (0u);
                    15636   ; }
                    15637   ; if (ptmr == (OS_TMR *)0) {
                    15638   ; *perr = OS_ERR_TMR_INVALID;
                    15639   ; return (0u);
                    15640   ; }
                    15641   ; #endif
                    15642   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
000051A0  2043      15643          move.l    D3,A0
000051A2  1010      15644          move.b    (A0),D0
000051A4  0C00 0064 15645          cmp.b     #100,D0
000051A8  670C      15646          beq.s     OSTmrNameGet_1
                    15647   ; *perr = OS_ERR_TMR_INVALID_TYPE;
000051AA  2042      15648          move.l    D2,A0
000051AC  10BC 0089 15649          move.b    #137,(A0)
                    15650   ; return (0u);
000051B0  4200      15651          clr.b     D0
000051B2  6000 0082 15652          bra       OSTmrNameGet_3
                    15653   OSTmrNameGet_1:
                    15654   ; }
                    15655   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
000051B6  1039 0800 15656          move.b    _OSIntNesting.L,D0
000051BA  030E      
000051BC  0C00 0000 15657          cmp.b     #0,D0
000051C0  630C      15658          bls.s     OSTmrNameGet_4
                    15659   ; *perr = OS_ERR_NAME_GET_ISR;
000051C2  2042      15660          move.l    D2,A0
000051C4  10BC 0011 15661          move.b    #17,(A0)
                    15662   ; return (0u);
000051C8  4200      15663          clr.b     D0
000051CA  6000 006A 15664          bra       OSTmrNameGet_3
                    15665   OSTmrNameGet_4:
                    15666   ; }
                    15667   ; OSSchedLock();
000051CE  4EB8 0E2A 15668          jsr       _OSSchedLock
                    15669   ; switch (ptmr->OSTmrState) {
000051D2  2043      15670          move.l    D3,A0
000051D4  1028 0023 15671          move.b    35(A0),D0
000051D8  C0BC 0000 15672          and.l     #255,D0
000051DC  00FF      
000051DE  0C80 0000 15673          cmp.l     #4,D0
000051E2  0004      
000051E4  6400 0046 15674          bhs       OSTmrNameGet_6
000051E8  E380      15675          asl.l     #1,D0
000051EA  303B 0806 15676          move.w    OSTmrNameGet_8(PC,D0.L),D0
000051EE  4EFB 0002 15677          jmp       OSTmrNameGet_8(PC,D0.W)
                    15678   OSTmrNameGet_8:
000051F2  002E      15679          dc.w      OSTmrNameGet_12-OSTmrNameGet_8
000051F4  0008      15680          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
000051F6  0008      15681          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
000051F8  0008      15682          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
                    15683   OSTmrNameGet_9:
                    15684   ; case OS_TMR_STATE_RUNNING:
                    15685   ; case OS_TMR_STATE_STOPPED:
                    15686   ; case OS_TMR_STATE_COMPLETED:
                    15687   ; *pdest = ptmr->OSTmrName;
000051FA  2043      15688          move.l    D3,A0
000051FC  226E 000C 15689          move.l    12(A6),A1
00005200  22A8 001E 15690          move.l    30(A0),(A1)
                    15691   ; len    = OS_StrLen(*pdest);
00005204  206E 000C 15692          move.l    12(A6),A0
00005208  2F10      15693          move.l    (A0),-(A7)
0000520A  4EB8 1684 15694          jsr       _OS_StrLen
0000520E  584F      15695          addq.w    #4,A7
00005210  1D40 FFFF 15696          move.b    D0,-1(A6)
                    15697   ; OSSchedUnlock();
00005214  4E92      15698          jsr       (A2)
                    15699   ; *perr = OS_ERR_NONE;
00005216  2042      15700          move.l    D2,A0
00005218  4210      15701          clr.b     (A0)
                    15702   ; return (len);
0000521A  102E FFFF 15703          move.b    -1(A6),D0
0000521E  6016      15704          bra.s     OSTmrNameGet_3
                    15705   OSTmrNameGet_12:
                    15706   ; case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
                    15707   ; OSSchedUnlock();
00005220  4E92      15708          jsr       (A2)
                    15709   ; *perr = OS_ERR_TMR_INACTIVE;
00005222  2042      15710          move.l    D2,A0
00005224  10BC 0087 15711          move.b    #135,(A0)
                    15712   ; return (0u);
00005228  4200      15713          clr.b     D0
0000522A  600A      15714          bra.s     OSTmrNameGet_3
                    15715   OSTmrNameGet_6:
                    15716   ; default:
                    15717   ; OSSchedUnlock();
0000522C  4E92      15718          jsr       (A2)
                    15719   ; *perr = OS_ERR_TMR_INVALID_STATE;
0000522E  2042      15720          move.l    D2,A0
00005230  10BC 008D 15721          move.b    #141,(A0)
                    15722   ; return (0u);
00005234  4200      15723          clr.b     D0
                    15724   OSTmrNameGet_3:
00005236  4CDF 040C 15725          movem.l   (A7)+,D2/D3/A2
0000523A  4E5E      15726          unlk      A6
0000523C  4E75      15727          rts
                    15728   ; }
                    15729   ; }
                    15730   ; #endif
                    15731   ; /*$PAGE*/
                    15732   ; /*
                    15733   ; *********************************************************************************************************
                    15734   ; *                          GET HOW MUCH TIME IS LEFT BEFORE A TIMER EXPIRES
                    15735   ; *
                    15736   ; * Description: This function is called to get the number of ticks before a timer times out.
                    15737   ; *
                    15738   ; * Arguments  : ptmr          Is a pointer to the timer to obtain the remaining time from.
                    15739   ; *
                    15740   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15741   ; *                               OS_ERR_NONE
                    15742   ; *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
                    15743   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    15744   ; *                               OS_ERR_TMR_ISR            if the call was made from an ISR
                    15745   ; *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
                    15746   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    15747   ; *
                    15748   ; * Returns    : The time remaining for the timer to expire.  The time represents 'timer' increments. 
                    15749   ; *              In other words, if OSTmr_Task() is signaled every 1/10 of a second then the returned 
                    15750   ; *              value represents the number of 1/10 of a second remaining before the timer expires.
                    15751   ; *********************************************************************************************************
                    15752   ; */
                    15753   ; #if OS_TMR_EN > 0u
                    15754   ; INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                    15755   ; INT8U   *perr)
                    15756   ; {
                    15757   _OSTmrRemainGet:
0000523E  4E56 0000 15758          link      A6,#0
00005242  48E7 3820 15759          movem.l   D2/D3/D4/A2,-(A7)
00005246  242E 000C 15760          move.l    12(A6),D2
0000524A  262E 0008 15761          move.l    8(A6),D3
0000524E  45F8 0E5A 15762          lea       _OSSchedUnlock.L,A2
                    15763   ; INT32U  remain;
                    15764   ; #ifdef OS_SAFETY_CRITICAL
                    15765   ; if (perr == (INT8U *)0) {
                    15766   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15767   ; return (0u);
                    15768   ; }
                    15769   ; #endif
                    15770   ; #if OS_ARG_CHK_EN > 0u
                    15771   ; if (ptmr == (OS_TMR *)0) {
                    15772   ; *perr = OS_ERR_TMR_INVALID;
                    15773   ; return (0u);
                    15774   ; }
                    15775   ; #endif
                    15776   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
00005252  2043      15777          move.l    D3,A0
00005254  1010      15778          move.b    (A0),D0
00005256  0C00 0064 15779          cmp.b     #100,D0
0000525A  670C      15780          beq.s     OSTmrRemainGet_1
                    15781   ; *perr = OS_ERR_TMR_INVALID_TYPE;
0000525C  2042      15782          move.l    D2,A0
0000525E  10BC 0089 15783          move.b    #137,(A0)
                    15784   ; return (0u);
00005262  4280      15785          clr.l     D0
00005264  6000 00CE 15786          bra       OSTmrRemainGet_3
                    15787   OSTmrRemainGet_1:
                    15788   ; }
                    15789   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
00005268  1039 0800 15790          move.b    _OSIntNesting.L,D0
0000526C  030E      
0000526E  0C00 0000 15791          cmp.b     #0,D0
00005272  630C      15792          bls.s     OSTmrRemainGet_4
                    15793   ; *perr = OS_ERR_TMR_ISR;
00005274  2042      15794          move.l    D2,A0
00005276  10BC 008B 15795          move.b    #139,(A0)
                    15796   ; return (0u);
0000527A  4280      15797          clr.l     D0
0000527C  6000 00B6 15798          bra       OSTmrRemainGet_3
                    15799   OSTmrRemainGet_4:
                    15800   ; }
                    15801   ; OSSchedLock();
00005280  4EB8 0E2A 15802          jsr       _OSSchedLock
                    15803   ; switch (ptmr->OSTmrState) {
00005284  2043      15804          move.l    D3,A0
00005286  1028 0023 15805          move.b    35(A0),D0
0000528A  C0BC 0000 15806          and.l     #255,D0
0000528E  00FF      
00005290  0C80 0000 15807          cmp.l     #4,D0
00005294  0004      
00005296  6400 0092 15808          bhs       OSTmrRemainGet_6
0000529A  E380      15809          asl.l     #1,D0
0000529C  303B 0806 15810          move.w    OSTmrRemainGet_8(PC,D0.L),D0
000052A0  4EFB 0002 15811          jmp       OSTmrRemainGet_8(PC,D0.W)
                    15812   OSTmrRemainGet_8:
000052A4  007A      15813          dc.w      OSTmrRemainGet_12-OSTmrRemainGet_8
000052A6  0022      15814          dc.w      OSTmrRemainGet_10-OSTmrRemainGet_8
000052A8  0070      15815          dc.w      OSTmrRemainGet_11-OSTmrRemainGet_8
000052AA  0008      15816          dc.w      OSTmrRemainGet_9-OSTmrRemainGet_8
                    15817   OSTmrRemainGet_9:
                    15818   ; case OS_TMR_STATE_RUNNING:
                    15819   ; remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
000052AC  2043      15820          move.l    D3,A0
000052AE  2028 0012 15821          move.l    18(A0),D0
000052B2  90B9 0800 15822          sub.l     _OSTmrTime.L,D0
000052B6  0D86      
000052B8  2800      15823          move.l    D0,D4
                    15824   ; OSSchedUnlock();
000052BA  4E92      15825          jsr       (A2)
                    15826   ; *perr  = OS_ERR_NONE;
000052BC  2042      15827          move.l    D2,A0
000052BE  4210      15828          clr.b     (A0)
                    15829   ; return (remain);
000052C0  2004      15830          move.l    D4,D0
000052C2  6000 0070 15831          bra       OSTmrRemainGet_3
                    15832   OSTmrRemainGet_10:
                    15833   ; case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
                    15834   ; switch (ptmr->OSTmrOpt) {
000052C6  2043      15835          move.l    D3,A0
000052C8  1028 0022 15836          move.b    34(A0),D0
000052CC  C0BC 0000 15837          and.l     #255,D0
000052D0  00FF      
000052D2  0C80 0000 15838          cmp.l     #2,D0
000052D6  0002      
000052D8  670C      15839          beq.s     OSTmrRemainGet_16
000052DA  6228      15840          bhi.s     OSTmrRemainGet_17
000052DC  0C80 0000 15841          cmp.l     #1,D0
000052E0  0001      
000052E2  6720      15842          beq.s     OSTmrRemainGet_17
000052E4  601E      15843          bra.s     OSTmrRemainGet_17
                    15844   OSTmrRemainGet_16:
                    15845   ; case OS_TMR_OPT_PERIODIC:
                    15846   ; if (ptmr->OSTmrDly == 0u) {
000052E6  2043      15847          move.l    D3,A0
000052E8  2028 0016 15848          move.l    22(A0),D0
000052EC  6608      15849          bne.s     OSTmrRemainGet_19
                    15850   ; remain = ptmr->OSTmrPeriod;
000052EE  2043      15851          move.l    D3,A0
000052F0  2828 001A 15852          move.l    26(A0),D4
000052F4  6006      15853          bra.s     OSTmrRemainGet_20
                    15854   OSTmrRemainGet_19:
                    15855   ; } else {
                    15856   ; remain = ptmr->OSTmrDly;
000052F6  2043      15857          move.l    D3,A0
000052F8  2828 0016 15858          move.l    22(A0),D4
                    15859   OSTmrRemainGet_20:
                    15860   ; }
                    15861   ; OSSchedUnlock();
000052FC  4E92      15862          jsr       (A2)
                    15863   ; *perr  = OS_ERR_NONE;
000052FE  2042      15864          move.l    D2,A0
00005300  4210      15865          clr.b     (A0)
                    15866   ; break;
00005302  600C      15867          bra.s     OSTmrRemainGet_15
                    15868   OSTmrRemainGet_17:
                    15869   ; case OS_TMR_OPT_ONE_SHOT:
                    15870   ; default:
                    15871   ; remain = ptmr->OSTmrDly;
00005304  2043      15872          move.l    D3,A0
00005306  2828 0016 15873          move.l    22(A0),D4
                    15874   ; OSSchedUnlock();
0000530A  4E92      15875          jsr       (A2)
                    15876   ; *perr  = OS_ERR_NONE;
0000530C  2042      15877          move.l    D2,A0
0000530E  4210      15878          clr.b     (A0)
                    15879   ; break;
                    15880   OSTmrRemainGet_15:
                    15881   ; }
                    15882   ; return (remain);
00005310  2004      15883          move.l    D4,D0
00005312  6020      15884          bra.s     OSTmrRemainGet_3
                    15885   OSTmrRemainGet_11:
                    15886   ; case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
                    15887   ; OSSchedUnlock();
00005314  4E92      15888          jsr       (A2)
                    15889   ; *perr = OS_ERR_NONE;
00005316  2042      15890          move.l    D2,A0
00005318  4210      15891          clr.b     (A0)
                    15892   ; return (0u);
0000531A  4280      15893          clr.l     D0
0000531C  6016      15894          bra.s     OSTmrRemainGet_3
                    15895   OSTmrRemainGet_12:
                    15896   ; case OS_TMR_STATE_UNUSED:
                    15897   ; OSSchedUnlock();
0000531E  4E92      15898          jsr       (A2)
                    15899   ; *perr = OS_ERR_TMR_INACTIVE;
00005320  2042      15900          move.l    D2,A0
00005322  10BC 0087 15901          move.b    #135,(A0)
                    15902   ; return (0u);
00005326  4280      15903          clr.l     D0
00005328  600A      15904          bra.s     OSTmrRemainGet_3
                    15905   OSTmrRemainGet_6:
                    15906   ; default:
                    15907   ; OSSchedUnlock();
0000532A  4E92      15908          jsr       (A2)
                    15909   ; *perr = OS_ERR_TMR_INVALID_STATE;
0000532C  2042      15910          move.l    D2,A0
0000532E  10BC 008D 15911          move.b    #141,(A0)
                    15912   ; return (0u);
00005332  4280      15913          clr.l     D0
                    15914   OSTmrRemainGet_3:
00005334  4CDF 041C 15915          movem.l   (A7)+,D2/D3/D4/A2
00005338  4E5E      15916          unlk      A6
0000533A  4E75      15917          rts
                    15918   ; }
                    15919   ; }
                    15920   ; #endif
                    15921   ; /*$PAGE*/
                    15922   ; /*
                    15923   ; *********************************************************************************************************
                    15924   ; *                                  FIND OUT WHAT STATE A TIMER IS IN
                    15925   ; *
                    15926   ; * Description: This function is called to determine what state the timer is in:
                    15927   ; *
                    15928   ; *                  OS_TMR_STATE_UNUSED     the timer has not been created
                    15929   ; *                  OS_TMR_STATE_STOPPED    the timer has been created but has not been started or has been stopped
                    15930   ; *                  OS_TMR_STATE_COMPLETED  the timer is in ONE-SHOT mode and has completed it's timeout
                    15931   ; *                  OS_TMR_STATE_RUNNING    the timer is currently running
                    15932   ; *
                    15933   ; * Arguments  : ptmr          Is a pointer to the desired timer
                    15934   ; *
                    15935   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15936   ; *                               OS_ERR_NONE
                    15937   ; *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
                    15938   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    15939   ; *                               OS_ERR_TMR_ISR            if the call was made from an ISR
                    15940   ; *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
                    15941   ; *                               OS_ERR_TMR_INVALID_STATE  if the timer is not in a valid state
                    15942   ; *
                    15943   ; * Returns    : The current state of the timer (see description).
                    15944   ; *********************************************************************************************************
                    15945   ; */
                    15946   ; #if OS_TMR_EN > 0u
                    15947   ; INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                    15948   ; INT8U   *perr)
                    15949   ; {
                    15950   _OSTmrStateGet:
0000533C  4E56 0000 15951          link      A6,#0
00005340  48E7 3000 15952          movem.l   D2/D3,-(A7)
00005344  242E 000C 15953          move.l    12(A6),D2
                    15954   ; INT8U  state;
                    15955   ; #ifdef OS_SAFETY_CRITICAL
                    15956   ; if (perr == (INT8U *)0) {
                    15957   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15958   ; return (0u);
                    15959   ; }
                    15960   ; #endif
                    15961   ; #if OS_ARG_CHK_EN > 0u
                    15962   ; if (ptmr == (OS_TMR *)0) {
                    15963   ; *perr = OS_ERR_TMR_INVALID;
                    15964   ; return (0u);
                    15965   ; }
                    15966   ; #endif
                    15967   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
00005348  206E 0008 15968          move.l    8(A6),A0
0000534C  1010      15969          move.b    (A0),D0
0000534E  0C00 0064 15970          cmp.b     #100,D0
00005352  670C      15971          beq.s     OSTmrStateGet_1
                    15972   ; *perr = OS_ERR_TMR_INVALID_TYPE;
00005354  2042      15973          move.l    D2,A0
00005356  10BC 0089 15974          move.b    #137,(A0)
                    15975   ; return (0u);
0000535A  4200      15976          clr.b     D0
0000535C  6000 005A 15977          bra       OSTmrStateGet_3
                    15978   OSTmrStateGet_1:
                    15979   ; }
                    15980   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
00005360  1039 0800 15981          move.b    _OSIntNesting.L,D0
00005364  030E      
00005366  0C00 0000 15982          cmp.b     #0,D0
0000536A  630C      15983          bls.s     OSTmrStateGet_4
                    15984   ; *perr = OS_ERR_TMR_ISR;
0000536C  2042      15985          move.l    D2,A0
0000536E  10BC 008B 15986          move.b    #139,(A0)
                    15987   ; return (0u);
00005372  4200      15988          clr.b     D0
00005374  6000 0042 15989          bra       OSTmrStateGet_3
                    15990   OSTmrStateGet_4:
                    15991   ; }
                    15992   ; OSSchedLock();
00005378  4EB8 0E2A 15993          jsr       _OSSchedLock
                    15994   ; state = ptmr->OSTmrState;
0000537C  206E 0008 15995          move.l    8(A6),A0
00005380  1628 0023 15996          move.b    35(A0),D3
                    15997   ; switch (state) {
00005384  C6BC 0000 15998          and.l     #255,D3
00005388  00FF      
0000538A  2003      15999          move.l    D3,D0
0000538C  0C80 0000 16000          cmp.l     #4,D0
00005390  0004      
00005392  6418      16001          bhs.s     OSTmrStateGet_6
00005394  E380      16002          asl.l     #1,D0
00005396  303B 0806 16003          move.w    OSTmrStateGet_8(PC,D0.L),D0
0000539A  4EFB 0002 16004          jmp       OSTmrStateGet_8(PC,D0.W)
                    16005   OSTmrStateGet_8:
0000539E  0008      16006          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
000053A0  0008      16007          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
000053A2  0008      16008          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
000053A4  0008      16009          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
                    16010   OSTmrStateGet_9:
                    16011   ; case OS_TMR_STATE_UNUSED:
                    16012   ; case OS_TMR_STATE_STOPPED:
                    16013   ; case OS_TMR_STATE_COMPLETED:
                    16014   ; case OS_TMR_STATE_RUNNING:
                    16015   ; *perr = OS_ERR_NONE;
000053A6  2042      16016          move.l    D2,A0
000053A8  4210      16017          clr.b     (A0)
                    16018   ; break;
000053AA  6006      16019          bra.s     OSTmrStateGet_7
                    16020   OSTmrStateGet_6:
                    16021   ; default:
                    16022   ; *perr = OS_ERR_TMR_INVALID_STATE;
000053AC  2042      16023          move.l    D2,A0
000053AE  10BC 008D 16024          move.b    #141,(A0)
                    16025   ; break;
                    16026   OSTmrStateGet_7:
                    16027   ; }
                    16028   ; OSSchedUnlock();
000053B2  4EB8 0E5A 16029          jsr       _OSSchedUnlock
                    16030   ; return (state);
000053B6  1003      16031          move.b    D3,D0
                    16032   OSTmrStateGet_3:
000053B8  4CDF 000C 16033          movem.l   (A7)+,D2/D3
000053BC  4E5E      16034          unlk      A6
000053BE  4E75      16035          rts
                    16036   ; }
                    16037   ; #endif
                    16038   ; /*$PAGE*/
                    16039   ; /*
                    16040   ; *********************************************************************************************************
                    16041   ; *                                            START A TIMER
                    16042   ; *
                    16043   ; * Description: This function is called by your application code to start a timer.
                    16044   ; *
                    16045   ; * Arguments  : ptmr          Is a pointer to an OS_TMR
                    16046   ; *
                    16047   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16048   ; *                               OS_ERR_NONE
                    16049   ; *                               OS_ERR_TMR_INVALID
                    16050   ; *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
                    16051   ; *                               OS_ERR_TMR_ISR             if the call was made from an ISR
                    16052   ; *                               OS_ERR_TMR_INACTIVE        if the timer was not created
                    16053   ; *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
                    16054   ; *
                    16055   ; * Returns    : OS_TRUE    if the timer was started
                    16056   ; *              OS_FALSE   if an error was detected
                    16057   ; *********************************************************************************************************
                    16058   ; */
                    16059   ; #if OS_TMR_EN > 0u
                    16060   ; BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                    16061   ; INT8U    *perr)
                    16062   ; {
                    16063   _OSTmrStart:
000053C0  4E56 0000 16064          link      A6,#0
000053C4  48E7 3020 16065          movem.l   D2/D3/A2,-(A7)
000053C8  242E 000C 16066          move.l    12(A6),D2
000053CC  262E 0008 16067          move.l    8(A6),D3
000053D0  45F8 0E5A 16068          lea       _OSSchedUnlock.L,A2
                    16069   ; #ifdef OS_SAFETY_CRITICAL
                    16070   ; if (perr == (INT8U *)0) {
                    16071   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16072   ; return (OS_FALSE);
                    16073   ; }
                    16074   ; #endif
                    16075   ; #if OS_ARG_CHK_EN > 0u
                    16076   ; if (ptmr == (OS_TMR *)0) {
                    16077   ; *perr = OS_ERR_TMR_INVALID;
                    16078   ; return (OS_FALSE);
                    16079   ; }
                    16080   ; #endif
                    16081   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
000053D4  2043      16082          move.l    D3,A0
000053D6  1010      16083          move.b    (A0),D0
000053D8  0C00 0064 16084          cmp.b     #100,D0
000053DC  670C      16085          beq.s     OSTmrStart_1
                    16086   ; *perr = OS_ERR_TMR_INVALID_TYPE;
000053DE  2042      16087          move.l    D2,A0
000053E0  10BC 0089 16088          move.b    #137,(A0)
                    16089   ; return (OS_FALSE);
000053E4  4200      16090          clr.b     D0
000053E6  6000 0094 16091          bra       OSTmrStart_3
                    16092   OSTmrStart_1:
                    16093   ; }
                    16094   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
000053EA  1039 0800 16095          move.b    _OSIntNesting.L,D0
000053EE  030E      
000053F0  0C00 0000 16096          cmp.b     #0,D0
000053F4  630C      16097          bls.s     OSTmrStart_4
                    16098   ; *perr  = OS_ERR_TMR_ISR;
000053F6  2042      16099          move.l    D2,A0
000053F8  10BC 008B 16100          move.b    #139,(A0)
                    16101   ; return (OS_FALSE);
000053FC  4200      16102          clr.b     D0
000053FE  6000 007C 16103          bra       OSTmrStart_3
                    16104   OSTmrStart_4:
                    16105   ; }
                    16106   ; OSSchedLock();
00005402  4EB8 0E2A 16107          jsr       _OSSchedLock
                    16108   ; switch (ptmr->OSTmrState) {
00005406  2043      16109          move.l    D3,A0
00005408  1028 0023 16110          move.b    35(A0),D0
0000540C  C0BC 0000 16111          and.l     #255,D0
00005410  00FF      
00005412  0C80 0000 16112          cmp.l     #4,D0
00005416  0004      
00005418  6400 0058 16113          bhs       OSTmrStart_6
0000541C  E380      16114          asl.l     #1,D0
0000541E  303B 0806 16115          move.w    OSTmrStart_8(PC,D0.L),D0
00005422  4EFB 0002 16116          jmp       OSTmrStart_8(PC,D0.W)
                    16117   OSTmrStart_8:
00005426  0040      16118          dc.w      OSTmrStart_12-OSTmrStart_8
00005428  002A      16119          dc.w      OSTmrStart_10-OSTmrStart_8
0000542A  002A      16120          dc.w      OSTmrStart_10-OSTmrStart_8
0000542C  0008      16121          dc.w      OSTmrStart_9-OSTmrStart_8
                    16122   OSTmrStart_9:
                    16123   ; case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
                    16124   ; OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
0000542E  2F03      16125          move.l    D3,-(A7)
00005430  4EB9 0000 16126          jsr       @ucos_ii_OSTmr_Unlink
00005434  58B8      
00005436  584F      16127          addq.w    #4,A7
                    16128   ; OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
00005438  42A7      16129          clr.l     -(A7)
0000543A  2F03      16130          move.l    D3,-(A7)
0000543C  4EB9 0000 16131          jsr       @ucos_ii_OSTmr_Link
00005440  57E4      
00005442  504F      16132          addq.w    #8,A7
                    16133   ; OSSchedUnlock();
00005444  4E92      16134          jsr       (A2)
                    16135   ; *perr = OS_ERR_NONE;
00005446  2042      16136          move.l    D2,A0
00005448  4210      16137          clr.b     (A0)
                    16138   ; return (OS_TRUE);
0000544A  7001      16139          moveq     #1,D0
0000544C  6000 002E 16140          bra       OSTmrStart_3
                    16141   OSTmrStart_10:
                    16142   ; case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
                    16143   ; case OS_TMR_STATE_COMPLETED:
                    16144   ; OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
00005450  42A7      16145          clr.l     -(A7)
00005452  2F03      16146          move.l    D3,-(A7)
00005454  4EB9 0000 16147          jsr       @ucos_ii_OSTmr_Link
00005458  57E4      
0000545A  504F      16148          addq.w    #8,A7
                    16149   ; OSSchedUnlock();
0000545C  4E92      16150          jsr       (A2)
                    16151   ; *perr = OS_ERR_NONE;
0000545E  2042      16152          move.l    D2,A0
00005460  4210      16153          clr.b     (A0)
                    16154   ; return (OS_TRUE);
00005462  7001      16155          moveq     #1,D0
00005464  6016      16156          bra.s     OSTmrStart_3
                    16157   OSTmrStart_12:
                    16158   ; case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
                    16159   ; OSSchedUnlock();
00005466  4E92      16160          jsr       (A2)
                    16161   ; *perr = OS_ERR_TMR_INACTIVE;
00005468  2042      16162          move.l    D2,A0
0000546A  10BC 0087 16163          move.b    #135,(A0)
                    16164   ; return (OS_FALSE);
0000546E  4200      16165          clr.b     D0
00005470  600A      16166          bra.s     OSTmrStart_3
                    16167   OSTmrStart_6:
                    16168   ; default:
                    16169   ; OSSchedUnlock();
00005472  4E92      16170          jsr       (A2)
                    16171   ; *perr = OS_ERR_TMR_INVALID_STATE;
00005474  2042      16172          move.l    D2,A0
00005476  10BC 008D 16173          move.b    #141,(A0)
                    16174   ; return (OS_FALSE);
0000547A  4200      16175          clr.b     D0
                    16176   OSTmrStart_3:
0000547C  4CDF 040C 16177          movem.l   (A7)+,D2/D3/A2
00005480  4E5E      16178          unlk      A6
00005482  4E75      16179          rts
                    16180   ; }
                    16181   ; }
                    16182   ; #endif
                    16183   ; /*$PAGE*/
                    16184   ; /*
                    16185   ; *********************************************************************************************************
                    16186   ; *                                            STOP A TIMER
                    16187   ; *
                    16188   ; * Description: This function is called by your application code to stop a timer.
                    16189   ; *
                    16190   ; * Arguments  : ptmr          Is a pointer to the timer to stop.
                    16191   ; *
                    16192   ; *              opt           Allows you to specify an option to this functions which can be:
                    16193   ; *
                    16194   ; *                               OS_TMR_OPT_NONE          Do nothing special but stop the timer
                    16195   ; *                               OS_TMR_OPT_CALLBACK      Execute the callback function, pass it the 
                    16196   ; *                                                        callback argument specified when the timer 
                    16197   ; *                                                        was created.
                    16198   ; *                               OS_TMR_OPT_CALLBACK_ARG  Execute the callback function, pass it the 
                    16199   ; *                                                        callback argument specified in THIS function call.
                    16200   ; *
                    16201   ; *              callback_arg  Is a pointer to a 'new' callback argument that can be passed to the callback 
                    16202   ; *                            function instead of the timer's callback argument.  In other words, use 
                    16203   ; *                            'callback_arg' passed in THIS function INSTEAD of ptmr->OSTmrCallbackArg.
                    16204   ; *
                    16205   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16206   ; *                               OS_ERR_NONE
                    16207   ; *                               OS_ERR_TMR_INVALID         'ptmr' is a NULL pointer
                    16208   ; *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
                    16209   ; *                               OS_ERR_TMR_ISR             if the function was called from an ISR
                    16210   ; *                               OS_ERR_TMR_INACTIVE        if the timer was not created
                    16211   ; *                               OS_ERR_TMR_INVALID_OPT     if you specified an invalid option for 'opt'
                    16212   ; *                               OS_ERR_TMR_STOPPED         if the timer was already stopped
                    16213   ; *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
                    16214   ; *                               OS_ERR_TMR_NO_CALLBACK     if the timer does not have a callback function defined
                    16215   ; *
                    16216   ; * Returns    : OS_TRUE       If we stopped the timer (if the timer is already stopped, we also return OS_TRUE)
                    16217   ; *              OS_FALSE      If not
                    16218   ; *********************************************************************************************************
                    16219   ; */
                    16220   ; #if OS_TMR_EN > 0u
                    16221   ; BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    16222   ; INT8U    opt,
                    16223   ; void    *callback_arg,
                    16224   ; INT8U   *perr)
                    16225   ; {
                    16226   _OSTmrStop:
00005484  4E56 0000 16227          link      A6,#0
00005488  48E7 3820 16228          movem.l   D2/D3/D4/A2,-(A7)
0000548C  242E 0014 16229          move.l    20(A6),D2
00005490  262E 0008 16230          move.l    8(A6),D3
00005494  45F8 0E5A 16231          lea       _OSSchedUnlock.L,A2
                    16232   ; OS_TMR_CALLBACK  pfnct;
                    16233   ; #ifdef OS_SAFETY_CRITICAL
                    16234   ; if (perr == (INT8U *)0) {
                    16235   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16236   ; return (OS_FALSE);
                    16237   ; }
                    16238   ; #endif
                    16239   ; #if OS_ARG_CHK_EN > 0u
                    16240   ; if (ptmr == (OS_TMR *)0) {
                    16241   ; *perr = OS_ERR_TMR_INVALID;
                    16242   ; return (OS_FALSE);
                    16243   ; }
                    16244   ; #endif
                    16245   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
00005498  2043      16246          move.l    D3,A0
0000549A  1010      16247          move.b    (A0),D0
0000549C  0C00 0064 16248          cmp.b     #100,D0
000054A0  670C      16249          beq.s     OSTmrStop_1
                    16250   ; *perr = OS_ERR_TMR_INVALID_TYPE;
000054A2  2042      16251          move.l    D2,A0
000054A4  10BC 0089 16252          move.b    #137,(A0)
                    16253   ; return (OS_FALSE);
000054A8  4200      16254          clr.b     D0
000054AA  6000 00F2 16255          bra       OSTmrStop_3
                    16256   OSTmrStop_1:
                    16257   ; }
                    16258   ; if (OSIntNesting > 0u) {                                      /* See if trying to call from an ISR                */
000054AE  1039 0800 16259          move.b    _OSIntNesting.L,D0
000054B2  030E      
000054B4  0C00 0000 16260          cmp.b     #0,D0
000054B8  630C      16261          bls.s     OSTmrStop_4
                    16262   ; *perr  = OS_ERR_TMR_ISR;
000054BA  2042      16263          move.l    D2,A0
000054BC  10BC 008B 16264          move.b    #139,(A0)
                    16265   ; return (OS_FALSE);
000054C0  4200      16266          clr.b     D0
000054C2  6000 00DA 16267          bra       OSTmrStop_3
                    16268   OSTmrStop_4:
                    16269   ; }
                    16270   ; OSSchedLock();
000054C6  4EB8 0E2A 16271          jsr       _OSSchedLock
                    16272   ; switch (ptmr->OSTmrState) {
000054CA  2043      16273          move.l    D3,A0
000054CC  1028 0023 16274          move.b    35(A0),D0
000054D0  C0BC 0000 16275          and.l     #255,D0
000054D4  00FF      
000054D6  0C80 0000 16276          cmp.l     #4,D0
000054DA  0004      
000054DC  6400 00B6 16277          bhs       OSTmrStop_6
000054E0  E380      16278          asl.l     #1,D0
000054E2  303B 0806 16279          move.w    OSTmrStop_8(PC,D0.L),D0
000054E6  4EFB 0002 16280          jmp       OSTmrStop_8(PC,D0.W)
                    16281   OSTmrStop_8:
000054EA  009E      16282          dc.w      OSTmrStop_12-OSTmrStop_8
000054EC  0092      16283          dc.w      OSTmrStop_10-OSTmrStop_8
000054EE  0092      16284          dc.w      OSTmrStop_10-OSTmrStop_8
000054F0  0008      16285          dc.w      OSTmrStop_9-OSTmrStop_8
                    16286   OSTmrStop_9:
                    16287   ; case OS_TMR_STATE_RUNNING:
                    16288   ; OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
000054F2  2F03      16289          move.l    D3,-(A7)
000054F4  4EB9 0000 16290          jsr       @ucos_ii_OSTmr_Unlink
000054F8  58B8      
000054FA  584F      16291          addq.w    #4,A7
                    16292   ; *perr = OS_ERR_NONE;
000054FC  2042      16293          move.l    D2,A0
000054FE  4210      16294          clr.b     (A0)
                    16295   ; switch (opt) {
00005500  102E 000F 16296          move.b    15(A6),D0
00005504  C0BC 0000 16297          and.l     #255,D0
00005508  00FF      
0000550A  0C80 0000 16298          cmp.l     #3,D0
0000550E  0003      
00005510  6718      16299          beq.s     OSTmrStop_16
00005512  620A      16300          bhi.s     OSTmrStop_20
00005514  4A80      16301          tst.l     D0
00005516  6700 0056 16302          beq       OSTmrStop_18
0000551A  6000 0054 16303          bra       OSTmrStop_14
                    16304   OSTmrStop_20:
0000551E  0C80 0000 16305          cmp.l     #4,D0
00005522  0004      
00005524  6728      16306          beq.s     OSTmrStop_17
00005526  6000 0048 16307          bra       OSTmrStop_14
                    16308   OSTmrStop_16:
                    16309   ; case OS_TMR_OPT_CALLBACK:
                    16310   ; pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
0000552A  2043      16311          move.l    D3,A0
0000552C  2828 0002 16312          move.l    2(A0),D4
                    16313   ; if (pfnct != (OS_TMR_CALLBACK)0) {
00005530  4A84      16314          tst.l     D4
00005532  6710      16315          beq.s     OSTmrStop_21
                    16316   ; (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
00005534  2043      16317          move.l    D3,A0
00005536  2F28 0006 16318          move.l    6(A0),-(A7)
0000553A  2F03      16319          move.l    D3,-(A7)
0000553C  2044      16320          move.l    D4,A0
0000553E  4E90      16321          jsr       (A0)
00005540  504F      16322          addq.w    #8,A7
00005542  6006      16323          bra.s     OSTmrStop_22
                    16324   OSTmrStop_21:
                    16325   ; } else {
                    16326   ; *perr = OS_ERR_TMR_NO_CALLBACK;
00005544  2042      16327          move.l    D2,A0
00005546  10BC 008F 16328          move.b    #143,(A0)
                    16329   OSTmrStop_22:
                    16330   ; }
                    16331   ; break;
0000554A  6000 002A 16332          bra       OSTmrStop_15
                    16333   OSTmrStop_17:
                    16334   ; case OS_TMR_OPT_CALLBACK_ARG:
                    16335   ; pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
0000554E  2043      16336          move.l    D3,A0
00005550  2828 0002 16337          move.l    2(A0),D4
                    16338   ; if (pfnct != (OS_TMR_CALLBACK)0) {
00005554  4A84      16339          tst.l     D4
00005556  670E      16340          beq.s     OSTmrStop_23
                    16341   ; (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
00005558  2F2E 0010 16342          move.l    16(A6),-(A7)
0000555C  2F03      16343          move.l    D3,-(A7)
0000555E  2044      16344          move.l    D4,A0
00005560  4E90      16345          jsr       (A0)
00005562  504F      16346          addq.w    #8,A7
00005564  6006      16347          bra.s     OSTmrStop_24
                    16348   OSTmrStop_23:
                    16349   ; } else {
                    16350   ; *perr = OS_ERR_TMR_NO_CALLBACK;
00005566  2042      16351          move.l    D2,A0
00005568  10BC 008F 16352          move.b    #143,(A0)
                    16353   OSTmrStop_24:
                    16354   ; }
                    16355   ; break;
0000556C  6008      16356          bra.s     OSTmrStop_15
                    16357   OSTmrStop_18:
                    16358   ; case OS_TMR_OPT_NONE:
                    16359   ; break;
0000556E  6006      16360          bra.s     OSTmrStop_15
                    16361   OSTmrStop_14:
                    16362   ; default:
                    16363   ; *perr = OS_ERR_TMR_INVALID_OPT;
00005570  2042      16364          move.l    D2,A0
00005572  10BC 0084 16365          move.b    #132,(A0)
                    16366   ; break;
                    16367   OSTmrStop_15:
                    16368   ; }
                    16369   ; OSSchedUnlock();
00005576  4E92      16370          jsr       (A2)
                    16371   ; return (OS_TRUE);
00005578  7001      16372          moveq     #1,D0
0000557A  6022      16373          bra.s     OSTmrStop_3
                    16374   OSTmrStop_10:
                    16375   ; case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
                    16376   ; case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
                    16377   ; OSSchedUnlock();
0000557C  4E92      16378          jsr       (A2)
                    16379   ; *perr = OS_ERR_TMR_STOPPED;
0000557E  2042      16380          move.l    D2,A0
00005580  10BC 008E 16381          move.b    #142,(A0)
                    16382   ; return (OS_TRUE);
00005584  7001      16383          moveq     #1,D0
00005586  6016      16384          bra.s     OSTmrStop_3
                    16385   OSTmrStop_12:
                    16386   ; case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
                    16387   ; OSSchedUnlock();
00005588  4E92      16388          jsr       (A2)
                    16389   ; *perr = OS_ERR_TMR_INACTIVE;
0000558A  2042      16390          move.l    D2,A0
0000558C  10BC 0087 16391          move.b    #135,(A0)
                    16392   ; return (OS_FALSE);
00005590  4200      16393          clr.b     D0
00005592  600A      16394          bra.s     OSTmrStop_3
                    16395   OSTmrStop_6:
                    16396   ; default:
                    16397   ; OSSchedUnlock();
00005594  4E92      16398          jsr       (A2)
                    16399   ; *perr = OS_ERR_TMR_INVALID_STATE;
00005596  2042      16400          move.l    D2,A0
00005598  10BC 008D 16401          move.b    #141,(A0)
                    16402   ; return (OS_FALSE);
0000559C  4200      16403          clr.b     D0
                    16404   OSTmrStop_3:
0000559E  4CDF 041C 16405          movem.l   (A7)+,D2/D3/D4/A2
000055A2  4E5E      16406          unlk      A6
000055A4  4E75      16407          rts
                    16408   ; }
                    16409   ; }
                    16410   ; #endif
                    16411   ; /*$PAGE*/
                    16412   ; /*
                    16413   ; *********************************************************************************************************
                    16414   ; *                             SIGNAL THAT IT'S TIME TO UPDATE THE TIMERS
                    16415   ; *
                    16416   ; * Description: This function is typically called by the ISR that occurs at the timer tick rate and is 
                    16417   ; *              used to signal to OSTmr_Task() that it's time to update the timers.
                    16418   ; *
                    16419   ; * Arguments  : none
                    16420   ; *
                    16421   ; * Returns    : OS_ERR_NONE         The call was successful and the timer task was signaled.
                    16422   ; *              OS_ERR_SEM_OVF      If OSTmrSignal() was called more often than OSTmr_Task() can handle 
                    16423   ; *                                  the timers. This would indicate that your system is heavily loaded.
                    16424   ; *              OS_ERR_EVENT_TYPE   Unlikely you would get this error because the semaphore used for 
                    16425   ; *                                  signaling is created by uC/OS-II.
                    16426   ; *              OS_ERR_PEVENT_NULL  Again, unlikely you would ever get this error because the semaphore 
                    16427   ; *                                  used for signaling is created by uC/OS-II.
                    16428   ; *********************************************************************************************************
                    16429   ; */
                    16430   ; #if OS_TMR_EN > 0u
                    16431   ; INT8U  OSTmrSignal (void)
                    16432   ; {
                    16433   _OSTmrSignal:
000055A6  4E56 FFFC 16434          link      A6,#-4
                    16435   ; INT8U  err;
                    16436   ; err = OSSemPost(OSTmrSemSignal);
000055AA  2F39 0800 16437          move.l    _OSTmrSemSignal.L,-(A7)
000055AE  0D8E      
000055B0  4EB8 4116 16438          jsr       _OSSemPost
000055B4  584F      16439          addq.w    #4,A7
000055B6  1D40 FFFF 16440          move.b    D0,-1(A6)
                    16441   ; return (err);
000055BA  102E FFFF 16442          move.b    -1(A6),D0
000055BE  4E5E      16443          unlk      A6
000055C0  4E75      16444          rts
                    16445   ; }
                    16446   ; #endif
                    16447   ; /*$PAGE*/
                    16448   ; /*
                    16449   ; *********************************************************************************************************
                    16450   ; *                                      ALLOCATE AND FREE A TIMER
                    16451   ; *
                    16452   ; * Description: This function is called to allocate a timer.
                    16453   ; *
                    16454   ; * Arguments  : none
                    16455   ; *
                    16456   ; * Returns    : a pointer to a timer if one is available
                    16457   ; *********************************************************************************************************
                    16458   ; */
                    16459   ; #if OS_TMR_EN > 0u
                    16460   ; static  OS_TMR  *OSTmr_Alloc (void)
                    16461   ; {
                    16462   @ucos_ii_OSTmr_Alloc:
000055C2  48E7 2020 16463          movem.l   D2/A2,-(A7)
000055C6  45F9 0800 16464          lea       _OSTmrFreeList.L,A2
000055CA  0FD2      
                    16465   ; OS_TMR *ptmr;
                    16466   ; if (OSTmrFreeList == (OS_TMR *)0) {
000055CC  2012      16467          move.l    (A2),D0
000055CE  6604      16468          bne.s     @ucos_ii_OSTmr_Alloc_1
                    16469   ; return ((OS_TMR *)0);
000055D0  4280      16470          clr.l     D0
000055D2  6022      16471          bra.s     @ucos_ii_OSTmr_Alloc_3
                    16472   @ucos_ii_OSTmr_Alloc_1:
                    16473   ; }
                    16474   ; ptmr            = (OS_TMR *)OSTmrFreeList;
000055D4  2412      16475          move.l    (A2),D2
                    16476   ; OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
000055D6  2042      16477          move.l    D2,A0
000055D8  24A8 000A 16478          move.l    10(A0),(A2)
                    16479   ; ptmr->OSTmrNext = (OS_TCB *)0;
000055DC  2042      16480          move.l    D2,A0
000055DE  42A8 000A 16481          clr.l     10(A0)
                    16482   ; ptmr->OSTmrPrev = (OS_TCB *)0;
000055E2  2042      16483          move.l    D2,A0
000055E4  42A8 000E 16484          clr.l     14(A0)
                    16485   ; OSTmrUsed++;
000055E8  5279 0800 16486          addq.w    #1,_OSTmrUsed.L
000055EC  0D84      
                    16487   ; OSTmrFree--;
000055EE  5379 0800 16488          subq.w    #1,_OSTmrFree.L
000055F2  0D82      
                    16489   ; return (ptmr);
000055F4  2002      16490          move.l    D2,D0
                    16491   @ucos_ii_OSTmr_Alloc_3:
000055F6  4CDF 0404 16492          movem.l   (A7)+,D2/A2
000055FA  4E75      16493          rts
                    16494   ; }
                    16495   ; #endif
                    16496   ; /*
                    16497   ; *********************************************************************************************************
                    16498   ; *                                   RETURN A TIMER TO THE FREE LIST
                    16499   ; *
                    16500   ; * Description: This function is called to return a timer object to the free list of timers.
                    16501   ; *
                    16502   ; * Arguments  : ptmr     is a pointer to the timer to free
                    16503   ; *
                    16504   ; * Returns    : none
                    16505   ; *********************************************************************************************************
                    16506   ; */
                    16507   ; #if OS_TMR_EN > 0u
                    16508   ; static  void  OSTmr_Free (OS_TMR *ptmr)
                    16509   ; {
                    16510   @ucos_ii_OSTmr_Free:
000055FC  4E56 0000 16511          link      A6,#0
00005600  2F02      16512          move.l    D2,-(A7)
00005602  242E 0008 16513          move.l    8(A6),D2
                    16514   ; ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
00005606  2042      16515          move.l    D2,A0
00005608  4228 0023 16516          clr.b     35(A0)
                    16517   ; ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
0000560C  2042      16518          move.l    D2,A0
0000560E  4228 0022 16519          clr.b     34(A0)
                    16520   ; ptmr->OSTmrPeriod      = 0u;
00005612  2042      16521          move.l    D2,A0
00005614  42A8 001A 16522          clr.l     26(A0)
                    16523   ; ptmr->OSTmrMatch       = 0u;
00005618  2042      16524          move.l    D2,A0
0000561A  42A8 0012 16525          clr.l     18(A0)
                    16526   ; ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
0000561E  2042      16527          move.l    D2,A0
00005620  42A8 0002 16528          clr.l     2(A0)
                    16529   ; ptmr->OSTmrCallbackArg = (void *)0;
00005624  2042      16530          move.l    D2,A0
00005626  42A8 0006 16531          clr.l     6(A0)
                    16532   ; #if OS_TMR_CFG_NAME_EN > 0u
                    16533   ; ptmr->OSTmrName        = (INT8U *)(void *)"?";
0000562A  41F9 0000 16534          lea       @ucos_ii_1.L,A0
0000562E  708C      
00005630  2242      16535          move.l    D2,A1
00005632  2348 001E 16536          move.l    A0,30(A1)
                    16537   ; #endif
                    16538   ; ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
00005636  2042      16539          move.l    D2,A0
00005638  42A8 000E 16540          clr.l     14(A0)
                    16541   ; ptmr->OSTmrNext        = OSTmrFreeList;
0000563C  2042      16542          move.l    D2,A0
0000563E  2179 0800 16543          move.l    _OSTmrFreeList.L,10(A0)
00005642  0FD2 000A 
                    16544   ; OSTmrFreeList          = ptmr;
00005646  23C2 0800 16545          move.l    D2,_OSTmrFreeList.L
0000564A  0FD2      
                    16546   ; OSTmrUsed--;                                       /* Update timer object statistics                              */
0000564C  5379 0800 16547          subq.w    #1,_OSTmrUsed.L
00005650  0D84      
                    16548   ; OSTmrFree++;
00005652  5279 0800 16549          addq.w    #1,_OSTmrFree.L
00005656  0D82      
00005658  241F      16550          move.l    (A7)+,D2
0000565A  4E5E      16551          unlk      A6
0000565C  4E75      16552          rts
                    16553   ; }
                    16554   ; #endif
                    16555   ; /*$PAGE*/
                    16556   ; /*
                    16557   ; *********************************************************************************************************
                    16558   ; *                                                    INITIALIZATION
                    16559   ; *                                          INITIALIZE THE FREE LIST OF TIMERS
                    16560   ; *
                    16561   ; * Description: This function is called by OSInit() to initialize the free list of OS_TMRs.
                    16562   ; *
                    16563   ; * Arguments  : none
                    16564   ; *
                    16565   ; * Returns    : none
                    16566   ; *********************************************************************************************************
                    16567   ; */
                    16568   ; #if OS_TMR_EN > 0u
                    16569   ; void  OSTmr_Init (void)
                    16570   ; {
                    16571   _OSTmr_Init:
0000565E  4E56 FFF8 16572          link      A6,#-8
00005662  48E7 3020 16573          movem.l   D2/D3/A2,-(A7)
00005666  45F9 0800 16574          lea       _OSTmrTbl.L,A2
0000566A  0D92      
                    16575   ; #if OS_EVENT_NAME_EN > 0u
                    16576   ; INT8U    err;
                    16577   ; #endif
                    16578   ; INT16U   ix;
                    16579   ; INT16U   ix_next;
                    16580   ; OS_TMR  *ptmr1;
                    16581   ; OS_TMR  *ptmr2;
                    16582   ; OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
0000566C  4878 0240 16583          pea       576
00005670  2F0A      16584          move.l    A2,-(A7)
00005672  4EB8 158E 16585          jsr       _OS_MemClr
00005676  504F      16586          addq.w    #8,A7
                    16587   ; OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
00005678  4878 0020 16588          pea       32
0000567C  4879 0800 16589          pea       _OSTmrWheelTbl.L
00005680  10D6      
00005682  4EB8 158E 16590          jsr       _OS_MemClr
00005686  504F      16591          addq.w    #8,A7
                    16592   ; for (ix = 0u; ix < (OS_TMR_CFG_MAX - 1u); ix++) {                   /* Init. list of free TMRs                    */
00005688  4243      16593          clr.w     D3
                    16594   OSTmr_Init_1:
0000568A  0C43 000F 16595          cmp.w     #15,D3
0000568E  6400 0056 16596          bhs       OSTmr_Init_3
                    16597   ; ix_next = ix + 1u;
00005692  3003      16598          move.w    D3,D0
00005694  5240      16599          addq.w    #1,D0
00005696  3D40 FFFA 16600          move.w    D0,-6(A6)
                    16601   ; ptmr1 = &OSTmrTbl[ix];
0000569A  200A      16602          move.l    A2,D0
0000569C  C6BC 0000 16603          and.l     #65535,D3
000056A0  FFFF      
000056A2  2203      16604          move.l    D3,D1
000056A4  C3FC 0024 16605          muls      #36,D1
000056A8  D081      16606          add.l     D1,D0
000056AA  2400      16607          move.l    D0,D2
                    16608   ; ptmr2 = &OSTmrTbl[ix_next];
000056AC  200A      16609          move.l    A2,D0
000056AE  322E FFFA 16610          move.w    -6(A6),D1
000056B2  C2BC 0000 16611          and.l     #65535,D1
000056B6  FFFF      
000056B8  C3FC 0024 16612          muls      #36,D1
000056BC  D081      16613          add.l     D1,D0
000056BE  2D40 FFFC 16614          move.l    D0,-4(A6)
                    16615   ; ptmr1->OSTmrType    = OS_TMR_TYPE;
000056C2  2042      16616          move.l    D2,A0
000056C4  10BC 0064 16617          move.b    #100,(A0)
                    16618   ; ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
000056C8  2042      16619          move.l    D2,A0
000056CA  4228 0023 16620          clr.b     35(A0)
                    16621   ; ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
000056CE  2042      16622          move.l    D2,A0
000056D0  216E FFFC 16623          move.l    -4(A6),10(A0)
000056D4  000A      
                    16624   ; #if OS_TMR_CFG_NAME_EN > 0u
                    16625   ; ptmr1->OSTmrName    = (INT8U *)(void *)"?";
000056D6  41F9 0000 16626          lea       @ucos_ii_1.L,A0
000056DA  708C      
000056DC  2242      16627          move.l    D2,A1
000056DE  2348 001E 16628          move.l    A0,30(A1)
000056E2  5243      16629          addq.w    #1,D3
000056E4  60A4      16630          bra       OSTmr_Init_1
                    16631   OSTmr_Init_3:
                    16632   ; #endif
                    16633   ; }
                    16634   ; ptmr1               = &OSTmrTbl[ix];
000056E6  200A      16635          move.l    A2,D0
000056E8  C6BC 0000 16636          and.l     #65535,D3
000056EC  FFFF      
000056EE  2203      16637          move.l    D3,D1
000056F0  C3FC 0024 16638          muls      #36,D1
000056F4  D081      16639          add.l     D1,D0
000056F6  2400      16640          move.l    D0,D2
                    16641   ; ptmr1->OSTmrType    = OS_TMR_TYPE;
000056F8  2042      16642          move.l    D2,A0
000056FA  10BC 0064 16643          move.b    #100,(A0)
                    16644   ; ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
000056FE  2042      16645          move.l    D2,A0
00005700  4228 0023 16646          clr.b     35(A0)
                    16647   ; ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
00005704  2042      16648          move.l    D2,A0
00005706  42A8 000A 16649          clr.l     10(A0)
                    16650   ; #if OS_TMR_CFG_NAME_EN > 0u
                    16651   ; ptmr1->OSTmrName    = (INT8U *)(void *)"?";
0000570A  41F9 0000 16652          lea       @ucos_ii_1.L,A0
0000570E  708C      
00005710  2242      16653          move.l    D2,A1
00005712  2348 001E 16654          move.l    A0,30(A1)
                    16655   ; #endif
                    16656   ; OSTmrTime           = 0u;
00005716  42B9 0800 16657          clr.l     _OSTmrTime.L
0000571A  0D86      
                    16658   ; OSTmrUsed           = 0u;
0000571C  4279 0800 16659          clr.w     _OSTmrUsed.L
00005720  0D84      
                    16660   ; OSTmrFree           = OS_TMR_CFG_MAX;
00005722  33FC 0010 16661          move.w    #16,_OSTmrFree.L
00005726  0800 0D82 
                    16662   ; OSTmrFreeList       = &OSTmrTbl[0];
0000572A  23CA 0800 16663          move.l    A2,_OSTmrFreeList.L
0000572E  0FD2      
                    16664   ; OSTmrSem            = OSSemCreate(1u);
00005730  4878 0001 16665          pea       1
00005734  4EB8 3DCE 16666          jsr       _OSSemCreate
00005738  584F      16667          addq.w    #4,A7
0000573A  23C0 0800 16668          move.l    D0,_OSTmrSem.L
0000573E  0D8A      
                    16669   ; OSTmrSemSignal      = OSSemCreate(0u);
00005740  42A7      16670          clr.l     -(A7)
00005742  4EB8 3DCE 16671          jsr       _OSSemCreate
00005746  584F      16672          addq.w    #4,A7
00005748  23C0 0800 16673          move.l    D0,_OSTmrSemSignal.L
0000574C  0D8E      
                    16674   ; #if OS_EVENT_NAME_EN > 0u                                               /* Assign names to semaphores                 */
                    16675   ; OSEventNameSet(OSTmrSem,       (INT8U *)(void *)"uC/OS-II TmrLock",   &err);
0000574E  486E FFF9 16676          pea       -7(A6)
00005752  4879 0000 16677          pea       @ucos_ii_4.L
00005756  70AA      
00005758  2F39 0800 16678          move.l    _OSTmrSem.L,-(A7)
0000575C  0D8A      
0000575E  4EB8 099C 16679          jsr       _OSEventNameSet
00005762  DEFC 000C 16680          add.w     #12,A7
                    16681   ; OSEventNameSet(OSTmrSemSignal, (INT8U *)(void *)"uC/OS-II TmrSignal", &err);
00005766  486E FFF9 16682          pea       -7(A6)
0000576A  4879 0000 16683          pea       @ucos_ii_5.L
0000576E  70BC      
00005770  2F39 0800 16684          move.l    _OSTmrSemSignal.L,-(A7)
00005774  0D8E      
00005776  4EB8 099C 16685          jsr       _OSEventNameSet
0000577A  DEFC 000C 16686          add.w     #12,A7
                    16687   ; #endif
                    16688   ; OSTmr_InitTask();
0000577E  4EB9 0000 16689          jsr       @ucos_ii_OSTmr_InitTask
00005782  578C      
00005784  4CDF 040C 16690          movem.l   (A7)+,D2/D3/A2
00005788  4E5E      16691          unlk      A6
0000578A  4E75      16692          rts
                    16693   ; }
                    16694   ; #endif
                    16695   ; /*$PAGE*/
                    16696   ; /*
                    16697   ; *********************************************************************************************************
                    16698   ; *                                INITIALIZE THE TIMER MANAGEMENT TASK
                    16699   ; *
                    16700   ; * Description: This function is called by OSTmrInit() to create the timer management task.
                    16701   ; *                               * Arguments  : none
                    16702   ; *
                    16703   ; * Returns    : none
                    16704   ; *********************************************************************************************************
                    16705   ; */
                    16706   ; #if OS_TMR_EN > 0u
                    16707   ; static  void  OSTmr_InitTask (void)
                    16708   ; {
                    16709   @ucos_ii_OSTmr_InitTask:
0000578C  4E56 FFFC 16710          link      A6,#-4
                    16711   ; #if OS_TASK_NAME_EN > 0u
                    16712   ; INT8U  err;
                    16713   ; #endif
                    16714   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    16715   ; #if OS_STK_GROWTH == 1u
                    16716   ; (void)OSTaskCreateExt(OSTmr_Task,
00005790  4878 0003 16717          pea       3
00005794  42A7      16718          clr.l     -(A7)
00005796  4878 0080 16719          pea       128
0000579A  4879 0800 16720          pea       _OSTmrTaskStk.L
0000579E  0FD6      
000057A0  4878 FFFD 16721          pea       65533
000057A4  4878 0005 16722          pea       5
000057A8  41F9 0800 16723          lea       _OSTmrTaskStk.L,A0
000057AC  0FD6      
000057AE  D0FC 00FE 16724          add.w     #254,A0
000057B2  2F08      16725          move.l    A0,-(A7)
000057B4  42A7      16726          clr.l     -(A7)
000057B6  4879 0000 16727          pea       @ucos_ii_OSTmr_Task.L
000057BA  5956      
000057BC  4EB8 4544 16728          jsr       _OSTaskCreateExt
000057C0  DEFC 0024 16729          add.w     #36,A7
000057C4  C0BC 0000 16730          and.l     #255,D0
000057C8  00FF      
                    16731   ; (void *)0,                                       /* No arguments passed to OSTmrTask()      */
                    16732   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Top-Of-Stack                        */
                    16733   ; OS_TASK_TMR_PRIO,
                    16734   ; OS_TASK_TMR_ID,
                    16735   ; &OSTmrTaskStk[0],                                /* Set Bottom-Of-Stack                     */
                    16736   ; OS_TASK_TMR_STK_SIZE,
                    16737   ; (void *)0,                                       /* No TCB extension                        */
                    16738   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
                    16739   ; #else
                    16740   ; (void)OSTaskCreateExt(OSTmr_Task,
                    16741   ; (void *)0,                                       /* No arguments passed to OSTmrTask()      */
                    16742   ; &OSTmrTaskStk[0],                                /* Set Top-Of-Stack                        */
                    16743   ; OS_TASK_TMR_PRIO,
                    16744   ; OS_TASK_TMR_ID,
                    16745   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Bottom-Of-Stack                     */
                    16746   ; OS_TASK_TMR_STK_SIZE,
                    16747   ; (void *)0,                                       /* No TCB extension                        */
                    16748   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
                    16749   ; #endif
                    16750   ; #else
                    16751   ; #if OS_STK_GROWTH == 1u
                    16752   ; (void)OSTaskCreate(OSTmr_Task,
                    16753   ; (void *)0,
                    16754   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],
                    16755   ; OS_TASK_TMR_PRIO);
                    16756   ; #else
                    16757   ; (void)OSTaskCreate(OSTmr_Task,
                    16758   ; (void *)0,
                    16759   ; &OSTmrTaskStk[0],
                    16760   ; OS_TASK_TMR_PRIO);
                    16761   ; #endif
                    16762   ; #endif
                    16763   ; #if OS_TASK_NAME_EN > 0u
                    16764   ; OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)(void *)"uC/OS-II Tmr", &err);
000057CA  486E FFFF 16765          pea       -1(A6)
000057CE  4879 0000 16766          pea       @ucos_ii_6.L
000057D2  70D0      
000057D4  4878 0005 16767          pea       5
000057D8  4EB8 4950 16768          jsr       _OSTaskNameSet
000057DC  DEFC 000C 16769          add.w     #12,A7
000057E0  4E5E      16770          unlk      A6
000057E2  4E75      16771          rts
                    16772   ; #endif
                    16773   ; }
                    16774   ; #endif
                    16775   ; /*$PAGE*/
                    16776   ; /*
                    16777   ; *********************************************************************************************************
                    16778   ; *                                 INSERT A TIMER INTO THE TIMER WHEEL
                    16779   ; *
                    16780   ; * Description: This function is called to insert the timer into the timer wheel.  The timer is always 
                    16781   ; *              inserted at the beginning of the list.
                    16782   ; *
                    16783   ; * Arguments  : ptmr          Is a pointer to the timer to insert.
                    16784   ; *
                    16785   ; *              type          Is either:
                    16786   ; *                               OS_TMR_LINK_PERIODIC    Means to re-insert the timer after a period expired
                    16787   ; *                               OS_TMR_LINK_DLY         Means to insert    the timer the first time
                    16788   ; *
                    16789   ; * Returns    : none
                    16790   ; *********************************************************************************************************
                    16791   ; */
                    16792   ; #if OS_TMR_EN > 0u
                    16793   ; static  void  OSTmr_Link (OS_TMR  *ptmr,
                    16794   ; INT8U    type)
                    16795   ; {
                    16796   @ucos_ii_OSTmr_Link:
000057E4  4E56 FFFC 16797          link      A6,#-4
000057E8  48E7 3820 16798          movem.l   D2/D3/D4/A2,-(A7)
000057EC  242E 0008 16799          move.l    8(A6),D2
000057F0  45F9 0800 16800          lea       _OSTmrTime.L,A2
000057F4  0D86      
                    16801   ; OS_TMR       *ptmr1;
                    16802   ; OS_TMR_WHEEL *pspoke;
                    16803   ; INT16U        spoke;
                    16804   ; ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
000057F6  2042      16805          move.l    D2,A0
000057F8  117C 0003 16806          move.b    #3,35(A0)
000057FC  0023      
                    16807   ; if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
000057FE  102E 000F 16808          move.b    15(A6),D0
00005802  0C00 0001 16809          cmp.b     #1,D0
00005806  6610      16810          bne.s     @ucos_ii_OSTmr_Link_1
                    16811   ; ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
00005808  2042      16812          move.l    D2,A0
0000580A  2028 001A 16813          move.l    26(A0),D0
0000580E  D092      16814          add.l     (A2),D0
00005810  2042      16815          move.l    D2,A0
00005812  2140 0012 16816          move.l    D0,18(A0)
00005816  6026      16817          bra.s     @ucos_ii_OSTmr_Link_4
                    16818   @ucos_ii_OSTmr_Link_1:
                    16819   ; } else {
                    16820   ; if (ptmr->OSTmrDly == 0u) {
00005818  2042      16821          move.l    D2,A0
0000581A  2028 0016 16822          move.l    22(A0),D0
0000581E  6610      16823          bne.s     @ucos_ii_OSTmr_Link_3
                    16824   ; ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
00005820  2042      16825          move.l    D2,A0
00005822  2028 001A 16826          move.l    26(A0),D0
00005826  D092      16827          add.l     (A2),D0
00005828  2042      16828          move.l    D2,A0
0000582A  2140 0012 16829          move.l    D0,18(A0)
0000582E  600E      16830          bra.s     @ucos_ii_OSTmr_Link_4
                    16831   @ucos_ii_OSTmr_Link_3:
                    16832   ; } else {
                    16833   ; ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
00005830  2042      16834          move.l    D2,A0
00005832  2028 0016 16835          move.l    22(A0),D0
00005836  D092      16836          add.l     (A2),D0
00005838  2042      16837          move.l    D2,A0
0000583A  2140 0012 16838          move.l    D0,18(A0)
                    16839   @ucos_ii_OSTmr_Link_4:
                    16840   ; }
                    16841   ; }
                    16842   ; spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
0000583E  2002      16843          move.l    D2,D0
00005840  0680 0000 16844          add.l     #18,D0
00005844  0012      
00005846  2040      16845          move.l    D0,A0
00005848  2F10      16846          move.l    (A0),-(A7)
0000584A  4878 0008 16847          pea       8
0000584E  4EB9 0000 16848          jsr       ULDIV
00005852  66E0      
00005854  202F 0004 16849          move.l    4(A7),D0
00005858  504F      16850          addq.w    #8,A7
0000585A  3D40 FFFE 16851          move.w    D0,-2(A6)
                    16852   ; pspoke = &OSTmrWheelTbl[spoke];
0000585E  41F9 0800 16853          lea       _OSTmrWheelTbl.L,A0
00005862  10D6      
00005864  302E FFFE 16854          move.w    -2(A6),D0
00005868  C0BC 0000 16855          and.l     #65535,D0
0000586C  FFFF      
0000586E  E588      16856          lsl.l     #2,D0
00005870  D1C0      16857          add.l     D0,A0
00005872  2608      16858          move.l    A0,D3
                    16859   ; if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
00005874  2043      16860          move.l    D3,A0
00005876  2010      16861          move.l    (A0),D0
00005878  6614      16862          bne.s     @ucos_ii_OSTmr_Link_5
                    16863   ; pspoke->OSTmrFirst   = ptmr;
0000587A  2043      16864          move.l    D3,A0
0000587C  2082      16865          move.l    D2,(A0)
                    16866   ; ptmr->OSTmrNext      = (OS_TMR *)0;
0000587E  2042      16867          move.l    D2,A0
00005880  42A8 000A 16868          clr.l     10(A0)
                    16869   ; pspoke->OSTmrEntries = 1u;
00005884  2043      16870          move.l    D3,A0
00005886  317C 0001 16871          move.w    #1,4(A0)
0000588A  0004      
0000588C  601C      16872          bra.s     @ucos_ii_OSTmr_Link_6
                    16873   @ucos_ii_OSTmr_Link_5:
                    16874   ; } else {
                    16875   ; ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
0000588E  2043      16876          move.l    D3,A0
00005890  2810      16877          move.l    (A0),D4
                    16878   ; pspoke->OSTmrFirst   = ptmr;
00005892  2043      16879          move.l    D3,A0
00005894  2082      16880          move.l    D2,(A0)
                    16881   ; ptmr->OSTmrNext      = (void *)ptmr1;
00005896  2042      16882          move.l    D2,A0
00005898  2144 000A 16883          move.l    D4,10(A0)
                    16884   ; ptmr1->OSTmrPrev     = (void *)ptmr;
0000589C  2044      16885          move.l    D4,A0
0000589E  2142 000E 16886          move.l    D2,14(A0)
                    16887   ; pspoke->OSTmrEntries++;
000058A2  2003      16888          move.l    D3,D0
000058A4  5880      16889          addq.l    #4,D0
000058A6  2040      16890          move.l    D0,A0
000058A8  5250      16891          addq.w    #1,(A0)
                    16892   @ucos_ii_OSTmr_Link_6:
                    16893   ; }
                    16894   ; ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
000058AA  2042      16895          move.l    D2,A0
000058AC  42A8 000E 16896          clr.l     14(A0)
000058B0  4CDF 041C 16897          movem.l   (A7)+,D2/D3/D4/A2
000058B4  4E5E      16898          unlk      A6
000058B6  4E75      16899          rts
                    16900   ; }
                    16901   ; #endif
                    16902   ; /*$PAGE*/
                    16903   ; /*
                    16904   ; *********************************************************************************************************
                    16905   ; *                                 REMOVE A TIMER FROM THE TIMER WHEEL
                    16906   ; *
                    16907   ; * Description: This function is called to remove the timer from the timer wheel.
                    16908   ; *
                    16909   ; * Arguments  : ptmr          Is a pointer to the timer to remove.
                    16910   ; *
                    16911   ; * Returns    : none
                    16912   ; *********************************************************************************************************
                    16913   ; */
                    16914   ; #if OS_TMR_EN > 0u
                    16915   ; static  void  OSTmr_Unlink (OS_TMR *ptmr)
                    16916   ; {
                    16917   @ucos_ii_OSTmr_Unlink:
000058B8  4E56 FFFC 16918          link      A6,#-4
000058BC  48E7 3C00 16919          movem.l   D2/D3/D4/D5,-(A7)
000058C0  242E 0008 16920          move.l    8(A6),D2
                    16921   ; OS_TMR        *ptmr1;
                    16922   ; OS_TMR        *ptmr2;
                    16923   ; OS_TMR_WHEEL  *pspoke;
                    16924   ; INT16U         spoke;
                    16925   ; spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
000058C4  2002      16926          move.l    D2,D0
000058C6  0680 0000 16927          add.l     #18,D0
000058CA  0012      
000058CC  2040      16928          move.l    D0,A0
000058CE  2F10      16929          move.l    (A0),-(A7)
000058D0  4878 0008 16930          pea       8
000058D4  4EB9 0000 16931          jsr       ULDIV
000058D8  66E0      
000058DA  202F 0004 16932          move.l    4(A7),D0
000058DE  504F      16933          addq.w    #8,A7
000058E0  3D40 FFFE 16934          move.w    D0,-2(A6)
                    16935   ; pspoke = &OSTmrWheelTbl[spoke];
000058E4  41F9 0800 16936          lea       _OSTmrWheelTbl.L,A0
000058E8  10D6      
000058EA  302E FFFE 16937          move.w    -2(A6),D0
000058EE  C0BC 0000 16938          and.l     #65535,D0
000058F2  FFFF      
000058F4  E588      16939          lsl.l     #2,D0
000058F6  D1C0      16940          add.l     D0,A0
000058F8  2A08      16941          move.l    A0,D5
                    16942   ; if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
000058FA  2045      16943          move.l    D5,A0
000058FC  B490      16944          cmp.l     (A0),D2
000058FE  6616      16945          bne.s     @ucos_ii_OSTmr_Unlink_1
                    16946   ; ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
00005900  2042      16947          move.l    D2,A0
00005902  2628 000A 16948          move.l    10(A0),D3
                    16949   ; pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
00005906  2045      16950          move.l    D5,A0
00005908  2083      16951          move.l    D3,(A0)
                    16952   ; if (ptmr1 != (OS_TMR *)0) {
0000590A  4A83      16953          tst.l     D3
0000590C  6706      16954          beq.s     @ucos_ii_OSTmr_Unlink_3
                    16955   ; ptmr1->OSTmrPrev = (void *)0;
0000590E  2043      16956          move.l    D3,A0
00005910  42A8 000E 16957          clr.l     14(A0)
                    16958   @ucos_ii_OSTmr_Unlink_3:
00005914  601C      16959          bra.s     @ucos_ii_OSTmr_Unlink_5
                    16960   @ucos_ii_OSTmr_Unlink_1:
                    16961   ; }
                    16962   ; } else {
                    16963   ; ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
00005916  2042      16964          move.l    D2,A0
00005918  2628 000E 16965          move.l    14(A0),D3
                    16966   ; ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
0000591C  2042      16967          move.l    D2,A0
0000591E  2828 000A 16968          move.l    10(A0),D4
                    16969   ; ptmr1->OSTmrNext = ptmr2;
00005922  2043      16970          move.l    D3,A0
00005924  2144 000A 16971          move.l    D4,10(A0)
                    16972   ; if (ptmr2 != (OS_TMR *)0) {
00005928  4A84      16973          tst.l     D4
0000592A  6706      16974          beq.s     @ucos_ii_OSTmr_Unlink_5
                    16975   ; ptmr2->OSTmrPrev = (void *)ptmr1;
0000592C  2044      16976          move.l    D4,A0
0000592E  2143 000E 16977          move.l    D3,14(A0)
                    16978   @ucos_ii_OSTmr_Unlink_5:
                    16979   ; }
                    16980   ; }
                    16981   ; ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
00005932  2042      16982          move.l    D2,A0
00005934  117C 0001 16983          move.b    #1,35(A0)
00005938  0023      
                    16984   ; ptmr->OSTmrNext  = (void *)0;
0000593A  2042      16985          move.l    D2,A0
0000593C  42A8 000A 16986          clr.l     10(A0)
                    16987   ; ptmr->OSTmrPrev  = (void *)0;
00005940  2042      16988          move.l    D2,A0
00005942  42A8 000E 16989          clr.l     14(A0)
                    16990   ; pspoke->OSTmrEntries--;
00005946  2005      16991          move.l    D5,D0
00005948  5880      16992          addq.l    #4,D0
0000594A  2040      16993          move.l    D0,A0
0000594C  5350      16994          subq.w    #1,(A0)
0000594E  4CDF 003C 16995          movem.l   (A7)+,D2/D3/D4/D5
00005952  4E5E      16996          unlk      A6
00005954  4E75      16997          rts
                    16998   ; }
                    16999   ; #endif
                    17000   ; /*$PAGE*/
                    17001   ; /*
                    17002   ; *********************************************************************************************************
                    17003   ; *                                        TIMER MANAGEMENT TASK
                    17004   ; *
                    17005   ; * Description: This task is created by OSTmrInit().
                    17006   ; *
                    17007   ; * Arguments  : none
                    17008   ; *
                    17009   ; * Returns    : none
                    17010   ; *********************************************************************************************************
                    17011   ; */
                    17012   ; #if OS_TMR_EN > 0u
                    17013   ; static  void  OSTmr_Task (void *p_arg)
                    17014   ; {
                    17015   @ucos_ii_OSTmr_Task:
00005956  4E56 FFF4 17016          link      A6,#-12
0000595A  48E7 3020 17017          movem.l   D2/D3/A2,-(A7)
0000595E  45F9 0800 17018          lea       _OSTmrTime.L,A2
00005962  0D86      
                    17019   ; INT8U            err;
                    17020   ; OS_TMR          *ptmr;
                    17021   ; OS_TMR          *ptmr_next;
                    17022   ; OS_TMR_CALLBACK  pfnct;
                    17023   ; OS_TMR_WHEEL    *pspoke;
                    17024   ; INT16U           spoke;
                    17025   ; p_arg = p_arg;                                               /* Prevent compiler warning for not using 'p_arg'    */
                    17026   ; for (;;) {
                    17027   @ucos_ii_OSTmr_Task_1:
                    17028   ; OSSemPend(OSTmrSemSignal, 0u, &err);                     /* Wait for signal indicating time to update timers  */
00005964  486E FFF5 17029          pea       -11(A6)
00005968  42A7      17030          clr.l     -(A7)
0000596A  2F39 0800 17031          move.l    _OSTmrSemSignal.L,-(A7)
0000596E  0D8E      
00005970  4EB8 3F54 17032          jsr       _OSSemPend
00005974  DEFC 000C 17033          add.w     #12,A7
                    17034   ; OSSchedLock();
00005978  4EB8 0E2A 17035          jsr       _OSSchedLock
                    17036   ; OSTmrTime++;                                             /* Increment the current time                        */
0000597C  5292      17037          addq.l    #1,(A2)
                    17038   ; spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
0000597E  2F12      17039          move.l    (A2),-(A7)
00005980  4878 0008 17040          pea       8
00005984  4EB9 0000 17041          jsr       ULDIV
00005988  66E0      
0000598A  202F 0004 17042          move.l    4(A7),D0
0000598E  504F      17043          addq.w    #8,A7
00005990  3D40 FFFE 17044          move.w    D0,-2(A6)
                    17045   ; pspoke = &OSTmrWheelTbl[spoke];
00005994  41F9 0800 17046          lea       _OSTmrWheelTbl.L,A0
00005998  10D6      
0000599A  302E FFFE 17047          move.w    -2(A6),D0
0000599E  C0BC 0000 17048          and.l     #65535,D0
000059A2  FFFF      
000059A4  E588      17049          lsl.l     #2,D0
000059A6  D1C0      17050          add.l     D0,A0
000059A8  2D48 FFFA 17051          move.l    A0,-6(A6)
                    17052   ; ptmr   = pspoke->OSTmrFirst;
000059AC  206E FFFA 17053          move.l    -6(A6),A0
000059B0  2410      17054          move.l    (A0),D2
                    17055   ; while (ptmr != (OS_TMR *)0) {
                    17056   @ucos_ii_OSTmr_Task_4:
000059B2  4A82      17057          tst.l     D2
000059B4  6700 005E 17058          beq       @ucos_ii_OSTmr_Task_6
                    17059   ; ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
000059B8  2042      17060          move.l    D2,A0
000059BA  2D68 000A 17061          move.l    10(A0),-10(A6)
000059BE  FFF6      
                    17062   ; /* ... timer could get unlinked from the wheel.      */
                    17063   ; if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
000059C0  2042      17064          move.l    D2,A0
000059C2  2012      17065          move.l    (A2),D0
000059C4  B0A8 0012 17066          cmp.l     18(A0),D0
000059C8  6600 0044 17067          bne       @ucos_ii_OSTmr_Task_11
                    17068   ; OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
000059CC  2F02      17069          move.l    D2,-(A7)
000059CE  4EB8 58B8 17070          jsr       @ucos_ii_OSTmr_Unlink
000059D2  584F      17071          addq.w    #4,A7
                    17072   ; if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
000059D4  2042      17073          move.l    D2,A0
000059D6  1028 0022 17074          move.b    34(A0),D0
000059DA  0C00 0002 17075          cmp.b     #2,D0
000059DE  660E      17076          bne.s     @ucos_ii_OSTmr_Task_9
                    17077   ; OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
000059E0  4878 0001 17078          pea       1
000059E4  2F02      17079          move.l    D2,-(A7)
000059E6  4EB8 57E4 17080          jsr       @ucos_ii_OSTmr_Link
000059EA  504F      17081          addq.w    #8,A7
000059EC  6008      17082          bra.s     @ucos_ii_OSTmr_Task_10
                    17083   @ucos_ii_OSTmr_Task_9:
                    17084   ; } else {
                    17085   ; ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
000059EE  2042      17086          move.l    D2,A0
000059F0  117C 0002 17087          move.b    #2,35(A0)
000059F4  0023      
                    17088   @ucos_ii_OSTmr_Task_10:
                    17089   ; }
                    17090   ; pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
000059F6  2042      17091          move.l    D2,A0
000059F8  2628 0002 17092          move.l    2(A0),D3
                    17093   ; if (pfnct != (OS_TMR_CALLBACK)0) {
000059FC  4A83      17094          tst.l     D3
000059FE  670E      17095          beq.s     @ucos_ii_OSTmr_Task_11
                    17096   ; (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
00005A00  2042      17097          move.l    D2,A0
00005A02  2F28 0006 17098          move.l    6(A0),-(A7)
00005A06  2F02      17099          move.l    D2,-(A7)
00005A08  2043      17100          move.l    D3,A0
00005A0A  4E90      17101          jsr       (A0)
00005A0C  504F      17102          addq.w    #8,A7
                    17103   @ucos_ii_OSTmr_Task_11:
                    17104   ; }
                    17105   ; }
                    17106   ; ptmr = ptmr_next;
00005A0E  242E FFF6 17107          move.l    -10(A6),D2
00005A12  609E      17108          bra       @ucos_ii_OSTmr_Task_4
                    17109   @ucos_ii_OSTmr_Task_6:
                    17110   ; }
                    17111   ; OSSchedUnlock();
00005A14  4EB8 0E5A 17112          jsr       _OSSchedUnlock
00005A18  6000 FF4A 17113          bra       @ucos_ii_OSTmr_Task_1
                    17114   ; /*
                    17115   ; *********************************************************************************************************
                    17116   ; *                                                uC/OS-II
                    17117   ; *                                          The Real-Time Kernel
                    17118   ; *
                    17119   ; *                              (c) Copyright 1992-2009, Micrium, Weston, FL
                    17120   ; *                                           All Rights Reserved
                    17121   ; *
                    17122   ; * File    : uCOS_II.C
                    17123   ; * By      : Jean J. Labrosse
                    17124   ; * Version : V2.91
                    17125   ; *
                    17126   ; * LICENSING TERMS:
                    17127   ; * ---------------
                    17128   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
                    17129   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
                    17130   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience 
                    17131   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
                    17132   ; * licensing fee.
                    17133   ; *********************************************************************************************************
                    17134   ; */
                    17135   ; #define  OS_GLOBALS                           /* Declare GLOBAL variables                              */
                    17136   ; #include <ucos_ii.h>
                    17137   ; #define  OS_MASTER_FILE                       /* Prevent the following files from including includes.h */
                    17138   ; #include <os_core.c>
                    17139   ; #include <os_flag.c>
                    17140   ; #include <os_mbox.c>
                    17141   ; #include <os_mem.c>
                    17142   ; #include <os_mutex.c>
                    17143   ; #include <os_q.c>
                    17144   ; #include <os_sem.c>
                    17145   ; #include <os_task.c>
                    17146   ; #include <os_time.c>
                    17147   ; #include <os_tmr.c>
                    17148   ; C:\IDE68K\UCOSII\BIOS.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    17149   ; #include <Bios.h>
                    17150   ; /*
                    17151   ; **  These basic IO routines are designed to handle input and output of characters
                    17152   ; **  via the serial port to the console of hyperternal
                    17153   ; **
                    17154   ; **  You need to include this code into your projects, either as a source file, or copy into your code
                    17155   ; */
                    17156   ; // things that need to be done at initialisation/boot include
                    17157   ; // 1) initialise serial port and LCD display
                    17158   ; // 2) initialise the LCD display
                    17159   ; // 3) install the trap handler for a context switch (trap0)
                    17160   ; // 4) install the TickISR for level 3 IRQ
                    17161   ; // these actions can be performed in OSInitHookBegin() in file OS_CPU_C.c (one the Port files)
                    17162   ; /*********************************************************************************************
                    17163   ; *Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                    17164   ; *********************************************************************************************/
                    17165   ; void Init_RS232(void)
                    17166   ; {
                    17167   _Init_RS232:
                    17168   ; RS232_Control = (char)(0x15) ; //  %00010101    divide by 16 clock, set rts low, 8 bits no parity, 1 stop bit transmitter interrupt disabled
00005A1C  13FC 0015 17169          move.b    #21,4194368
00005A20  0040 0040 
                    17170   ; RS232_Baud = (char)(0x1) ;      // program baud rate generator 000 = 230k, 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
00005A24  13FC 0001 17171          move.b    #1,4194372
00005A28  0040 0044 
00005A2C  4E75      17172          rts
                    17173   ; }
                    17174   ; int kbhit(void)
                    17175   ; {
                    17176   _kbhit:
                    17177   ; if(((char)(RS232_Status) & (char)(0x02)) == (char)(0x02))    // wait for Tx bit in status register to be '1'
00005A2E  1039 0040 17178          move.b    4194368,D0
00005A32  0040      
00005A34  C03C 0002 17179          and.b     #2,D0
00005A38  0C00 0002 17180          cmp.b     #2,D0
00005A3C  6604      17181          bne.s     kbhit_1
                    17182   ; return 1 ;
00005A3E  7001      17183          moveq     #1,D0
00005A40  6002      17184          bra.s     kbhit_3
                    17185   kbhit_1:
                    17186   ; else
                    17187   ; return 0 ;
00005A42  4280      17188          clr.l     D0
                    17189   kbhit_3:
00005A44  4E75      17190          rts
                    17191   ; }
                    17192   ; /*********************************************************************************************************
                    17193   ; **  Subroutine to provide a low level output function to 6850 ACIA
                    17194   ; **  This routine provides the basic functionality to output a single character to the serial Port
                    17195   ; **  to allow the board to communicate with HyperTerminal Program
                    17196   ; **
                    17197   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                    17198   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                    17199   ; **  call _putch() also
                    17200   ; *********************************************************************************************************/
                    17201   ; int _putch( int c)
                    17202   ; {
                    17203   __putch:
00005A46  4E56 0000 17204          link      A6,#0
                    17205   ; while(((char)(RS232_Status) & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                    17206   _putch_1:
00005A4A  1039 0040 17207          move.b    4194368,D0
00005A4E  0040      
00005A50  C03C 0002 17208          and.b     #2,D0
00005A54  0C00 0002 17209          cmp.b     #2,D0
00005A58  6702      17210          beq.s     _putch_3
00005A5A  60EE      17211          bra       _putch_1
                    17212   _putch_3:
                    17213   ; ;
                    17214   ; (char)(RS232_TxData) = ((char)(c) & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
00005A5C  202E 0008 17215          move.l    8(A6),D0
00005A60  C03C 007F 17216          and.b     #127,D0
00005A64  13C0 0040 17217          move.b    D0,4194370
00005A68  0042      
                    17218   ; return c ;                                              // putchar() expects the character to be returned
00005A6A  202E 0008 17219          move.l    8(A6),D0
00005A6E  4E5E      17220          unlk      A6
00005A70  4E75      17221          rts
                    17222   ; }
                    17223   ; /*********************************************************************************************************
                    17224   ; **  Subroutine to provide a low level input function to 6850 ACIA
                    17225   ; **  This routine provides the basic functionality to input a single character from the serial Port
                    17226   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                    17227   ; **
                    17228   ; **  NOTE you do not call this function directly, instead you call the normal _getch() function
                    17229   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call _getch() so will
                    17230   ; **  call _getch() also
                    17231   ; *********************************************************************************************************/
                    17232   ; int _getch( void )
                    17233   ; {
                    17234   __getch:
00005A72  2F02      17235          move.l    D2,-(A7)
                    17236   ; int c ;
                    17237   ; while(((char)(RS232_Status) & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                    17238   _getch_1:
00005A74  1039 0040 17239          move.b    4194368,D0
00005A78  0040      
00005A7A  C03C 0001 17240          and.b     #1,D0
00005A7E  0C00 0001 17241          cmp.b     #1,D0
00005A82  6702      17242          beq.s     _getch_3
00005A84  60EE      17243          bra       _getch_1
                    17244   _getch_3:
                    17245   ; ;
                    17246   ; c = (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
00005A86  1039 0040 17247          move.b    4194370,D0
00005A8A  0042      
00005A8C  C0BC 0000 17248          and.l     #255,D0
00005A90  00FF      
00005A92  C0BC 0000 17249          and.l     #127,D0
00005A96  007F      
00005A98  2400      17250          move.l    D0,D2
                    17251   ; _putch(c);
00005A9A  2F02      17252          move.l    D2,-(A7)
00005A9C  4EB8 5A46 17253          jsr       __putch
00005AA0  584F      17254          addq.w    #4,A7
                    17255   ; return c ;
00005AA2  2002      17256          move.l    D2,D0
00005AA4  241F      17257          move.l    (A7)+,D2
00005AA6  4E75      17258          rts
                    17259   ; }
                    17260   ; /************************************************************************************
                    17261   ; *Subroutine to give the 68000 something useless to do to waste 1 mSec
                    17262   ; ************************************************************************************/
                    17263   ; void Wait1ms(void)
                    17264   ; {
                    17265   _Wait1ms:
00005AA8  2F02      17266          move.l    D2,-(A7)
                    17267   ; long int  i ;
                    17268   ; for(i = 0; i < 1000; i ++)
00005AAA  4282      17269          clr.l     D2
                    17270   Wait1ms_1:
00005AAC  0C82 0000 17271          cmp.l     #1000,D2
00005AB0  03E8      
00005AB2  6C04      17272          bge.s     Wait1ms_3
00005AB4  5282      17273          addq.l    #1,D2
00005AB6  60F4      17274          bra       Wait1ms_1
                    17275   Wait1ms_3:
00005AB8  241F      17276          move.l    (A7)+,D2
00005ABA  4E75      17277          rts
                    17278   ; ;
                    17279   ; }
                    17280   ; /************************************************************************************
                    17281   ; *Subroutine to give the 68000 something useless to do to waste 3 mSec
                    17282   ; **************************************************************************************/
                    17283   ; void Wait3ms(void)
                    17284   ; {
                    17285   _Wait3ms:
00005ABC  2F02      17286          move.l    D2,-(A7)
                    17287   ; int i ;
                    17288   ; for(i = 0; i < 3; i++)
00005ABE  4282      17289          clr.l     D2
                    17290   Wait3ms_1:
00005AC0  0C82 0000 17291          cmp.l     #3,D2
00005AC4  0003      
00005AC6  6C08      17292          bge.s     Wait3ms_3
                    17293   ; Wait1ms() ;
00005AC8  4EB8 5AA8 17294          jsr       _Wait1ms
00005ACC  5282      17295          addq.l    #1,D2
00005ACE  60F0      17296          bra       Wait3ms_1
                    17297   Wait3ms_3:
00005AD0  241F      17298          move.l    (A7)+,D2
00005AD2  4E75      17299          rts
                    17300   ; }
                    17301   ; /*********************************************************************************************
                    17302   ; *Subroutine to initialise the display by writing some commands to the LCD internal registers
                    17303   ; *********************************************************************************************/
                    17304   ; void Init_LCD(void)
                    17305   ; {
                    17306   _Init_LCD:
                    17307   ; LCDcommand = (char)(0x0c) ;
00005AD4  13FC 000C 17308          move.b    #12,4194336
00005AD8  0040 0020 
                    17309   ; Wait3ms() ;
00005ADC  4EB8 5ABC 17310          jsr       _Wait3ms
                    17311   ; LCDcommand = (char)(0x38) ;
00005AE0  13FC 0038 17312          move.b    #56,4194336
00005AE4  0040 0020 
                    17313   ; Wait3ms() ;
00005AE8  4EB8 5ABC 17314          jsr       _Wait3ms
00005AEC  4E75      17315          rts
                    17316   ; }
                    17317   ; /******************************************************************************
                    17318   ; *subroutine to output a single character held in d1 to the LCD display
                    17319   ; *it is assumed the character is an ASCII code and it will be displayed at the
                    17320   ; *current cursor position
                    17321   ; *******************************************************************************/
                    17322   ; void Outchar(int c)
                    17323   ; {
                    17324   _Outchar:
00005AEE  4E56 0000 17325          link      A6,#0
                    17326   ; LCDdata = (char)(c);
00005AF2  202E 0008 17327          move.l    8(A6),D0
00005AF6  13C0 0040 17328          move.b    D0,4194338
00005AFA  0022      
                    17329   ; Wait1ms() ;
00005AFC  4EB8 5AA8 17330          jsr       _Wait1ms
00005B00  4E5E      17331          unlk      A6
00005B02  4E75      17332          rts
                    17333   ; }
                    17334   ; /**********************************************************************************
                    17335   ; *subroutine to output a message at the current cursor position of the LCD display
                    17336   ; ************************************************************************************/
                    17337   ; void OutMess(char *theMessage)
                    17338   ; {
                    17339   _OutMess:
00005B04  4E56 FFFC 17340          link      A6,#-4
                    17341   ; char c ;
                    17342   ; while((c = *theMessage++) != (char)(0))
                    17343   OutMess_1:
00005B08  206E 0008 17344          move.l    8(A6),A0
00005B0C  52AE 0008 17345          addq.l    #1,8(A6)
00005B10  1D50 FFFF 17346          move.b    (A0),-1(A6)
00005B14  1010      17347          move.b    (A0),D0
00005B16  6712      17348          beq.s     OutMess_3
                    17349   ; Outchar(c) ;
00005B18  122E FFFF 17350          move.b    -1(A6),D1
00005B1C  4881      17351          ext.w     D1
00005B1E  48C1      17352          ext.l     D1
00005B20  2F01      17353          move.l    D1,-(A7)
00005B22  4EB8 5AEE 17354          jsr       _Outchar
00005B26  584F      17355          addq.w    #4,A7
00005B28  60DE      17356          bra       OutMess_1
                    17357   OutMess_3:
00005B2A  4E5E      17358          unlk      A6
00005B2C  4E75      17359          rts
                    17360   ; }
                    17361   ; /******************************************************************************
                    17362   ; *subroutine to clear the line by issuing 24 space characters
                    17363   ; *******************************************************************************/
                    17364   ; void Clearln(void)
                    17365   ; {
                    17366   _Clearln:
00005B2E  2F02      17367          move.l    D2,-(A7)
                    17368   ; unsigned char i ;
                    17369   ; for(i = 0; i < 24; i ++)
00005B30  4202      17370          clr.b     D2
                    17371   Clearln_1:
00005B32  0C02 0018 17372          cmp.b     #24,D2
00005B36  640E      17373          bhs.s     Clearln_3
                    17374   ; Outchar(' ') ;  /* write a space char to the LCD display */
00005B38  4878 0020 17375          pea       32
00005B3C  4EB8 5AEE 17376          jsr       _Outchar
00005B40  584F      17377          addq.w    #4,A7
00005B42  5202      17378          addq.b    #1,D2
00005B44  60EC      17379          bra       Clearln_1
                    17380   Clearln_3:
00005B46  241F      17381          move.l    (A7)+,D2
00005B48  4E75      17382          rts
                    17383   ; }
                    17384   ; /******************************************************************************
                    17385   ; *subroutine to move the cursor to the start of line 1 and clear that line
                    17386   ; *******************************************************************************/
                    17387   ; void Oline0(char *theMessage)
                    17388   ; {
                    17389   _Oline0:
00005B4A  4E56 0000 17390          link      A6,#0
                    17391   ; LCDcommand = (char)(0x80) ;
00005B4E  13FC 0080 17392          move.b    #128,4194336
00005B52  0040 0020 
                    17393   ; Wait3ms();
00005B56  4EB8 5ABC 17394          jsr       _Wait3ms
                    17395   ; Clearln() ;
00005B5A  4EB8 5B2E 17396          jsr       _Clearln
                    17397   ; LCDcommand = (char)(0x80) ;
00005B5E  13FC 0080 17398          move.b    #128,4194336
00005B62  0040 0020 
                    17399   ; Wait3ms() ;
00005B66  4EB8 5ABC 17400          jsr       _Wait3ms
                    17401   ; OutMess(theMessage) ;
00005B6A  2F2E 0008 17402          move.l    8(A6),-(A7)
00005B6E  4EB8 5B04 17403          jsr       _OutMess
00005B72  584F      17404          addq.w    #4,A7
00005B74  4E5E      17405          unlk      A6
00005B76  4E75      17406          rts
                    17407   ; }
                    17408   ; /******************************************************************************
                    17409   ; *subroutine to move the cursor to the start of line 2 and clear that line
                    17410   ; *******************************************************************************/
                    17411   ; void Oline1(char *theMessage)
                    17412   ; {
                    17413   _Oline1:
00005B78  4E56 0000 17414          link      A6,#0
                    17415   ; LCDcommand = (char)(0xC0) ;
00005B7C  13FC 00C0 17416          move.b    #192,4194336
00005B80  0040 0020 
                    17417   ; Wait3ms();
00005B84  4EB8 5ABC 17418          jsr       _Wait3ms
                    17419   ; Clearln() ;
00005B88  4EB8 5B2E 17420          jsr       _Clearln
                    17421   ; LCDcommand = (char)(0xC0) ;
00005B8C  13FC 00C0 17422          move.b    #192,4194336
00005B90  0040 0020 
                    17423   ; Wait3ms() ;
00005B94  4EB8 5ABC 17424          jsr       _Wait3ms
                    17425   ; OutMess(theMessage) ;
00005B98  2F2E 0008 17426          move.l    8(A6),-(A7)
00005B9C  4EB8 5B04 17427          jsr       _OutMess
00005BA0  584F      17428          addq.w    #4,A7
00005BA2  4E5E      17429          unlk      A6
00005BA4  4E75      17430          rts
                    17431   ; }
                    17432   ; /*********************************************************************************
                    17433   ; ** Timer ISR
                    17434   ; **********************************************************************************/
                    17435   ; void Timer_ISR(void)
                    17436   ; {
                    17437   _Timer_ISR:
                    17438   ; if(Timer1Status == 1) {       // Did Timer 1 produce the Interrupt?
00005BA6  1039 0040 17439          move.b    4194354,D0
00005BAA  0032      
00005BAC  0C00 0001 17440          cmp.b     #1,D0
00005BB0  6608      17441          bne.s     Timer_ISR_1
                    17442   ; Timer1Control = 3;      	// if so clear interrupt and restart timer
00005BB2  13FC 0003 17443          move.b    #3,4194354
00005BB6  0040 0032 
                    17444   Timer_ISR_1:
00005BBA  4E75      17445          rts
                    17446   ; }
                    17447   ; }
                    17448   ; /**********************************************************************************
                    17449   ; ** Timer Initialisation Routine
                    17450   ; **********************************************************************************/
                    17451   ; void Timer1_Init(void)
                    17452   ; {
                    17453   _Timer1_Init:
                    17454   ; Timer1Data = 0x03;		// program 100 hz time delay into timer 1.
00005BBC  13FC 0003 17455          move.b    #3,4194352
00005BC0  0040 0030 
                    17456   ; /*
                    17457   ; ** timer driven off 25Mhz clock so program value so that it counts down in 0.01 secs
                    17458   ; ** the example 0x03 above is loaded into top 8 bits of a 24 bit timer so reads as
                    17459   ; ** 0x03FFFF a value of 0x03 would be 262,143/25,000,000, so is close to 1/100th sec
                    17460   ; **
                    17461   ; **
                    17462   ; ** Now write binary 00000011 to timer control register:
                    17463   ; **	Bit0 = 1 (enable interrupt from that timer)
                    17464   ; **	Bit 1 = 1 enable counting
                    17465   ; */
                    17466   ; Timer1Control = 3;
00005BC4  13FC 0003 17467          move.b    #3,4194354
00005BC8  0040 0032 
00005BCC  4E75      17468          rts
                    17469   ; }
                    17470   ; /*********************************************************************************************************************************
                    17471   ; **  IMPORTANT FUNCTION
                    17472   ; **  This function installs an exception (interrupt) handler so you can capture and deal with any 68000 exception in your program
                    17473   ; **  You pass it the name of a function in your code that will get called in response to the exception (as the 1st parameter)
                    17474   ; **  and in the 2nd parameter, you pass it the exception number that you want to take over (see 68000 exceptions for details)
                    17475   ; **  Calling this function allows you to deal with Interrupts for example
                    17476   ; **
                    17477   ; **	e.g. to install the function 'void Timer_ISR()' (see above in this program) to deal with interrupts from the timer do this
                    17478   ; **
                    17479   ; **	InstallExceptionHandler(Timer_ISR, 27) ;		// install interrupt handler for Timers 1-8 on level 3 IRQ (exception number 27 on 68k)
                    17480   ; **
                    17481   ; **	see main below for other examples
                    17482   ; ***********************************************************************************************************************************/
                    17483   ; /*
                    17484   ; void InstallExceptionHandler( void (*function_ptr)(), int level)
                    17485   ; {
                    17486   ; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
                    17487   ; RamVectorAddress[level] = (long int *)(function_ptr);                       // install the address of our function into the exception table
                    17488   ; }
                    17489   ; */
                    17490   ; C:\M68KV6.0 - 800BY480\ASSIGNMENT6\PARTB_PROJ\PART_B.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    17491   ; /*
                    17492   ; * EXAMPLE_1.C
                    17493   ; *
                    17494   ; * This is a minimal program to verify multitasking.
                    17495   ; *
                    17496   ; */
                    17497   ; #include <stdio.h>
                    17498   ; #include <Bios.h>
                    17499   ; #include <ucos_ii.h>
                    17500   ; #include <stdlib.h>
                    17501   ; #define STACKSIZE  256
                    17502   ; void CanBusTest(void);
                    17503   ; /* 
                    17504   ; ** Stacks for each task are allocated here in the application in this case = 256 bytes
                    17505   ; ** but you can change size if required
                    17506   ; */
                    17507   ; OS_STK Task1Stk[STACKSIZE];
                    17508   ; OS_STK Task2Stk[STACKSIZE];
                    17509   ; OS_STK Task3Stk[STACKSIZE];
                    17510   ; OS_STK Task4Stk[STACKSIZE];
                    17511   ; OS_STK Task5Stk[STACKSIZE];
                    17512   ; OS_EVENT *CANMutex;
                    17513   ; /* Prototypes for our tasks/threads*/
                    17514   ; void Task1(void *);	/* (void *) means the child task expects no data from parent*/
                    17515   ; void Task2(void *);
                    17516   ; void Task3(void *);
                    17517   ; void Task4(void *);
                    17518   ; void Task5(void *);
                    17519   ; void CanBus0_Transmit(
                    17520   ; unsigned int* TxData1, 
                    17521   ; unsigned int* TxData2, 
                    17522   ; unsigned int* TxData3, 
                    17523   ; unsigned int* TxData4,
                    17524   ; unsigned int* TxData5,
                    17525   ; unsigned int* TxData6,
                    17526   ; unsigned int* TxData7,
                    17527   ; unsigned int* TxData8);
                    17528   ; unsigned char I2C_ReadADCChannel(unsigned char adc_channel, unsigned char * adc_val);
                    17529   ; void ADC_DAC_TEST(void);
                    17530   ; void InitI2C(void);
                    17531   ; void CanBus1_Receive(
                    17532   ; unsigned int* RxData1, 
                    17533   ; unsigned int* RxData2, 
                    17534   ; unsigned int* RxData3, 
                    17535   ; unsigned int* RxData4,
                    17536   ; unsigned int* RxData5,
                    17537   ; unsigned int* RxData6,
                    17538   ; unsigned int* RxData7,
                    17539   ; unsigned int* RxData8);
                    17540   ; void Init_CanBus_Controller0(void);
                    17541   ; void Init_CanBus_Controller1(void);
                    17542   ; void CanBusTest(void);
                    17543   ; /* 
                    17544   ; ** Our main application which has to
                    17545   ; ** 1) Initialise any peripherals on the board, e.g. RS232 for hyperterminal + LCD
                    17546   ; ** 2) Call OSInit() to initialise the OS
                    17547   ; ** 3) Create our application task/threads
                    17548   ; ** 4) Call OSStart()
                    17549   ; */
                    17550   ; unsigned char Timer1Count, Timer2Count, Timer3Count, Timer4Count;
                    17551   ; unsigned char receied_data1, receied_data2, receied_data3, receied_data4, receied_data5, receied_data6, receied_data7, receied_data8;
                    17552   ; unsigned char adc_reading = 0xAAU;
                    17553   ; unsigned char light_reading = 0x0;
                    17554   ; unsigned char therm_reading = 0x0;
                    17555   ; unsigned char zero = 0x0;
                    17556   ; void main(void)
                    17557   ; {        
                    17558   _main:
00005BCE  2F0A      17559          move.l    A2,-(A7)
00005BD0  45F8 4476 17560          lea       _OSTaskCreate.L,A2
                    17561   ; // initialise board hardware by calling our routines from the BIOS.C source file
                    17562   ; Init_RS232();
00005BD4  4EB8 5A1C 17563          jsr       _Init_RS232
                    17564   ; InitI2C();
00005BD8  4EB9 0000 17565          jsr       _InitI2C
00005BDC  6436      
                    17566   ; Init_LCD();
00005BDE  4EB8 5AD4 17567          jsr       _Init_LCD
                    17568   ; //Init_CanBus_Controller0();
                    17569   ; //Init_CanBus_Controller1();
                    17570   ; /* display welcome message on LCD display */
                    17571   ; Oline0("Altera DE1/68K");
00005BE2  4879 0000 17572          pea       @part_b_1.L
00005BE6  71DE      
00005BE8  4EB8 5B4A 17573          jsr       _Oline0
00005BEC  584F      17574          addq.w    #4,A7
                    17575   ; Oline1("Micrium uC/OS-II RTOS");
00005BEE  4879 0000 17576          pea       @part_b_2.L
00005BF2  71EE      
00005BF4  4EB8 5B78 17577          jsr       _Oline1
00005BF8  584F      17578          addq.w    #4,A7
                    17579   ; OSInit();		// call to initialise the OS
00005BFA  4EB8 0D3E 17580          jsr       _OSInit
                    17581   ; CanBusTest();
00005BFE  4EB9 0000 17582          jsr       _CanBusTest
00005C02  624A      
                    17583   ; /* 
                    17584   ; ** Now create the 4 child tasks and pass them no data.
                    17585   ; ** the smaller the numerical priority value, the higher the task priority 
                    17586   ; */
                    17587   ; Timer1Count = Timer2Count = 0;
00005C04  4239 0800 17588          clr.b     _Timer2Count.L
00005C08  1AFC      
00005C0A  4239 0800 17589          clr.b     _Timer1Count.L
00005C0E  1AFA      
                    17590   ; OSTaskCreate(Task1, OS_NULL, &Task1Stk[STACKSIZE], 11);     
00005C10  4878 000B 17591          pea       11
00005C14  41F9 0800 17592          lea       _Task1Stk.L,A0
00005C18  10F6      
00005C1A  D0FC 0200 17593          add.w     #512,A0
00005C1E  2F08      17594          move.l    A0,-(A7)
00005C20  42A7      17595          clr.l     -(A7)
00005C22  4879 0000 17596          pea       _Task1.L
00005C26  5CAE      
00005C28  4E92      17597          jsr       (A2)
00005C2A  DEFC 0010 17598          add.w     #16,A7
                    17599   ; OSTaskCreate(Task2, OS_NULL, &Task2Stk[STACKSIZE], 12);     // lowest priority task
00005C2E  4878 000C 17600          pea       12
00005C32  41F9 0800 17601          lea       _Task2Stk.L,A0
00005C36  12F6      
00005C38  D0FC 0200 17602          add.w     #512,A0
00005C3C  2F08      17603          move.l    A0,-(A7)
00005C3E  42A7      17604          clr.l     -(A7)
00005C40  4879 0000 17605          pea       _Task2.L
00005C44  5D30      
00005C46  4E92      17606          jsr       (A2)
00005C48  DEFC 0010 17607          add.w     #16,A7
                    17608   ; OSTaskCreate(Task3, OS_NULL, &Task3Stk[STACKSIZE], 13);
00005C4C  4878 000D 17609          pea       13
00005C50  41F9 0800 17610          lea       _Task3Stk.L,A0
00005C54  14F6      
00005C56  D0FC 0200 17611          add.w     #512,A0
00005C5A  2F08      17612          move.l    A0,-(A7)
00005C5C  42A7      17613          clr.l     -(A7)
00005C5E  4879 0000 17614          pea       _Task3.L
00005C62  5DC2      
00005C64  4E92      17615          jsr       (A2)
00005C66  DEFC 0010 17616          add.w     #16,A7
                    17617   ; OSTaskCreate(Task4, OS_NULL, &Task4Stk[STACKSIZE], 14);
00005C6A  4878 000E 17618          pea       14
00005C6E  41F9 0800 17619          lea       _Task4Stk.L,A0
00005C72  16F6      
00005C74  D0FC 0200 17620          add.w     #512,A0
00005C78  2F08      17621          move.l    A0,-(A7)
00005C7A  42A7      17622          clr.l     -(A7)
00005C7C  4879 0000 17623          pea       _Task4.L
00005C80  5E54      
00005C82  4E92      17624          jsr       (A2)
00005C84  DEFC 0010 17625          add.w     #16,A7
                    17626   ; OSTaskCreate(Task5, OS_NULL, &Task5Stk[STACKSIZE], 15);
00005C88  4878 000F 17627          pea       15
00005C8C  41F9 0800 17628          lea       _Task5Stk.L,A0
00005C90  18F6      
00005C92  D0FC 0200 17629          add.w     #512,A0
00005C96  2F08      17630          move.l    A0,-(A7)
00005C98  42A7      17631          clr.l     -(A7)
00005C9A  4879 0000 17632          pea       _Task5.L
00005C9E  5EE4      
00005CA0  4E92      17633          jsr       (A2)
00005CA2  DEFC 0010 17634          add.w     #16,A7
                    17635   ; OSStart();  // call to start the OS scheduler, (never returns from this function)
00005CA6  4EB8 0EA6 17636          jsr       _OSStart
00005CAA  245F      17637          move.l    (A7)+,A2
00005CAC  4E75      17638          rts
                    17639   ; }
                    17640   ; /*
                    17641   ; ** IMPORTANT : Timer 1 interrupts must be started by the highest priority task 
                    17642   ; ** that runs first which is Task2
                    17643   ; */
                    17644   ; // Transmit & receive slider switches values
                    17645   ; void Task1(void *pdata)
                    17646   ; {
                    17647   _Task1:
00005CAE  4E56 FFFC 17648          link      A6,#-4
00005CB2  2F0A      17649          move.l    A2,-(A7)
00005CB4  45F9 0800 17650          lea       _zero.L,A2
00005CB8  0006      
                    17651   ; INT8U err;
                    17652   ; Timer1_Init();
00005CBA  4EB8 5BBC 17653          jsr       _Timer1_Init
                    17654   ; for (;;) {
                    17655   Task1_1:
                    17656   ; // PortA = Timer2Count++;
                    17657   ; // suspect that the if the LED is not assigned, LED will display the value of the slider
                    17658   ; // from "analog.asm"
                    17659   ; OSMutexPend(CANMutex, 0, &err);
00005CBE  486E FFFF 17660          pea       -1(A6)
00005CC2  42A7      17661          clr.l     -(A7)
00005CC4  2F39 0800 17662          move.l    _CANMutex.L,-(A7)
00005CC8  1AF6      
00005CCA  4EB8 2F7A 17663          jsr       _OSMutexPend
00005CCE  DEFC 000C 17664          add.w     #12,A7
                    17665   ; CanBus0_Transmit(&adc_reading, &light_reading, &therm_reading, &PortA, &zero, &zero, &zero, &zero);
00005CD2  2F0A      17666          move.l    A2,-(A7)
00005CD4  2F0A      17667          move.l    A2,-(A7)
00005CD6  2F0A      17668          move.l    A2,-(A7)
00005CD8  2F0A      17669          move.l    A2,-(A7)
00005CDA  4879 0040 17670          pea       4194304
00005CDE  0000      
00005CE0  4879 0800 17671          pea       _therm_reading.L
00005CE4  0004      
00005CE6  4879 0800 17672          pea       _light_reading.L
00005CEA  0002      
00005CEC  4879 0800 17673          pea       _adc_reading.L
00005CF0  0000      
00005CF2  4EB9 0000 17674          jsr       _CanBus0_Transmit
00005CF6  60D0      
00005CF8  DEFC 0020 17675          add.w     #32,A7
                    17676   ; OSMutexPost(CANMutex);
00005CFC  2F39 0800 17677          move.l    _CANMutex.L,-(A7)
00005D00  1AF6      
00005D02  4EB8 325C 17678          jsr       _OSMutexPost
00005D06  584F      17679          addq.w    #4,A7
                    17680   ; printf("Slider switchs: %02X\n", PortA);   // checking if port C is the slider switch
00005D08  1239 0040 17681          move.b    4194304,D1
00005D0C  0000      
00005D0E  C2BC 0000 17682          and.l     #255,D1
00005D12  00FF      
00005D14  2F01      17683          move.l    D1,-(A7)
00005D16  4879 0000 17684          pea       @part_b_3.L
00005D1A  7204      
00005D1C  4EB9 0000 17685          jsr       _printf
00005D20  67BE      
00005D22  504F      17686          addq.w    #8,A7
                    17687   ; OSTimeDly(10);
00005D24  4878 000A 17688          pea       10
00005D28  4EB8 4DD6 17689          jsr       _OSTimeDly
00005D2C  584F      17690          addq.w    #4,A7
00005D2E  608E      17691          bra       Task1_1
                    17692   ; }
                    17693   ; }
                    17694   ; /*
                    17695   ; ** Task 2 below was created with the highest priority so it must start timer1
                    17696   ; ** so that it produces interrupts for the 100hz context switches
                    17697   ; */
                    17698   ; // Transmit & receive ADC reading 
                    17699   ; void Task2(void *pdata)
                    17700   ; {
                    17701   _Task2:
00005D30  4E56 FFFC 17702          link      A6,#-4
00005D34  2F0A      17703          move.l    A2,-(A7)
00005D36  45F9 0800 17704          lea       _zero.L,A2
00005D3A  0006      
                    17705   ; // unsigned char received_reading = 0x0;
                    17706   ; // ADC value at Ch1. ??
                    17707   ; INT8U err;
                    17708   ; for (;;) {
                    17709   Task2_1:
                    17710   ; // read and transmit ADC value to CAN bus
                    17711   ; I2C_ReadADCChannel(1, &adc_reading);
00005D3C  4879 0800 17712          pea       _adc_reading.L
00005D40  0000      
00005D42  4878 0001 17713          pea       1
00005D46  4EB9 0000 17714          jsr       _I2C_ReadADCChannel
00005D4A  657C      
00005D4C  504F      17715          addq.w    #8,A7
                    17716   ; // transimit the ADC reading to CAN bus using can0
                    17717   ; OSMutexPend(CANMutex, 0, &err);
00005D4E  486E FFFF 17718          pea       -1(A6)
00005D52  42A7      17719          clr.l     -(A7)
00005D54  2F39 0800 17720          move.l    _CANMutex.L,-(A7)
00005D58  1AF6      
00005D5A  4EB8 2F7A 17721          jsr       _OSMutexPend
00005D5E  DEFC 000C 17722          add.w     #12,A7
                    17723   ; CanBus0_Transmit(&adc_reading, &light_reading, &therm_reading, &PortA, &zero, &zero, &zero, &zero);
00005D62  2F0A      17724          move.l    A2,-(A7)
00005D64  2F0A      17725          move.l    A2,-(A7)
00005D66  2F0A      17726          move.l    A2,-(A7)
00005D68  2F0A      17727          move.l    A2,-(A7)
00005D6A  4879 0040 17728          pea       4194304
00005D6E  0000      
00005D70  4879 0800 17729          pea       _therm_reading.L
00005D74  0004      
00005D76  4879 0800 17730          pea       _light_reading.L
00005D7A  0002      
00005D7C  4879 0800 17731          pea       _adc_reading.L
00005D80  0000      
00005D82  4EB9 0000 17732          jsr       _CanBus0_Transmit
00005D86  60D0      
00005D88  DEFC 0020 17733          add.w     #32,A7
                    17734   ; OSMutexPost(CANMutex);
00005D8C  2F39 0800 17735          move.l    _CANMutex.L,-(A7)
00005D90  1AF6      
00005D92  4EB8 325C 17736          jsr       _OSMutexPost
00005D96  584F      17737          addq.w    #4,A7
                    17738   ; printf("    ADC reading:    %d\n", adc_reading);
00005D98  1239 0800 17739          move.b    _adc_reading.L,D1
00005D9C  0000      
00005D9E  C2BC 0000 17740          and.l     #255,D1
00005DA2  00FF      
00005DA4  2F01      17741          move.l    D1,-(A7)
00005DA6  4879 0000 17742          pea       @part_b_4.L
00005DAA  721A      
00005DAC  4EB9 0000 17743          jsr       _printf
00005DB0  67BE      
00005DB2  504F      17744          addq.w    #8,A7
                    17745   ; // receive the ADC reading from CAN bus using can1
                    17746   ; // CanBus1_Receive(&received_reading, &zero, &zero, &zero, &zero, &zero, &zero, &zero);
                    17747   ; OSTimeDly(20); //wait for 200ms
00005DB4  4878 0014 17748          pea       20
00005DB8  4EB8 4DD6 17749          jsr       _OSTimeDly
00005DBC  584F      17750          addq.w    #4,A7
00005DBE  6000 FF7C 17751          bra       Task2_1
                    17752   ; }
                    17753   ; }
                    17754   ; // Transmit & receive light sensor reading 
                    17755   ; void Task3(void *pdata)
                    17756   ; {
                    17757   _Task3:
00005DC2  4E56 FFFC 17758          link      A6,#-4
00005DC6  2F0A      17759          move.l    A2,-(A7)
00005DC8  45F9 0800 17760          lea       _zero.L,A2
00005DCC  0006      
                    17761   ; INT8U err;
                    17762   ; // unsigned char received_reading = 0x0;
                    17763   ; // light sensor value at Ch0. ??
                    17764   ; for (;;) {
                    17765   Task3_1:
                    17766   ; // read and transmit ADC value to CAN bus
                    17767   ; I2C_ReadADCChannel(2, &light_reading);
00005DCE  4879 0800 17768          pea       _light_reading.L
00005DD2  0002      
00005DD4  4878 0002 17769          pea       2
00005DD8  4EB9 0000 17770          jsr       _I2C_ReadADCChannel
00005DDC  657C      
00005DDE  504F      17771          addq.w    #8,A7
                    17772   ; // transimit the ADC reading to CAN bus using can0
                    17773   ; OSMutexPend(CANMutex, 0, &err);
00005DE0  486E FFFF 17774          pea       -1(A6)
00005DE4  42A7      17775          clr.l     -(A7)
00005DE6  2F39 0800 17776          move.l    _CANMutex.L,-(A7)
00005DEA  1AF6      
00005DEC  4EB8 2F7A 17777          jsr       _OSMutexPend
00005DF0  DEFC 000C 17778          add.w     #12,A7
                    17779   ; CanBus0_Transmit(&adc_reading, &light_reading, &therm_reading, &PortA, &zero, &zero, &zero, &zero);
00005DF4  2F0A      17780          move.l    A2,-(A7)
00005DF6  2F0A      17781          move.l    A2,-(A7)
00005DF8  2F0A      17782          move.l    A2,-(A7)
00005DFA  2F0A      17783          move.l    A2,-(A7)
00005DFC  4879 0040 17784          pea       4194304
00005E00  0000      
00005E02  4879 0800 17785          pea       _therm_reading.L
00005E06  0004      
00005E08  4879 0800 17786          pea       _light_reading.L
00005E0C  0002      
00005E0E  4879 0800 17787          pea       _adc_reading.L
00005E12  0000      
00005E14  4EB9 0000 17788          jsr       _CanBus0_Transmit
00005E18  60D0      
00005E1A  DEFC 0020 17789          add.w     #32,A7
                    17790   ; OSMutexPost(CANMutex);
00005E1E  2F39 0800 17791          move.l    _CANMutex.L,-(A7)
00005E22  1AF6      
00005E24  4EB8 325C 17792          jsr       _OSMutexPost
00005E28  584F      17793          addq.w    #4,A7
                    17794   ; // receive the ADC reading from CAN bus using can1
                    17795   ; // CanBus1_Receive(&received_reading, &zero, &zero, &zero, &zero, &zero, &zero, &zero);
                    17796   ; printf("        light sensor reading:   %d\n", light_reading);
00005E2A  1239 0800 17797          move.b    _light_reading.L,D1
00005E2E  0002      
00005E30  C2BC 0000 17798          and.l     #255,D1
00005E34  00FF      
00005E36  2F01      17799          move.l    D1,-(A7)
00005E38  4879 0000 17800          pea       @part_b_5.L
00005E3C  7232      
00005E3E  4EB9 0000 17801          jsr       _printf
00005E42  67BE      
00005E44  504F      17802          addq.w    #8,A7
                    17803   ; OSTimeDly(50); //wait for 500ms
00005E46  4878 0032 17804          pea       50
00005E4A  4EB8 4DD6 17805          jsr       _OSTimeDly
00005E4E  584F      17806          addq.w    #4,A7
00005E50  6000 FF7C 17807          bra       Task3_1
                    17808   ; }
                    17809   ; }
                    17810   ; void Task4(void *pdata)
                    17811   ; {
                    17812   _Task4:
00005E54  4E56 FFFC 17813          link      A6,#-4
00005E58  2F0A      17814          move.l    A2,-(A7)
00005E5A  45F9 0800 17815          lea       _zero.L,A2
00005E5E  0006      
                    17816   ; INT8U err;
                    17817   ; // unsigned char received_reading = 0x0;
                    17818   ; // Thermister value at Ch2. ??
                    17819   ; for (;;) {
                    17820   Task4_1:
                    17821   ; // read and transmit ADC value to CAN bus
                    17822   ; I2C_ReadADCChannel(0, &therm_reading);
00005E60  4879 0800 17823          pea       _therm_reading.L
00005E64  0004      
00005E66  42A7      17824          clr.l     -(A7)
00005E68  4EB9 0000 17825          jsr       _I2C_ReadADCChannel
00005E6C  657C      
00005E6E  504F      17826          addq.w    #8,A7
                    17827   ; // transimit the ADC reading to CAN bus using can0
                    17828   ; OSMutexPend(CANMutex, 0, &err);
00005E70  486E FFFF 17829          pea       -1(A6)
00005E74  42A7      17830          clr.l     -(A7)
00005E76  2F39 0800 17831          move.l    _CANMutex.L,-(A7)
00005E7A  1AF6      
00005E7C  4EB8 2F7A 17832          jsr       _OSMutexPend
00005E80  DEFC 000C 17833          add.w     #12,A7
                    17834   ; CanBus0_Transmit(&adc_reading, &light_reading, &therm_reading, &PortA, &zero, &zero, &zero, &zero);
00005E84  2F0A      17835          move.l    A2,-(A7)
00005E86  2F0A      17836          move.l    A2,-(A7)
00005E88  2F0A      17837          move.l    A2,-(A7)
00005E8A  2F0A      17838          move.l    A2,-(A7)
00005E8C  4879 0040 17839          pea       4194304
00005E90  0000      
00005E92  4879 0800 17840          pea       _therm_reading.L
00005E96  0004      
00005E98  4879 0800 17841          pea       _light_reading.L
00005E9C  0002      
00005E9E  4879 0800 17842          pea       _adc_reading.L
00005EA2  0000      
00005EA4  4EB9 0000 17843          jsr       _CanBus0_Transmit
00005EA8  60D0      
00005EAA  DEFC 0020 17844          add.w     #32,A7
                    17845   ; OSMutexPost(CANMutex);
00005EAE  2F39 0800 17846          move.l    _CANMutex.L,-(A7)
00005EB2  1AF6      
00005EB4  4EB8 325C 17847          jsr       _OSMutexPost
00005EB8  584F      17848          addq.w    #4,A7
                    17849   ; // receive the ADC reading from CAN bus using can1
                    17850   ; // CanBus1_Receive(&received_reading, &zero, &zero, &zero, &zero, &zero, &zero, &zero);
                    17851   ; printf("            Thermister reading:     %d\n", therm_reading);
00005EBA  1239 0800 17852          move.b    _therm_reading.L,D1
00005EBE  0004      
00005EC0  C2BC 0000 17853          and.l     #255,D1
00005EC4  00FF      
00005EC6  2F01      17854          move.l    D1,-(A7)
00005EC8  4879 0000 17855          pea       @part_b_6.L
00005ECC  7256      
00005ECE  4EB9 0000 17856          jsr       _printf
00005ED2  67BE      
00005ED4  504F      17857          addq.w    #8,A7
                    17858   ; OSTimeDly(200); //wait for 2s
00005ED6  4878 00C8 17859          pea       200
00005EDA  4EB8 4DD6 17860          jsr       _OSTimeDly
00005EDE  584F      17861          addq.w    #4,A7
00005EE0  6000 FF7E 17862          bra       Task4_1
                    17863   ; }
                    17864   ; }
                    17865   ; void Task5(void *pdata)
                    17866   ; {
                    17867   _Task5:
00005EE4  4E56 FFFC 17868          link      A6,#-4
                    17869   ; INT8U err; 
                    17870   ; for(;;){
                    17871   Task5_1:
                    17872   ; OSMutexPend(CANMutex, 0, &err);
00005EE8  486E FFFF 17873          pea       -1(A6)
00005EEC  42A7      17874          clr.l     -(A7)
00005EEE  2F39 0800 17875          move.l    _CANMutex.L,-(A7)
00005EF2  1AF6      
00005EF4  4EB8 2F7A 17876          jsr       _OSMutexPend
00005EF8  DEFC 000C 17877          add.w     #12,A7
                    17878   ; CanBus1_Receive(&receied_data1, &receied_data2, &receied_data3, &receied_data4, &receied_data5, &receied_data6, &receied_data7, &receied_data8);
00005EFC  4879 0800 17879          pea       _receied_data8.L
00005F00  1B10      
00005F02  4879 0800 17880          pea       _receied_data7.L
00005F06  1B0E      
00005F08  4879 0800 17881          pea       _receied_data6.L
00005F0C  1B0C      
00005F0E  4879 0800 17882          pea       _receied_data5.L
00005F12  1B0A      
00005F14  4879 0800 17883          pea       _receied_data4.L
00005F18  1B08      
00005F1A  4879 0800 17884          pea       _receied_data3.L
00005F1E  1B06      
00005F20  4879 0800 17885          pea       _receied_data2.L
00005F24  1B04      
00005F26  4879 0800 17886          pea       _receied_data1.L
00005F2A  1B02      
00005F2C  4EB9 0000 17887          jsr       _CanBus1_Receive
00005F30  61FC      
00005F32  DEFC 0020 17888          add.w     #32,A7
                    17889   ; printf("ADC: %d, light sensor: %d, \nthermister: %d, slider: %d\n", receied_data1, receied_data2, receied_data3, receied_data4);
00005F36  1239 0800 17890          move.b    _receied_data4.L,D1
00005F3A  1B08      
00005F3C  C2BC 0000 17891          and.l     #255,D1
00005F40  00FF      
00005F42  2F01      17892          move.l    D1,-(A7)
00005F44  1239 0800 17893          move.b    _receied_data3.L,D1
00005F48  1B06      
00005F4A  C2BC 0000 17894          and.l     #255,D1
00005F4E  00FF      
00005F50  2F01      17895          move.l    D1,-(A7)
00005F52  1239 0800 17896          move.b    _receied_data2.L,D1
00005F56  1B04      
00005F58  C2BC 0000 17897          and.l     #255,D1
00005F5C  00FF      
00005F5E  2F01      17898          move.l    D1,-(A7)
00005F60  1239 0800 17899          move.b    _receied_data1.L,D1
00005F64  1B02      
00005F66  C2BC 0000 17900          and.l     #255,D1
00005F6A  00FF      
00005F6C  2F01      17901          move.l    D1,-(A7)
00005F6E  4879 0000 17902          pea       @part_b_7.L
00005F72  727E      
00005F74  4EB9 0000 17903          jsr       _printf
00005F78  67BE      
00005F7A  DEFC 0014 17904          add.w     #20,A7
                    17905   ; OSMutexPost(CANMutex);
00005F7E  2F39 0800 17906          move.l    _CANMutex.L,-(A7)
00005F82  1AF6      
00005F84  4EB8 325C 17907          jsr       _OSMutexPost
00005F88  584F      17908          addq.w    #4,A7
                    17909   ; OSTimeDly(5); // get reading every second, might need mutex
00005F8A  4878 0005 17910          pea       5
00005F8E  4EB8 4DD6 17911          jsr       _OSTimeDly
00005F92  584F      17912          addq.w    #4,A7
00005F94  6000 FF52 17913          bra       Task5_1
                    17914   ; }
                    17915   ; }
                    17916   ; C:\M68KV6.0 - 800BY480\ASSIGNMENT6\PARTB_PROJ\CANBUS_CONTROLLER_ROUTINES.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    17917   ; #include <stdio.h>
                    17918   ; #include <stdlib.h>
                    17919   ; /*********************************************************************************************
                    17920   ; ** These addresses and definitions were taken from Appendix 7 of the Can Controller
                    17921   ; ** application note and adapted for the 68k assignment
                    17922   ; *********************************************************************************************/
                    17923   ; /*
                    17924   ; ** definition for the SJA1000 registers and bits based on 68k address map areas
                    17925   ; ** assume the addresses for the 2 can controllers given in the assignment
                    17926   ; **
                    17927   ; ** Registers are defined in terms of the following Macro for each Can controller,
                    17928   ; ** where (i) represents an registers number
                    17929   ; */
                    17930   ; #define CAN0_CONTROLLER(i) (*(volatile unsigned char *)(0x00500000 + (i << 1)))
                    17931   ; #define CAN1_CONTROLLER(i) (*(volatile unsigned char *)(0x00500200 + (i << 1)))
                    17932   ; /* Can 0 register definitions */
                    17933   ; #define Can0_ModeControlReg      CAN0_CONTROLLER(0)
                    17934   ; #define Can0_CommandReg          CAN0_CONTROLLER(1)
                    17935   ; #define Can0_StatusReg           CAN0_CONTROLLER(2)
                    17936   ; #define Can0_InterruptReg        CAN0_CONTROLLER(3)
                    17937   ; #define Can0_InterruptEnReg      CAN0_CONTROLLER(4) /* PeliCAN mode */
                    17938   ; #define Can0_BusTiming0Reg       CAN0_CONTROLLER(6)
                    17939   ; #define Can0_BusTiming1Reg       CAN0_CONTROLLER(7)
                    17940   ; #define Can0_OutControlReg       CAN0_CONTROLLER(8)
                    17941   ; /* address definitions of Other Registers */
                    17942   ; #define Can0_ArbLostCapReg       CAN0_CONTROLLER(11)
                    17943   ; #define Can0_ErrCodeCapReg       CAN0_CONTROLLER(12)
                    17944   ; #define Can0_ErrWarnLimitReg     CAN0_CONTROLLER(13)
                    17945   ; #define Can0_RxErrCountReg       CAN0_CONTROLLER(14)
                    17946   ; #define Can0_TxErrCountReg       CAN0_CONTROLLER(15)
                    17947   ; #define Can0_RxMsgCountReg       CAN0_CONTROLLER(29)
                    17948   ; #define Can0_RxBufStartAdr       CAN0_CONTROLLER(30)
                    17949   ; #define Can0_ClockDivideReg      CAN0_CONTROLLER(31)
                    17950   ; /* address definitions of Acceptance Code & Mask Registers - RESET MODE */
                    17951   ; #define Can0_AcceptCode0Reg      CAN0_CONTROLLER(16)
                    17952   ; #define Can0_AcceptCode1Reg      CAN0_CONTROLLER(17)
                    17953   ; #define Can0_AcceptCode2Reg      CAN0_CONTROLLER(18)
                    17954   ; #define Can0_AcceptCode3Reg      CAN0_CONTROLLER(19)
                    17955   ; #define Can0_AcceptMask0Reg      CAN0_CONTROLLER(20)
                    17956   ; #define Can0_AcceptMask1Reg      CAN0_CONTROLLER(21)
                    17957   ; #define Can0_AcceptMask2Reg      CAN0_CONTROLLER(22)
                    17958   ; #define Can0_AcceptMask3Reg      CAN0_CONTROLLER(23)
                    17959   ; /* address definitions Rx Buffer - OPERATING MODE - Read only register*/
                    17960   ; #define Can0_RxFrameInfo         CAN0_CONTROLLER(16)
                    17961   ; #define Can0_RxBuffer1           CAN0_CONTROLLER(17)
                    17962   ; #define Can0_RxBuffer2           CAN0_CONTROLLER(18)
                    17963   ; #define Can0_RxBuffer3           CAN0_CONTROLLER(19)
                    17964   ; #define Can0_RxBuffer4           CAN0_CONTROLLER(20)
                    17965   ; #define Can0_RxBuffer5           CAN0_CONTROLLER(21)
                    17966   ; #define Can0_RxBuffer6           CAN0_CONTROLLER(22)
                    17967   ; #define Can0_RxBuffer7           CAN0_CONTROLLER(23)
                    17968   ; #define Can0_RxBuffer8           CAN0_CONTROLLER(24)
                    17969   ; #define Can0_RxBuffer9           CAN0_CONTROLLER(25)
                    17970   ; #define Can0_RxBuffer10          CAN0_CONTROLLER(26)
                    17971   ; #define Can0_RxBuffer11          CAN0_CONTROLLER(27)
                    17972   ; #define Can0_RxBuffer12          CAN0_CONTROLLER(28)
                    17973   ; /* address definitions of the Tx-Buffer - OPERATING MODE - Write only register */
                    17974   ; #define Can0_TxFrameInfo         CAN0_CONTROLLER(16)
                    17975   ; #define Can0_TxBuffer1           CAN0_CONTROLLER(17)
                    17976   ; #define Can0_TxBuffer2           CAN0_CONTROLLER(18)
                    17977   ; #define Can0_TxBuffer3           CAN0_CONTROLLER(19)
                    17978   ; #define Can0_TxBuffer4           CAN0_CONTROLLER(20)
                    17979   ; #define Can0_TxBuffer5           CAN0_CONTROLLER(21)
                    17980   ; #define Can0_TxBuffer6           CAN0_CONTROLLER(22)
                    17981   ; #define Can0_TxBuffer7           CAN0_CONTROLLER(23)
                    17982   ; #define Can0_TxBuffer8           CAN0_CONTROLLER(24)
                    17983   ; #define Can0_TxBuffer9           CAN0_CONTROLLER(25)
                    17984   ; #define Can0_TxBuffer10          CAN0_CONTROLLER(26)
                    17985   ; #define Can0_TxBuffer11          CAN0_CONTROLLER(27)
                    17986   ; #define Can0_TxBuffer12          CAN0_CONTROLLER(28)
                    17987   ; /* read only addresses */
                    17988   ; #define Can0_TxFrameInfoRd       CAN0_CONTROLLER(96)
                    17989   ; #define Can0_TxBufferRd1         CAN0_CONTROLLER(97)
                    17990   ; #define Can0_TxBufferRd2         CAN0_CONTROLLER(98)
                    17991   ; #define Can0_TxBufferRd3         CAN0_CONTROLLER(99)
                    17992   ; #define Can0_TxBufferRd4         CAN0_CONTROLLER(100)
                    17993   ; #define Can0_TxBufferRd5         CAN0_CONTROLLER(101)
                    17994   ; #define Can0_TxBufferRd6         CAN0_CONTROLLER(102)
                    17995   ; #define Can0_TxBufferRd7         CAN0_CONTROLLER(103)
                    17996   ; #define Can0_TxBufferRd8         CAN0_CONTROLLER(104)
                    17997   ; #define Can0_TxBufferRd9         CAN0_CONTROLLER(105)
                    17998   ; #define Can0_TxBufferRd10        CAN0_CONTROLLER(106)
                    17999   ; #define Can0_TxBufferRd11        CAN0_CONTROLLER(107)
                    18000   ; #define Can0_TxBufferRd12        CAN0_CONTROLLER(108)
                    18001   ; /* CAN1 Controller register definitions */
                    18002   ; #define Can1_ModeControlReg      CAN1_CONTROLLER(0)
                    18003   ; #define Can1_CommandReg          CAN1_CONTROLLER(1)
                    18004   ; #define Can1_StatusReg           CAN1_CONTROLLER(2)
                    18005   ; #define Can1_InterruptReg        CAN1_CONTROLLER(3)
                    18006   ; #define Can1_InterruptEnReg      CAN1_CONTROLLER(4) /* PeliCAN mode */
                    18007   ; #define Can1_BusTiming0Reg       CAN1_CONTROLLER(6)
                    18008   ; #define Can1_BusTiming1Reg       CAN1_CONTROLLER(7)
                    18009   ; #define Can1_OutControlReg       CAN1_CONTROLLER(8)
                    18010   ; /* address definitions of Other Registers */
                    18011   ; #define Can1_ArbLostCapReg       CAN1_CONTROLLER(11)
                    18012   ; #define Can1_ErrCodeCapReg       CAN1_CONTROLLER(12)
                    18013   ; #define Can1_ErrWarnLimitReg     CAN1_CONTROLLER(13)
                    18014   ; #define Can1_RxErrCountReg       CAN1_CONTROLLER(14)
                    18015   ; #define Can1_TxErrCountReg       CAN1_CONTROLLER(15)
                    18016   ; #define Can1_RxMsgCountReg       CAN1_CONTROLLER(29)
                    18017   ; #define Can1_RxBufStartAdr       CAN1_CONTROLLER(30)
                    18018   ; #define Can1_ClockDivideReg      CAN1_CONTROLLER(31)
                    18019   ; /* address definitions of Acceptance Code & Mask Registers - RESET MODE */
                    18020   ; #define Can1_AcceptCode0Reg      CAN1_CONTROLLER(16)
                    18021   ; #define Can1_AcceptCode1Reg      CAN1_CONTROLLER(17)
                    18022   ; #define Can1_AcceptCode2Reg      CAN1_CONTROLLER(18)
                    18023   ; #define Can1_AcceptCode3Reg      CAN1_CONTROLLER(19)
                    18024   ; #define Can1_AcceptMask0Reg      CAN1_CONTROLLER(20)
                    18025   ; #define Can1_AcceptMask1Reg      CAN1_CONTROLLER(21)
                    18026   ; #define Can1_AcceptMask2Reg      CAN1_CONTROLLER(22)
                    18027   ; #define Can1_AcceptMask3Reg      CAN1_CONTROLLER(23)
                    18028   ; /* address definitions Rx Buffer - OPERATING MODE - Read only register*/
                    18029   ; #define Can1_RxFrameInfo         CAN1_CONTROLLER(16)
                    18030   ; #define Can1_RxBuffer1           CAN1_CONTROLLER(17)
                    18031   ; #define Can1_RxBuffer2           CAN1_CONTROLLER(18)
                    18032   ; #define Can1_RxBuffer3           CAN1_CONTROLLER(19)
                    18033   ; #define Can1_RxBuffer4           CAN1_CONTROLLER(20)
                    18034   ; #define Can1_RxBuffer5           CAN1_CONTROLLER(21)
                    18035   ; #define Can1_RxBuffer6           CAN1_CONTROLLER(22)
                    18036   ; #define Can1_RxBuffer7           CAN1_CONTROLLER(23)
                    18037   ; #define Can1_RxBuffer8           CAN1_CONTROLLER(24)
                    18038   ; #define Can1_RxBuffer9           CAN1_CONTROLLER(25)
                    18039   ; #define Can1_RxBuffer10          CAN1_CONTROLLER(26)
                    18040   ; #define Can1_RxBuffer11          CAN1_CONTROLLER(27)
                    18041   ; #define Can1_RxBuffer12          CAN1_CONTROLLER(28)
                    18042   ; /* address definitions of the Tx-Buffer - OPERATING MODE - Write only register */
                    18043   ; #define Can1_TxFrameInfo         CAN1_CONTROLLER(16)
                    18044   ; #define Can1_TxBuffer1           CAN1_CONTROLLER(17)
                    18045   ; #define Can1_TxBuffer2           CAN1_CONTROLLER(18)
                    18046   ; #define Can1_TxBuffer3           CAN1_CONTROLLER(19)
                    18047   ; #define Can1_TxBuffer4           CAN1_CONTROLLER(20)
                    18048   ; #define Can1_TxBuffer5           CAN1_CONTROLLER(21)
                    18049   ; #define Can1_TxBuffer6           CAN1_CONTROLLER(22)
                    18050   ; #define Can1_TxBuffer7           CAN1_CONTROLLER(23)
                    18051   ; #define Can1_TxBuffer8           CAN1_CONTROLLER(24)
                    18052   ; #define Can1_TxBuffer9           CAN1_CONTROLLER(25)
                    18053   ; #define Can1_TxBuffer10          CAN1_CONTROLLER(26)
                    18054   ; #define Can1_TxBuffer11          CAN1_CONTROLLER(27)
                    18055   ; #define Can1_TxBuffer12          CAN1_CONTROLLER(28)
                    18056   ; /* read only addresses */
                    18057   ; #define Can1_TxFrameInfoRd       CAN1_CONTROLLER(96)
                    18058   ; #define Can1_TxBufferRd1         CAN1_CONTROLLER(97)
                    18059   ; #define Can1_TxBufferRd2         CAN1_CONTROLLER(98)
                    18060   ; #define Can1_TxBufferRd3         CAN1_CONTROLLER(99)
                    18061   ; #define Can1_TxBufferRd4         CAN1_CONTROLLER(100)
                    18062   ; #define Can1_TxBufferRd5         CAN1_CONTROLLER(101)
                    18063   ; #define Can1_TxBufferRd6         CAN1_CONTROLLER(102)
                    18064   ; #define Can1_TxBufferRd7         CAN1_CONTROLLER(103)
                    18065   ; #define Can1_TxBufferRd8         CAN1_CONTROLLER(104)
                    18066   ; #define Can1_TxBufferRd9         CAN1_CONTROLLER(105)
                    18067   ; #define Can1_TxBufferRd10        CAN1_CONTROLLER(106)
                    18068   ; #define Can1_TxBufferRd11        CAN1_CONTROLLER(107)
                    18069   ; #define Can1_TxBufferRd12        CAN1_CONTROLLER(108)
                    18070   ; /* bit definitions for the Mode & Control Register */
                    18071   ; #define RM_RR_Bit 0x01 /* reset mode (request) bit */
                    18072   ; #define LOM_Bit 0x02 /* listen only mode bit */
                    18073   ; #define STM_Bit 0x04 /* self test mode bit */
                    18074   ; #define AFM_Bit 0x08 /* acceptance filter mode bit */
                    18075   ; #define SM_Bit  0x10 /* enter sleep mode bit */
                    18076   ; /* bit definitions for the Interrupt Enable & Control Register */
                    18077   ; #define RIE_Bit 0x01 /* receive interrupt enable bit */
                    18078   ; #define TIE_Bit 0x02 /* transmit interrupt enable bit */
                    18079   ; #define EIE_Bit 0x04 /* error warning interrupt enable bit */
                    18080   ; #define DOIE_Bit 0x08 /* data overrun interrupt enable bit */
                    18081   ; #define WUIE_Bit 0x10 /* wake-up interrupt enable bit */
                    18082   ; #define EPIE_Bit 0x20 /* error passive interrupt enable bit */
                    18083   ; #define ALIE_Bit 0x40 /* arbitration lost interr. enable bit*/
                    18084   ; #define BEIE_Bit 0x80 /* bus error interrupt enable bit */
                    18085   ; /* bit definitions for the Command Register */
                    18086   ; #define TR_Bit 0x01 /* transmission request bit */
                    18087   ; #define AT_Bit 0x02 /* abort transmission bit */
                    18088   ; #define RRB_Bit 0x04 /* release receive buffer bit */
                    18089   ; #define CDO_Bit 0x08 /* clear data overrun bit */
                    18090   ; #define SRR_Bit 0x10 /* self reception request bit */
                    18091   ; /* bit definitions for the Status Register */
                    18092   ; #define RBS_Bit 0x01 /* receive buffer status bit */
                    18093   ; #define DOS_Bit 0x02 /* data overrun status bit */
                    18094   ; #define TBS_Bit 0x04 /* transmit buffer status bit */
                    18095   ; #define TCS_Bit 0x08 /* transmission complete status bit */
                    18096   ; #define RS_Bit 0x10 /* receive status bit */
                    18097   ; #define TS_Bit 0x20 /* transmit status bit */
                    18098   ; #define ES_Bit 0x40 /* error status bit */
                    18099   ; #define BS_Bit 0x80 /* bus status bit */
                    18100   ; /* bit definitions for the Interrupt Register */
                    18101   ; #define RI_Bit 0x01 /* receive interrupt bit */
                    18102   ; #define TI_Bit 0x02 /* transmit interrupt bit */
                    18103   ; #define EI_Bit 0x04 /* error warning interrupt bit */
                    18104   ; #define DOI_Bit 0x08 /* data overrun interrupt bit */
                    18105   ; #define WUI_Bit 0x10 /* wake-up interrupt bit */
                    18106   ; #define EPI_Bit 0x20 /* error passive interrupt bit */
                    18107   ; #define ALI_Bit 0x40 /* arbitration lost interrupt bit */
                    18108   ; #define BEI_Bit 0x80 /* bus error interrupt bit */
                    18109   ; /* bit definitions for the Bus Timing Registers */
                    18110   ; #define SAM_Bit 0x80                        /* sample mode bit 1 == the bus is sampled 3 times, 0 == the bus is sampled once */
                    18111   ; /* bit definitions for the Output Control Register OCMODE1, OCMODE0 */
                    18112   ; #define BiPhaseMode 0x00 /* bi-phase output mode */
                    18113   ; #define NormalMode 0x02 /* normal output mode */
                    18114   ; #define ClkOutMode 0x03 /* clock output mode */
                    18115   ; /* output pin configuration for TX1 */
                    18116   ; #define OCPOL1_Bit 0x20 /* output polarity control bit */
                    18117   ; #define Tx1Float 0x00 /* configured as float */
                    18118   ; #define Tx1PullDn 0x40 /* configured as pull-down */
                    18119   ; #define Tx1PullUp 0x80 /* configured as pull-up */
                    18120   ; #define Tx1PshPull 0xC0 /* configured as push/pull */
                    18121   ; /* output pin configuration for TX0 */
                    18122   ; #define OCPOL0_Bit 0x04 /* output polarity control bit */
                    18123   ; #define Tx0Float 0x00 /* configured as float */
                    18124   ; #define Tx0PullDn 0x08 /* configured as pull-down */
                    18125   ; #define Tx0PullUp 0x10 /* configured as pull-up */
                    18126   ; #define Tx0PshPull 0x18 /* configured as push/pull */
                    18127   ; /* bit definitions for the Clock Divider Register */
                    18128   ; #define DivBy1 0x07 /* CLKOUT = oscillator frequency */
                    18129   ; #define DivBy2 0x00 /* CLKOUT = 1/2 oscillator frequency */
                    18130   ; #define ClkOff_Bit 0x08 /* clock off bit, control of the CLK OUT pin */
                    18131   ; #define RXINTEN_Bit 0x20 /* pin TX1 used for receive interrupt */
                    18132   ; #define CBP_Bit 0x40 /* CAN comparator bypass control bit */
                    18133   ; #define CANMode_Bit 0x80 /* CAN mode definition bit */
                    18134   ; /*- definition of used constants ---------------------------------------*/
                    18135   ; #define YES 1
                    18136   ; #define NO 0
                    18137   ; #define ENABLE 1
                    18138   ; #define DISABLE 0
                    18139   ; #define ENABLE_N 0
                    18140   ; #define DISABLE_N 1
                    18141   ; #define INTLEVELACT 0
                    18142   ; #define INTEDGEACT 1
                    18143   ; #define PRIORITY_LOW 0
                    18144   ; #define PRIORITY_HIGH 1
                    18145   ; /* default (reset) value for register content, clear register */
                    18146   ; #define ClrByte 0x00
                    18147   ; /* constant: clear Interrupt Enable Register */
                    18148   ; #define ClrIntEnSJA ClrByte
                    18149   ; /* definitions for the acceptance code and mask register */
                    18150   ; #define DontCare 0xFF
                    18151   ; /*  bus timing values for
                    18152   ; **  bit-rate : 100 kBit/s
                    18153   ; **  oscillator frequency : 25 MHz, 1 sample per bit, 0 tolerance %
                    18154   ; **  maximum tolerated propagation delay : 4450 ns
                    18155   ; **  minimum requested propagation delay : 500 ns
                    18156   ; **
                    18157   ; **  https://www.kvaser.com/support/calculators/bit-timing-calculator/
                    18158   ; **  T1 	T2 	BTQ 	SP% 	SJW 	BIT RATE 	ERR% 	BTR0 	BTR1
                    18159   ; **  17	8	25	    68	     1	      100	    0	      04	7f
                    18160   ; */
                    18161   ; void Wait1ms(void);
                    18162   ; void Wait500ms(void)
                    18163   ; {
                    18164   _Wait500ms:
00005F98  2F02      18165          move.l    D2,-(A7)
                    18166   ; int i ;
                    18167   ; for(i = 0; i < 500; i++)
00005F9A  4282      18168          clr.l     D2
                    18169   Wait500ms_1:
00005F9C  0C82 0000 18170          cmp.l     #500,D2
00005FA0  01F4      
00005FA2  6C08      18171          bge.s     Wait500ms_3
                    18172   ; Wait1ms() ;
00005FA4  4EB8 5AA8 18173          jsr       _Wait1ms
00005FA8  5282      18174          addq.l    #1,D2
00005FAA  60F0      18175          bra       Wait500ms_1
                    18176   Wait500ms_3:
00005FAC  241F      18177          move.l    (A7)+,D2
00005FAE  4E75      18178          rts
                    18179   ; }
                    18180   ; // initialisation for Can controller 0
                    18181   ; void Init_CanBus_Controller0(void)
                    18182   ; {
                    18183   _Init_CanBus_Controller0:
                    18184   ; // TODO - put your Canbus initialisation code for CanController 0 here
                    18185   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                    18186   ; /* define interrupt priority & control (level-activated, see chapter 4.2.5) */
                    18187   ; // PX0 = PRIORITY_HIGH; /* CAN HAS A HIGH PRIORITY INTERRUPT */
                    18188   ; // IT0 = INTLEVELACT; /* set interrupt0 to level activated */
                    18189   ; // /* enable the communication interface of the SJA1000 */
                    18190   ; // CS = ENABLE_N; /* Enable the SJA1000 interface */
                    18191   ; /*- end of the definition of the communication link -------------------------*/
                    18192   ; /* disable interrupts, if used (not necessary after power-on) */
                    18193   ; // EA = DISABLE; /* disable all interrupts */
                    18194   ; //Can0_InterruptReg = DISABLE; /* disable external interrupt from SJA1000 */
                    18195   ; /* set reset mode/request (Note: after power-on SJA1000 is in BasicCAN mode)
                    18196   ; leave loop after a time out and signal an error */
                    18197   ; while((Can0_ModeControlReg & RM_RR_Bit ) == ClrByte)
                    18198   Init_CanBus_Controller0_1:
00005FB0  1039 0050 18199          move.b    5242880,D0
00005FB4  0000      
00005FB6  C03C 0001 18200          and.b     #1,D0
00005FBA  6612      18201          bne.s     Init_CanBus_Controller0_3
                    18202   ; {
                    18203   ; /* other bits than the reset mode/request bit are unchanged */
                    18204   ; Can0_ModeControlReg = Can0_ModeControlReg | RM_RR_Bit ;
00005FBC  1039 0050 18205          move.b    5242880,D0
00005FC0  0000      
00005FC2  803C 0001 18206          or.b      #1,D0
00005FC6  13C0 0050 18207          move.b    D0,5242880
00005FCA  0000      
00005FCC  60E2      18208          bra       Init_CanBus_Controller0_1
                    18209   Init_CanBus_Controller0_3:
                    18210   ; }
                    18211   ; /* set the Clock Divider Register according to the given hardware of Figure 3
                    18212   ; select PeliCAN mode
                    18213   ; bypass CAN input comparator as external transceiver is used
                    18214   ; select the clock for the controller S87C654 */
                    18215   ; Can0_ClockDivideReg = CANMode_Bit | CBP_Bit | DivBy2;
00005FCE  13FC 00C0 18216          move.b    #192,5242942
00005FD2  0050 003E 
                    18217   ; /* disable CAN interrupts, if required (always necessary after power-on)
                    18218   ; (write to SJA1000 Interrupt Enable / Control Register) */
                    18219   ; Can0_InterruptEnReg = ClrIntEnSJA;
00005FD6  4239 0050 18220          clr.b     5242888
00005FDA  0008      
                    18221   ; /* define acceptance code and mask */
                    18222   ; Can0_AcceptCode0Reg = ClrByte; 
00005FDC  4239 0050 18223          clr.b     5242912
00005FE0  0020      
                    18224   ; Can0_AcceptCode1Reg = ClrByte; 
00005FE2  4239 0050 18225          clr.b     5242914
00005FE6  0022      
                    18226   ; Can0_AcceptCode2Reg = ClrByte; 
00005FE8  4239 0050 18227          clr.b     5242916
00005FEC  0024      
                    18228   ; Can0_AcceptCode3Reg = ClrByte; 
00005FEE  4239 0050 18229          clr.b     5242918
00005FF2  0026      
                    18230   ; Can0_AcceptMask0Reg = DontCare; /* every identifier is accepted */
00005FF4  13FC 00FF 18231          move.b    #255,5242920
00005FF8  0050 0028 
                    18232   ; Can0_AcceptMask1Reg = DontCare; /* every identifier is accepted */
00005FFC  13FC 00FF 18233          move.b    #255,5242922
00006000  0050 002A 
                    18234   ; Can0_AcceptMask2Reg = DontCare; /* every identifier is accepted */
00006004  13FC 00FF 18235          move.b    #255,5242924
00006008  0050 002C 
                    18236   ; Can0_AcceptMask3Reg = DontCare; /* every identifier is accepted */
0000600C  13FC 00FF 18237          move.b    #255,5242926
00006010  0050 002E 
                    18238   ; /* configure bus timing */
                    18239   ; /* bit-rate = 1 Mbit/s @ 24 MHz, the bus is sampled once */
                    18240   ; Can0_BusTiming0Reg = 0x04;
00006014  13FC 0004 18241          move.b    #4,5242892
00006018  0050 000C 
                    18242   ; Can0_BusTiming1Reg = 0x7f;
0000601C  13FC 007F 18243          move.b    #127,5242894
00006020  0050 000E 
                    18244   ; /* configure CAN outputs: float on TX1, Push/Pull on TX0,
                    18245   ; normal output mode */
                    18246   ; Can0_OutControlReg = Tx1Float | Tx0PshPull | NormalMode;
00006024  13FC 001A 18247          move.b    #26,5242896
00006028  0050 0010 
                    18248   ; /* leave the reset mode/request i.e. switch to operating mode,
                    18249   ; the interrupts of the S87C654 are enabled
                    18250   ; but not the CAN interrupts of the SJA1000, which can be done separately
                    18251   ; for the different tasks in a system */
                    18252   ; /* clear Reset Mode bit, select dual Acceptance Filter Mode,
                    18253   ; switch off Self Test Mode and Listen Only Mode,
                    18254   ; clear Sleep Mode (wake up) */
                    18255   ; do /* wait until RM_RR_Bit is cleared */
                    18256   Init_CanBus_Controller0_4:
                    18257   ; /* break loop after a time out and signal an error */
                    18258   ; {
                    18259   ; Can0_ModeControlReg = ClrByte;
0000602C  4239 0050 18260          clr.b     5242880
00006030  0000      
00006032  1039 0050 18261          move.b    5242880,D0
00006036  0000      
00006038  C03C 0001 18262          and.b     #1,D0
0000603C  66EE      18263          bne       Init_CanBus_Controller0_4
0000603E  4E75      18264          rts
                    18265   ; } while((Can0_ModeControlReg & RM_RR_Bit ) != ClrByte);
                    18266   ; //Can0_InterruptReg = ENABLE; /* enable external interrupt from SJA1000 */
                    18267   ; // EA = ENABLE; /* enable all interrupts */
                    18268   ; /*----- end of Initialization Example of the SJA1000 ------------------------*/
                    18269   ; }
                    18270   ; // initialisation for Can controller 1
                    18271   ; void Init_CanBus_Controller1(void)
                    18272   ; {
                    18273   _Init_CanBus_Controller1:
                    18274   ; // TODO - put your Canbus initialisation code for CanController 1 here
                    18275   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                    18276   ; // TODO - put your Canbus initialisation code for CanController 0 here
                    18277   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                    18278   ; /* disable interrupts, if used (not necessary after power-on) */
                    18279   ; // EA = DISABLE; /* disable all interrupts */
                    18280   ; //Can1_InterruptReg = DISABLE; /* disable external interrupt from SJA1000 */
                    18281   ; /* set reset mode/request (Note: after power-on SJA1000 is in BasicCAN mode)
                    18282   ; leave loop after a time out and signal an error */
                    18283   ; while((Can1_ModeControlReg & RM_RR_Bit ) == ClrByte)
                    18284   Init_CanBus_Controller1_1:
00006040  1039 0050 18285          move.b    5243392,D0
00006044  0200      
00006046  C03C 0001 18286          and.b     #1,D0
0000604A  6612      18287          bne.s     Init_CanBus_Controller1_3
                    18288   ; {
                    18289   ; /* other bits than the reset mode/request bit are unchanged */
                    18290   ; Can1_ModeControlReg = Can1_ModeControlReg | RM_RR_Bit ;
0000604C  1039 0050 18291          move.b    5243392,D0
00006050  0200      
00006052  803C 0001 18292          or.b      #1,D0
00006056  13C0 0050 18293          move.b    D0,5243392
0000605A  0200      
0000605C  60E2      18294          bra       Init_CanBus_Controller1_1
                    18295   Init_CanBus_Controller1_3:
                    18296   ; }
                    18297   ; /* set the Clock Divider Register according to the given hardware of Figure 3
                    18298   ; select PeliCAN mode
                    18299   ; bypass CAN input comparator as external transceiver is used
                    18300   ; select the clock for the controller S87C654 */
                    18301   ; Can1_ClockDivideReg = CANMode_Bit | CBP_Bit | DivBy2;
0000605E  13FC 00C0 18302          move.b    #192,5243454
00006062  0050 023E 
                    18303   ; /* disable CAN interrupts, if required (always necessary after power-on)
                    18304   ; (write to SJA1000 Interrupt Enable / Control Register) */
                    18305   ; Can1_InterruptEnReg = ClrIntEnSJA;
00006066  4239 0050 18306          clr.b     5243400
0000606A  0208      
                    18307   ; /* define acceptance code and mask */
                    18308   ; Can1_AcceptCode0Reg = ClrByte; 
0000606C  4239 0050 18309          clr.b     5243424
00006070  0220      
                    18310   ; Can1_AcceptCode1Reg = ClrByte; 
00006072  4239 0050 18311          clr.b     5243426
00006076  0222      
                    18312   ; Can1_AcceptCode2Reg = ClrByte; 
00006078  4239 0050 18313          clr.b     5243428
0000607C  0224      
                    18314   ; Can1_AcceptCode3Reg = ClrByte; 
0000607E  4239 0050 18315          clr.b     5243430
00006082  0226      
                    18316   ; Can1_AcceptMask0Reg = DontCare; /* every identifier is accepted */
00006084  13FC 00FF 18317          move.b    #255,5243432
00006088  0050 0228 
                    18318   ; Can1_AcceptMask1Reg = DontCare; /* every identifier is accepted */
0000608C  13FC 00FF 18319          move.b    #255,5243434
00006090  0050 022A 
                    18320   ; Can1_AcceptMask2Reg = DontCare; /* every identifier is accepted */
00006094  13FC 00FF 18321          move.b    #255,5243436
00006098  0050 022C 
                    18322   ; Can1_AcceptMask3Reg = DontCare; /* every identifier is accepted */
0000609C  13FC 00FF 18323          move.b    #255,5243438
000060A0  0050 022E 
                    18324   ; /* configure bus timing */
                    18325   ; /* bit-rate = 1 Mbit/s @ 24 MHz, the bus is sampled once */
                    18326   ; Can1_BusTiming0Reg = 0x04;
000060A4  13FC 0004 18327          move.b    #4,5243404
000060A8  0050 020C 
                    18328   ; Can1_BusTiming1Reg = 0x7f;
000060AC  13FC 007F 18329          move.b    #127,5243406
000060B0  0050 020E 
                    18330   ; /* configure CAN outputs: float on TX1, Push/Pull on TX0,
                    18331   ; normal output mode */
                    18332   ; Can1_OutControlReg = Tx1Float | Tx0PshPull | NormalMode;
000060B4  13FC 001A 18333          move.b    #26,5243408
000060B8  0050 0210 
                    18334   ; /* leave the reset mode/request i.e. switch to operating mode,
                    18335   ; the interrupts of the S87C654 are enabled
                    18336   ; but not the CAN interrupts of the SJA1000, which can be done separately
                    18337   ; for the different tasks in a system */
                    18338   ; /* clear Reset Mode bit, select dual Acceptance Filter Mode,
                    18339   ; switch off Self Test Mode and Listen Only Mode,
                    18340   ; clear Sleep Mode (wake up) */
                    18341   ; do /* wait until RM_RR_Bit is cleared */
                    18342   Init_CanBus_Controller1_4:
                    18343   ; /* break loop after a time out and signal an error */
                    18344   ; {
                    18345   ; Can1_ModeControlReg = ClrByte;
000060BC  4239 0050 18346          clr.b     5243392
000060C0  0200      
000060C2  1039 0050 18347          move.b    5243392,D0
000060C6  0200      
000060C8  C03C 0001 18348          and.b     #1,D0
000060CC  66EE      18349          bne       Init_CanBus_Controller1_4
000060CE  4E75      18350          rts
                    18351   ; } while((Can1_ModeControlReg & RM_RR_Bit ) != ClrByte);
                    18352   ; //Can1_InterruptReg = ENABLE; /* enable external interrupt from SJA1000 */
                    18353   ; // EA = ENABLE; /* enable all interrupts */
                    18354   ; /*----- end of Initialization Example of the SJA1000 ------------------------*/
                    18355   ; }
                    18356   ; // Transmit for sending a message via Can controller 0
                    18357   ; void CanBus0_Transmit(unsigned int* ID, unsigned int* TxData1)
                    18358   ; {
                    18359   _CanBus0_Transmit:
000060D0  4E56 0000 18360          link      A6,#0
000060D4  2F0A      18361          move.l    A2,-(A7)
000060D6  45F9 0000 18362          lea       _printf.L,A2
000060DA  67BE      
                    18363   ; // TODO - put your Canbus transmit code for CanController 0 here
                    18364   ; // See section 4.2.2 in the application note for details (PELICAN MODE)
                    18365   ; /* wait until the Transmit Buffer is released */
                    18366   ; do
                    18367   ; {
                    18368   CanBus0_Transmit_1:
                    18369   ; printf("\r\n[CanBus0]:Wait for Tx Begin");
000060DC  4879 0000 18370          pea       @canbus~1_1.L
000060E0  72B6      
000060E2  4E92      18371          jsr       (A2)
000060E4  584F      18372          addq.w    #4,A7
000060E6  1039 0050 18373          move.b    5242884,D0
000060EA  0004      
000060EC  C03C 0004 18374          and.b     #4,D0
000060F0  0C00 0004 18375          cmp.b     #4,D0
000060F4  66E6      18376          bne       CanBus0_Transmit_1
                    18377   ; /* start a polling timer and run some tasks while waiting
                    18378   ; break the loop and signal an error if time too long */
                    18379   ; } while((Can0_StatusReg & TBS_Bit ) != TBS_Bit );
                    18380   ; /* Transmit Buffer is released, a message may be written into the buffer */
                    18381   ; /* in this example a Standard Frame message shall be transmitted */
                    18382   ; Can0_TxFrameInfo = 0x08; /* SFF (data), DLC=8 */
000060F6  13FC 0008 18383          move.b    #8,5242912
000060FA  0050 0020 
                    18384   ; Can0_TxBuffer1 = *ID;
000060FE  206E 0008 18385          move.l    8(A6),A0
00006102  2010      18386          move.l    (A0),D0
00006104  13C0 0050 18387          move.b    D0,5242914
00006108  0022      
                    18388   ; Can0_TxBuffer2 = 0x20;   /* ID2 = 20, (0010 0000) */
0000610A  13FC 0020 18389          move.b    #32,5242916
0000610E  0050 0024 
                    18390   ; Can0_TxBuffer3 = *TxData1; 
00006112  206E 000C 18391          move.l    12(A6),A0
00006116  2010      18392          move.l    (A0),D0
00006118  13C0 0050 18393          move.b    D0,5242918
0000611C  0026      
                    18394   ; /* Start the transmission */
                    18395   ; Can0_CommandReg = TR_Bit ; /* Set Transmission Request bit */
0000611E  13FC 0001 18396          move.b    #1,5242882
00006122  0050 0002 
                    18397   ; do
                    18398   ; {
                    18399   CanBus0_Transmit_3:
                    18400   ; printf("\r\n[CanBus0]:Wait for Tx Finish");
00006126  4879 0000 18401          pea       @canbus~1_2.L
0000612A  72D4      
0000612C  4E92      18402          jsr       (A2)
0000612E  584F      18403          addq.w    #4,A7
00006130  1039 0050 18404          move.b    5242884,D0
00006134  0004      
00006136  C03C 0008 18405          and.b     #8,D0
0000613A  67EA      18406          beq       CanBus0_Transmit_3
                    18407   ; } while (!(Can0_StatusReg & TCS_Bit));
                    18408   ; printf("[CanBus0Tx]:");
0000613C  4879 0000 18409          pea       @canbus~1_3.L
00006140  72F4      
00006142  4E92      18410          jsr       (A2)
00006144  584F      18411          addq.w    #4,A7
00006146  245F      18412          move.l    (A7)+,A2
00006148  4E5E      18413          unlk      A6
0000614A  4E75      18414          rts
                    18415   ; }
                    18416   ; // Transmit for sending a message via Can controller 1
                    18417   ; void CanBus1_Transmit(unsigned int* ID, unsigned int* TxData1)
                    18418   ; {
                    18419   _CanBus1_Transmit:
0000614C  4E56 0000 18420          link      A6,#0
                    18421   ; // TODO - put your Canbus transmit code for CanController 1 here
                    18422   ; // See section 4.2.2 in the application note for details (PELICAN MODE)
                    18423   ; /* wait until the Transmit Buffer is released */
                    18424   ; do
                    18425   ; {
                    18426   CanBus1_Transmit_1:
                    18427   ; /* start a polling timer and run some tasks while waiting
                    18428   ; break the loop and signal an error if time too long */
                    18429   ; //printf("\r\n[CanBus1]:Wait for Tx Begin");
                    18430   ; } while((Can1_StatusReg & TBS_Bit ) != TBS_Bit );
00006150  1039 0050 18431          move.b    5243396,D0
00006154  0204      
00006156  C03C 0004 18432          and.b     #4,D0
0000615A  0C00 0004 18433          cmp.b     #4,D0
0000615E  66F0      18434          bne       CanBus1_Transmit_1
                    18435   ; /* Transmit Buffer is released, a message may be written into the buffer */
                    18436   ; /* in this example a Standard Frame message shall be transmitted */
                    18437   ; Can1_TxFrameInfo = 0x08; /* SFF (data), DLC=8 */
00006160  13FC 0008 18438          move.b    #8,5243424
00006164  0050 0220 
                    18439   ; Can1_TxBuffer1 = *ID;   /* ID1 = A5, (1010 0101) */
00006168  206E 0008 18440          move.l    8(A6),A0
0000616C  2010      18441          move.l    (A0),D0
0000616E  13C0 0050 18442          move.b    D0,5243426
00006172  0222      
                    18443   ; Can1_TxBuffer2 = 0x20;   /* ID2 = 20, (0010 0000) */
00006174  13FC 0020 18444          move.b    #32,5243428
00006178  0050 0224 
                    18445   ; Can1_TxBuffer3 = *TxData1; 
0000617C  206E 000C 18446          move.l    12(A6),A0
00006180  2010      18447          move.l    (A0),D0
00006182  13C0 0050 18448          move.b    D0,5243430
00006186  0226      
                    18449   ; /* Start the transmission */
                    18450   ; Can1_CommandReg = TR_Bit ; /* Set Transmission Request bit */
00006188  13FC 0001 18451          move.b    #1,5243394
0000618C  0050 0202 
                    18452   ; do
                    18453   ; {
                    18454   CanBus1_Transmit_3:
                    18455   ; //printf("\r\n[CanBus1]:Wait for Tx Finish");
                    18456   ; } while (!(Can1_StatusReg & TCS_Bit));
00006190  1039 0050 18457          move.b    5243396,D0
00006194  0204      
00006196  C03C 0008 18458          and.b     #8,D0
0000619A  67F4      18459          beq       CanBus1_Transmit_3
                    18460   ; printf("[CanBus1Tx]:");
0000619C  4879 0000 18461          pea       @canbus~1_4.L
000061A0  7302      
000061A2  4EB9 0000 18462          jsr       _printf
000061A6  67BE      
000061A8  584F      18463          addq.w    #4,A7
000061AA  4E5E      18464          unlk      A6
000061AC  4E75      18465          rts
                    18466   ; }
                    18467   ; // Receive for reading a received message via Can controller 0
                    18468   ; void CanBus0_Receive(unsigned int* ID, unsigned int* RxData1)
                    18469   ; {
                    18470   _CanBus0_Receive:
000061AE  4E56 0000 18471          link      A6,#0
                    18472   ; // TODO - put your Canbus receive code for CanController 0 here
                    18473   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                    18474   ; do
                    18475   ; {
                    18476   CanBus0_Receive_1:
                    18477   ; //printf("\r\n[CanBus0]:Wait for Rx Begin");
                    18478   ; } while (!(Can0_StatusReg & RBS_Bit));
000061B2  1039 0050 18479          move.b    5242884,D0
000061B6  0004      
000061B8  C03C 0001 18480          and.b     #1,D0
000061BC  67F4      18481          beq       CanBus0_Receive_1
                    18482   ; *ID      = Can0_RxBuffer1;
000061BE  1039 0050 18483          move.b    5242914,D0
000061C2  0022      
000061C4  C0BC 0000 18484          and.l     #255,D0
000061C8  00FF      
000061CA  206E 0008 18485          move.l    8(A6),A0
000061CE  2080      18486          move.l    D0,(A0)
                    18487   ; *RxData1 = Can0_RxBuffer3;
000061D0  1039 0050 18488          move.b    5242918,D0
000061D4  0026      
000061D6  C0BC 0000 18489          and.l     #255,D0
000061DA  00FF      
000061DC  206E 000C 18490          move.l    12(A6),A0
000061E0  2080      18491          move.l    D0,(A0)
                    18492   ; Can0_CommandReg = RRB_Bit;
000061E2  13FC 0004 18493          move.b    #4,5242882
000061E6  0050 0002 
                    18494   ; printf("[CanBus0Rx]:");
000061EA  4879 0000 18495          pea       @canbus~1_5.L
000061EE  7310      
000061F0  4EB9 0000 18496          jsr       _printf
000061F4  67BE      
000061F6  584F      18497          addq.w    #4,A7
000061F8  4E5E      18498          unlk      A6
000061FA  4E75      18499          rts
                    18500   ; }
                    18501   ; // Receive for reading a received message via Can controller 1
                    18502   ; void CanBus1_Receive(unsigned int* ID, unsigned int* RxData1)
                    18503   ; {
                    18504   _CanBus1_Receive:
000061FC  4E56 0000 18505          link      A6,#0
                    18506   ; // TODO - put your Canbus receive code for CanController 1 here
                    18507   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                    18508   ; do
                    18509   ; {
                    18510   CanBus1_Receive_1:
                    18511   ; //printf("\r\n[CanBus1]:Wait for Rx Begin");
                    18512   ; } while (!(Can1_StatusReg & RBS_Bit));
00006200  1039 0050 18513          move.b    5243396,D0
00006204  0204      
00006206  C03C 0001 18514          and.b     #1,D0
0000620A  67F4      18515          beq       CanBus1_Receive_1
                    18516   ; *ID = Can1_RxBuffer1;
0000620C  1039 0050 18517          move.b    5243426,D0
00006210  0222      
00006212  C0BC 0000 18518          and.l     #255,D0
00006216  00FF      
00006218  206E 0008 18519          move.l    8(A6),A0
0000621C  2080      18520          move.l    D0,(A0)
                    18521   ; *RxData1 = Can1_RxBuffer3;
0000621E  1039 0050 18522          move.b    5243430,D0
00006222  0226      
00006224  C0BC 0000 18523          and.l     #255,D0
00006228  00FF      
0000622A  206E 000C 18524          move.l    12(A6),A0
0000622E  2080      18525          move.l    D0,(A0)
                    18526   ; Can1_CommandReg = RRB_Bit;
00006230  13FC 0004 18527          move.b    #4,5243394
00006234  0050 0202 
                    18528   ; printf("[CanBus1Rx]:");
00006238  4879 0000 18529          pea       @canbus~1_6.L
0000623C  731E      
0000623E  4EB9 0000 18530          jsr       _printf
00006242  67BE      
00006244  584F      18531          addq.w    #4,A7
00006246  4E5E      18532          unlk      A6
00006248  4E75      18533          rts
                    18534   ; }
                    18535   ; void CanBusTest(void)
                    18536   ; {
                    18537   _CanBusTest:
0000624A  4E56 FFF4 18538          link      A6,#-12
0000624E  48E7 003C 18539          movem.l   A2/A3/A4/A5,-(A7)
00006252  45EE FFF4 18540          lea       -12(A6),A2
00006256  47F9 0000 18541          lea       _printf.L,A3
0000625A  67BE      
0000625C  49EE FFFC 18542          lea       -4(A6),A4
00006260  4BEE FFF8 18543          lea       -8(A6),A5
                    18544   ; // initialise the two Can controllers
                    18545   ; unsigned int Data, ID, ID_rx = 0;
00006264  4294      18546          clr.l     (A4)
                    18547   ; printf("\r\nCanBus Init");
00006266  4879 0000 18548          pea       @canbus~1_7.L
0000626A  732C      
0000626C  4E93      18549          jsr       (A3)
0000626E  584F      18550          addq.w    #4,A7
                    18551   ; Init_CanBus_Controller0();
00006270  4EB8 5FB0 18552          jsr       _Init_CanBus_Controller0
                    18553   ; Init_CanBus_Controller1();
00006274  4EB8 6040 18554          jsr       _Init_CanBus_Controller1
                    18555   ; printf("\r\n\r\n---- CANBUS Test ----\r\n") ;
00006278  4879 0000 18556          pea       @canbus~1_8.L
0000627C  733A      
0000627E  4E93      18557          jsr       (A3)
00006280  584F      18558          addq.w    #4,A7
                    18559   ; // simple application to alternately transmit and receive messages from each of two nodes
                    18560   ; while(1) 
                    18561   CanBusTest_1:
                    18562   ; {
                    18563   ; printf("\r\n[CanBusTest]:CanBus0 Tx to CanBus1");
00006282  4879 0000 18564          pea       @canbus~1_9.L
00006286  7356      
00006288  4E93      18565          jsr       (A3)
0000628A  584F      18566          addq.w    #4,A7
                    18567   ; Wait500ms();
0000628C  4EB8 5F98 18568          jsr       _Wait500ms
                    18569   ; Data = 1;
00006290  24BC 0000 18570          move.l    #1,(A2)
00006294  0001      
                    18571   ; ID = 1;
00006296  2ABC 0000 18572          move.l    #1,(A5)
0000629A  0001      
                    18573   ; CanBus0_Transmit(&ID, &Data);
0000629C  2F0A      18574          move.l    A2,-(A7)
0000629E  2F0D      18575          move.l    A5,-(A7)
000062A0  4EB8 60D0 18576          jsr       _CanBus0_Transmit
000062A4  504F      18577          addq.w    #8,A7
                    18578   ; Data = 2;
000062A6  24BC 0000 18579          move.l    #2,(A2)
000062AA  0002      
                    18580   ; ID = 2;
000062AC  2ABC 0000 18581          move.l    #2,(A5)
000062B0  0002      
                    18582   ; CanBus0_Transmit(&ID, &Data);
000062B2  2F0A      18583          move.l    A2,-(A7)
000062B4  2F0D      18584          move.l    A5,-(A7)
000062B6  4EB8 60D0 18585          jsr       _CanBus0_Transmit
000062BA  504F      18586          addq.w    #8,A7
                    18587   ; Data = 3;
000062BC  24BC 0000 18588          move.l    #3,(A2)
000062C0  0003      
                    18589   ; ID = 3;
000062C2  2ABC 0000 18590          move.l    #3,(A5)
000062C6  0003      
                    18591   ; CanBus0_Transmit(&ID, &Data);
000062C8  2F0A      18592          move.l    A2,-(A7)
000062CA  2F0D      18593          move.l    A5,-(A7)
000062CC  4EB8 60D0 18594          jsr       _CanBus0_Transmit
000062D0  504F      18595          addq.w    #8,A7
                    18596   ; Data = 4;
000062D2  24BC 0000 18597          move.l    #4,(A2)
000062D6  0004      
                    18598   ; ID = 4;
000062D8  2ABC 0000 18599          move.l    #4,(A5)
000062DC  0004      
                    18600   ; CanBus0_Transmit(&ID, &Data);
000062DE  2F0A      18601          move.l    A2,-(A7)
000062E0  2F0D      18602          move.l    A5,-(A7)
000062E2  4EB8 60D0 18603          jsr       _CanBus0_Transmit
000062E6  504F      18604          addq.w    #8,A7
                    18605   ; CanBus1_Receive(&ID_rx, &Data);
000062E8  2F0A      18606          move.l    A2,-(A7)
000062EA  2F0C      18607          move.l    A4,-(A7)
000062EC  4EB8 61FC 18608          jsr       _CanBus1_Receive
000062F0  504F      18609          addq.w    #8,A7
                    18610   ; printf("\r\n[CanBus1]:Received Data: %x @ ID %d", Data, ID_rx);
000062F2  2F14      18611          move.l    (A4),-(A7)
000062F4  2F12      18612          move.l    (A2),-(A7)
000062F6  4879 0000 18613          pea       @canbus~1_10.L
000062FA  737C      
000062FC  4E93      18614          jsr       (A3)
000062FE  DEFC 000C 18615          add.w     #12,A7
                    18616   ; CanBus1_Receive(&ID_rx, &Data);
00006302  2F0A      18617          move.l    A2,-(A7)
00006304  2F0C      18618          move.l    A4,-(A7)
00006306  4EB8 61FC 18619          jsr       _CanBus1_Receive
0000630A  504F      18620          addq.w    #8,A7
                    18621   ; printf("\r\n[CanBus1]:Received Data: %x @ ID %d", Data, ID_rx);
0000630C  2F14      18622          move.l    (A4),-(A7)
0000630E  2F12      18623          move.l    (A2),-(A7)
00006310  4879 0000 18624          pea       @canbus~1_10.L
00006314  737C      
00006316  4E93      18625          jsr       (A3)
00006318  DEFC 000C 18626          add.w     #12,A7
                    18627   ; CanBus1_Receive(&ID_rx, &Data);
0000631C  2F0A      18628          move.l    A2,-(A7)
0000631E  2F0C      18629          move.l    A4,-(A7)
00006320  4EB8 61FC 18630          jsr       _CanBus1_Receive
00006324  504F      18631          addq.w    #8,A7
                    18632   ; printf("\r\n[CanBus1]:Received Data: %x @ ID %d", Data, ID_rx);
00006326  2F14      18633          move.l    (A4),-(A7)
00006328  2F12      18634          move.l    (A2),-(A7)
0000632A  4879 0000 18635          pea       @canbus~1_10.L
0000632E  737C      
00006330  4E93      18636          jsr       (A3)
00006332  DEFC 000C 18637          add.w     #12,A7
                    18638   ; CanBus1_Receive(&ID_rx, &Data);
00006336  2F0A      18639          move.l    A2,-(A7)
00006338  2F0C      18640          move.l    A4,-(A7)
0000633A  4EB8 61FC 18641          jsr       _CanBus1_Receive
0000633E  504F      18642          addq.w    #8,A7
                    18643   ; printf("\r\n[CanBus1]:Received Data: %x @ ID %d", Data, ID_rx);
00006340  2F14      18644          move.l    (A4),-(A7)
00006342  2F12      18645          move.l    (A2),-(A7)
00006344  4879 0000 18646          pea       @canbus~1_10.L
00006348  737C      
0000634A  4E93      18647          jsr       (A3)
0000634C  DEFC 000C 18648          add.w     #12,A7
                    18649   ; printf("\r\n");
00006350  4879 0000 18650          pea       @canbus~1_11.L
00006354  73A2      
00006356  4E93      18651          jsr       (A3)
00006358  584F      18652          addq.w    #4,A7
                    18653   ; printf("\r\n[CanBusTest]:CanBus1 Tx to CanBus0");
0000635A  4879 0000 18654          pea       @canbus~1_12.L
0000635E  73A6      
00006360  4E93      18655          jsr       (A3)
00006362  584F      18656          addq.w    #4,A7
                    18657   ; Wait500ms();                    // write a routine to delay say 1/2 second so we don't flood the network with messages to0 quickly
00006364  4EB8 5F98 18658          jsr       _Wait500ms
                    18659   ; Data = 1;
00006368  24BC 0000 18660          move.l    #1,(A2)
0000636C  0001      
                    18661   ; ID = 1;
0000636E  2ABC 0000 18662          move.l    #1,(A5)
00006372  0001      
                    18663   ; CanBus1_Transmit(&ID, &Data);
00006374  2F0A      18664          move.l    A2,-(A7)
00006376  2F0D      18665          move.l    A5,-(A7)
00006378  4EB8 614C 18666          jsr       _CanBus1_Transmit
0000637C  504F      18667          addq.w    #8,A7
                    18668   ; Data = 2;
0000637E  24BC 0000 18669          move.l    #2,(A2)
00006382  0002      
                    18670   ; ID = 2;
00006384  2ABC 0000 18671          move.l    #2,(A5)
00006388  0002      
                    18672   ; CanBus1_Transmit(&ID, &Data);
0000638A  2F0A      18673          move.l    A2,-(A7)
0000638C  2F0D      18674          move.l    A5,-(A7)
0000638E  4EB8 614C 18675          jsr       _CanBus1_Transmit
00006392  504F      18676          addq.w    #8,A7
                    18677   ; Data = 3;
00006394  24BC 0000 18678          move.l    #3,(A2)
00006398  0003      
                    18679   ; ID = 3;
0000639A  2ABC 0000 18680          move.l    #3,(A5)
0000639E  0003      
                    18681   ; CanBus1_Transmit(&ID, &Data);
000063A0  2F0A      18682          move.l    A2,-(A7)
000063A2  2F0D      18683          move.l    A5,-(A7)
000063A4  4EB8 614C 18684          jsr       _CanBus1_Transmit
000063A8  504F      18685          addq.w    #8,A7
                    18686   ; Data = 4;
000063AA  24BC 0000 18687          move.l    #4,(A2)
000063AE  0004      
                    18688   ; ID = 4;
000063B0  2ABC 0000 18689          move.l    #4,(A5)
000063B4  0004      
                    18690   ; CanBus1_Transmit(&ID, &Data);
000063B6  2F0A      18691          move.l    A2,-(A7)
000063B8  2F0D      18692          move.l    A5,-(A7)
000063BA  4EB8 614C 18693          jsr       _CanBus1_Transmit
000063BE  504F      18694          addq.w    #8,A7
                    18695   ; CanBus0_Receive(&ID_rx, &Data);
000063C0  2F0A      18696          move.l    A2,-(A7)
000063C2  2F0C      18697          move.l    A4,-(A7)
000063C4  4EB8 61AE 18698          jsr       _CanBus0_Receive
000063C8  504F      18699          addq.w    #8,A7
                    18700   ; printf("\r\n[CanBus1]:Received Data: %x @ ID %d", Data, ID_rx);
000063CA  2F14      18701          move.l    (A4),-(A7)
000063CC  2F12      18702          move.l    (A2),-(A7)
000063CE  4879 0000 18703          pea       @canbus~1_10.L
000063D2  737C      
000063D4  4E93      18704          jsr       (A3)
000063D6  DEFC 000C 18705          add.w     #12,A7
                    18706   ; CanBus0_Receive(&ID_rx, &Data);
000063DA  2F0A      18707          move.l    A2,-(A7)
000063DC  2F0C      18708          move.l    A4,-(A7)
000063DE  4EB8 61AE 18709          jsr       _CanBus0_Receive
000063E2  504F      18710          addq.w    #8,A7
                    18711   ; printf("\r\n[CanBus1]:Received Data: %x @ ID %d", Data, ID_rx);
000063E4  2F14      18712          move.l    (A4),-(A7)
000063E6  2F12      18713          move.l    (A2),-(A7)
000063E8  4879 0000 18714          pea       @canbus~1_10.L
000063EC  737C      
000063EE  4E93      18715          jsr       (A3)
000063F0  DEFC 000C 18716          add.w     #12,A7
                    18717   ; CanBus0_Receive(&ID_rx, &Data);
000063F4  2F0A      18718          move.l    A2,-(A7)
000063F6  2F0C      18719          move.l    A4,-(A7)
000063F8  4EB8 61AE 18720          jsr       _CanBus0_Receive
000063FC  504F      18721          addq.w    #8,A7
                    18722   ; printf("\r\n[CanBus1]:Received Data: %x @ ID %d", Data, ID_rx);
000063FE  2F14      18723          move.l    (A4),-(A7)
00006400  2F12      18724          move.l    (A2),-(A7)
00006402  4879 0000 18725          pea       @canbus~1_10.L
00006406  737C      
00006408  4E93      18726          jsr       (A3)
0000640A  DEFC 000C 18727          add.w     #12,A7
                    18728   ; CanBus0_Receive(&ID_rx, &Data);
0000640E  2F0A      18729          move.l    A2,-(A7)
00006410  2F0C      18730          move.l    A4,-(A7)
00006412  4EB8 61AE 18731          jsr       _CanBus0_Receive
00006416  504F      18732          addq.w    #8,A7
                    18733   ; printf("\r\n[CanBus1]:Received Data: %x @ ID %d", Data, ID_rx);
00006418  2F14      18734          move.l    (A4),-(A7)
0000641A  2F12      18735          move.l    (A2),-(A7)
0000641C  4879 0000 18736          pea       @canbus~1_10.L
00006420  737C      
00006422  4E93      18737          jsr       (A3)
00006424  DEFC 000C 18738          add.w     #12,A7
                    18739   ; printf("\r\n");
00006428  4879 0000 18740          pea       @canbus~1_11.L
0000642C  73A2      
0000642E  4E93      18741          jsr       (A3)
00006430  584F      18742          addq.w    #4,A7
00006432  6000 FE4E 18743          bra       CanBusTest_1
                    18744   ; }
                    18745   ; }
                    18746   ; C:\M68KV6.0 - 800BY480\ASSIGNMENT6\PARTB_PROJ\DAC_ADC_MAIN.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    18747   ; #include <stdio.h>
                    18748   ; #include <string.h>
                    18749   ; #include <ctype.h>
                    18750   ; #define TRUE 1
                    18751   ; #define FALSE 0
                    18752   ; #define SUCCESS 1
                    18753   ; #define FAILURE 0
                    18754   ; #define ACK 1
                    18755   ; #define NO_ACK 0
                    18756   ; #define ADC_DAC_DEVICE_ADDR       0x48 // A2, A1, A0 all tied to GND
                    18757   ; /*********************************************************************************************
                    18758   ; **	RS232 port addresses
                    18759   ; *********************************************************************************************/
                    18760   ; #define RS232_Control     *(volatile unsigned char *)(0x00400040)
                    18761   ; #define RS232_Status      *(volatile unsigned char *)(0x00400040)
                    18762   ; #define RS232_TxData      *(volatile unsigned char *)(0x00400042)
                    18763   ; #define RS232_RxData      *(volatile unsigned char *)(0x00400042)
                    18764   ; #define RS232_Baud        *(volatile unsigned char *)(0x00400044)
                    18765   ; /*************************************************************
                    18766   ; ** I2C Controller registers
                    18767   ; **************************************************************/
                    18768   ; #define I2C_PSC_LOW         (*(volatile unsigned char *)(0x00408000))
                    18769   ; #define I2C_PSC_HIGH        (*(volatile unsigned char *)(0x00408002))
                    18770   ; #define I2C_CONTROL         (*(volatile unsigned char *)(0x00408004))
                    18771   ; #define I2C_TX_RX           (*(volatile unsigned char *)(0x00408006))
                    18772   ; #define I2C_CMD_STATUS      (*(volatile unsigned char *)(0x00408008))
                    18773   ; void InitI2C(void)
                    18774   ; {
                    18775   _InitI2C:
                    18776   ; // Prescaler for 100 Khz I2C clock
                    18777   ; // = (25 MHz) / (5 * 100 KHz)  - 1 = 0x0031
                    18778   ; I2C_PSC_LOW = 0x31U;
00006436  13FC 0031 18779          move.b    #49,4227072
0000643A  0040 8000 
                    18780   ; I2C_PSC_HIGH = 0x00U;
0000643E  4239 0040 18781          clr.b     4227074
00006442  8002      
                    18782   ; // Enable I2C core, disable interrupt generation
                    18783   ; I2C_CONTROL = 0x80U;
00006444  13FC 0080 18784          move.b    #128,4227076
00006448  0040 8004 
0000644C  4E75      18785          rts
                    18786   ; }
                    18787   ; void I2C_SetStartBitCommand(unsigned char* cmd_buf)
                    18788   ; {
                    18789   _I2C_SetStartBitCommand:
0000644E  4E56 0000 18790          link      A6,#0
                    18791   ; *cmd_buf |= (0x01U << 7);
00006452  206E 0008 18792          move.l    8(A6),A0
00006456  0010 0080 18793          or.b      #128,(A0)
0000645A  4E5E      18794          unlk      A6
0000645C  4E75      18795          rts
                    18796   ; }
                    18797   ; void I2C_SetStopBitCommand(unsigned char* cmd_buf)
                    18798   ; {
                    18799   _I2C_SetStopBitCommand:
0000645E  4E56 0000 18800          link      A6,#0
                    18801   ; *cmd_buf |= (0x01U << 6);
00006462  206E 0008 18802          move.l    8(A6),A0
00006466  0010 0040 18803          or.b      #64,(A0)
0000646A  4E5E      18804          unlk      A6
0000646C  4E75      18805          rts
                    18806   ; }
                    18807   ; void I2C_SetReadBitCommand(unsigned char* cmd_buf)
                    18808   ; {
                    18809   _I2C_SetReadBitCommand:
0000646E  4E56 0000 18810          link      A6,#0
                    18811   ; *cmd_buf |= (0x01U << 5);
00006472  206E 0008 18812          move.l    8(A6),A0
00006476  0010 0020 18813          or.b      #32,(A0)
0000647A  4E5E      18814          unlk      A6
0000647C  4E75      18815          rts
                    18816   ; }
                    18817   ; void I2C_SetWriteBitCommand(unsigned char* cmd_buf)
                    18818   ; {
                    18819   _I2C_SetWriteBitCommand:
0000647E  4E56 0000 18820          link      A6,#0
                    18821   ; *cmd_buf |= (0x01U << 4);
00006482  206E 0008 18822          move.l    8(A6),A0
00006486  0010 0010 18823          or.b      #16,(A0)
0000648A  4E5E      18824          unlk      A6
0000648C  4E75      18825          rts
                    18826   ; }
                    18827   ; void I2C_SetAckBitCommand(unsigned char* cmd_buf)
                    18828   ; {
                    18829   _I2C_SetAckBitCommand:
0000648E  4E56 0000 18830          link      A6,#0
                    18831   ; *cmd_buf |= (0x01U << 3);
00006492  206E 0008 18832          move.l    8(A6),A0
00006496  0010 0008 18833          or.b      #8,(A0)
0000649A  4E5E      18834          unlk      A6
0000649C  4E75      18835          rts
                    18836   ; }
                    18837   ; void I2C_PerformCommand(unsigned char cmd)
                    18838   ; {
                    18839   _I2C_PerformCommand:
0000649E  4E56 0000 18840          link      A6,#0
                    18841   ; I2C_CMD_STATUS = cmd;
000064A2  13EE 000B 18842          move.b    11(A6),4227080
000064A6  0040 8008 
000064AA  4E5E      18843          unlk      A6
000064AC  4E75      18844          rts
                    18845   ; }
                    18846   ; void I2C_WaitForTransmissionComplete(void)
                    18847   ; {
                    18848   _I2C_WaitForTransmissionComplete:
                    18849   ; // Wait For transfer in progress TIP to be complete
                    18850   ; while(I2C_CMD_STATUS & 0x02U);
                    18851   I2C_WaitForTransmissionComplete_1:
000064AE  1039 0040 18852          move.b    4227080,D0
000064B2  8008      
000064B4  C03C 0002 18853          and.b     #2,D0
000064B8  6702      18854          beq.s     I2C_WaitForTransmissionComplete_3
000064BA  60F2      18855          bra       I2C_WaitForTransmissionComplete_1
                    18856   I2C_WaitForTransmissionComplete_3:
000064BC  4E75      18857          rts
                    18858   ; }
                    18859   ; unsigned char DidDeviceACK(void)
                    18860   ; {
                    18861   _DidDeviceACK:
                    18862   ; return (I2C_CMD_STATUS & 0x80U) ? NO_ACK : ACK;
000064BE  1039 0040 18863          move.b    4227080,D0
000064C2  8008      
000064C4  C03C 0080 18864          and.b     #128,D0
000064C8  6704      18865          beq.s     DidDeviceACK_1
000064CA  4200      18866          clr.b     D0
000064CC  6002      18867          bra.s     DidDeviceACK_2
                    18868   DidDeviceACK_1:
000064CE  7001      18869          moveq     #1,D0
                    18870   DidDeviceACK_2:
000064D0  4E75      18871          rts
                    18872   ; }
                    18873   ; unsigned char I2C_WriteByte(unsigned char data, unsigned char with_start_bit, unsigned char with_stop_bit)
                    18874   ; {
                    18875   _I2C_WriteByte:
000064D2  4E56 FFFC 18876          link      A6,#-4
000064D6  2F0A      18877          move.l    A2,-(A7)
000064D8  45EE FFFF 18878          lea       -1(A6),A2
                    18879   ; unsigned char cmd_buf = 0x00U;
000064DC  4212      18880          clr.b     (A2)
                    18881   ; I2C_TX_RX = data;  // Place data to transmit in transmit register
000064DE  13EE 000B 18882          move.b    11(A6),4227078
000064E2  0040 8006 
                    18883   ; if (with_start_bit)
000064E6  4A2E 000F 18884          tst.b     15(A6)
000064EA  6708      18885          beq.s     I2C_WriteByte_1
                    18886   ; {
                    18887   ; I2C_SetStartBitCommand(&cmd_buf);       // Set START Bit in command register
000064EC  2F0A      18888          move.l    A2,-(A7)
000064EE  4EB8 644E 18889          jsr       _I2C_SetStartBitCommand
000064F2  584F      18890          addq.w    #4,A7
                    18891   I2C_WriteByte_1:
                    18892   ; }
                    18893   ; if (with_stop_bit)
000064F4  4A2E 0013 18894          tst.b     19(A6)
000064F8  6708      18895          beq.s     I2C_WriteByte_3
                    18896   ; {
                    18897   ; I2C_SetStopBitCommand(&cmd_buf);        // Set STOP Bit in command register
000064FA  2F0A      18898          move.l    A2,-(A7)
000064FC  4EB8 645E 18899          jsr       _I2C_SetStopBitCommand
00006500  584F      18900          addq.w    #4,A7
                    18901   I2C_WriteByte_3:
                    18902   ; }
                    18903   ; I2C_SetWriteBitCommand(&cmd_buf);           // Set Write bit in command register
00006502  2F0A      18904          move.l    A2,-(A7)
00006504  4EB8 647E 18905          jsr       _I2C_SetWriteBitCommand
00006508  584F      18906          addq.w    #4,A7
                    18907   ; I2C_PerformCommand(cmd_buf);                // Perform the write command 
0000650A  1212      18908          move.b    (A2),D1
0000650C  C2BC 0000 18909          and.l     #255,D1
00006510  00FF      
00006512  2F01      18910          move.l    D1,-(A7)
00006514  4EB8 649E 18911          jsr       _I2C_PerformCommand
00006518  584F      18912          addq.w    #4,A7
                    18913   ; I2C_WaitForTransmissionComplete();          // Wait for I2C transmission to complete
0000651A  4EB8 64AE 18914          jsr       _I2C_WaitForTransmissionComplete
                    18915   ; return DidDeviceACK();             
0000651E  4EB8 64BE 18916          jsr       _DidDeviceACK
00006522  245F      18917          move.l    (A7)+,A2
00006524  4E5E      18918          unlk      A6
00006526  4E75      18919          rts
                    18920   ; }
                    18921   ; void I2C_ReadByte(unsigned int with_nack, unsigned char with_stop_bit, unsigned char* byte_read)
                    18922   ; {
                    18923   _I2C_ReadByte:
00006528  4E56 FFFC 18924          link      A6,#-4
0000652C  2F0A      18925          move.l    A2,-(A7)
0000652E  45EE FFFF 18926          lea       -1(A6),A2
                    18927   ; unsigned char cmd_buf = 0x00U;
00006532  4212      18928          clr.b     (A2)
                    18929   ; if (with_nack)
00006534  4AAE 0008 18930          tst.l     8(A6)
00006538  6708      18931          beq.s     I2C_ReadByte_1
                    18932   ; {
                    18933   ; I2C_SetAckBitCommand(&cmd_buf); // NOTE: Send NACK after reception of data by setting ACK = â€˜1â€™ 
0000653A  2F0A      18934          move.l    A2,-(A7)
0000653C  4EB8 648E 18935          jsr       _I2C_SetAckBitCommand
00006540  584F      18936          addq.w    #4,A7
                    18937   I2C_ReadByte_1:
                    18938   ; }
                    18939   ; if (with_stop_bit)
00006542  4A2E 000F 18940          tst.b     15(A6)
00006546  6708      18941          beq.s     I2C_ReadByte_3
                    18942   ; {
                    18943   ; I2C_SetStopBitCommand(&cmd_buf); 
00006548  2F0A      18944          move.l    A2,-(A7)
0000654A  4EB8 645E 18945          jsr       _I2C_SetStopBitCommand
0000654E  584F      18946          addq.w    #4,A7
                    18947   I2C_ReadByte_3:
                    18948   ; }
                    18949   ; I2C_SetReadBitCommand(&cmd_buf);
00006550  2F0A      18950          move.l    A2,-(A7)
00006552  4EB8 646E 18951          jsr       _I2C_SetReadBitCommand
00006556  584F      18952          addq.w    #4,A7
                    18953   ; I2C_PerformCommand(cmd_buf);        // Perform read command     
00006558  1212      18954          move.b    (A2),D1
0000655A  C2BC 0000 18955          and.l     #255,D1
0000655E  00FF      
00006560  2F01      18956          move.l    D1,-(A7)
00006562  4EB8 649E 18957          jsr       _I2C_PerformCommand
00006566  584F      18958          addq.w    #4,A7
                    18959   ; I2C_WaitForTransmissionComplete();  
00006568  4EB8 64AE 18960          jsr       _I2C_WaitForTransmissionComplete
                    18961   ; *byte_read = I2C_TX_RX;     // Read valid data from RX register
0000656C  206E 0010 18962          move.l    16(A6),A0
00006570  10B9 0040 18963          move.b    4227078,(A0)
00006574  8006      
00006576  245F      18964          move.l    (A7)+,A2
00006578  4E5E      18965          unlk      A6
0000657A  4E75      18966          rts
                    18967   ; }
                    18968   ; unsigned char I2C_ReadADCChannel(unsigned char adc_channel, unsigned char * adc_val)
                    18969   ; {
                    18970   _I2C_ReadADCChannel:
0000657C  4E56 FFFC 18971          link      A6,#-4
00006580  48E7 3820 18972          movem.l   D2/D3/D4/A2,-(A7)
00006584  45F8 64D2 18973          lea       _I2C_WriteByte.L,A2
                    18974   ; // Prepend R/~W bit to device address.
                    18975   ; unsigned char address_byte_write = ADC_DAC_DEVICE_ADDR << 1;  // Prepend ~W bit to device address.
00006588  183C 0090 18976          move.b    #144,D4
                    18977   ; unsigned char address_byte_read = address_byte_write | 0x01U; // Prepend R bit to device address.
0000658C  1004      18978          move.b    D4,D0
0000658E  803C 0001 18979          or.b      #1,D0
00006592  1D40 FFFF 18980          move.b    D0,-1(A6)
                    18981   ; unsigned char control_byte = 0x00U; 
00006596  4203      18982          clr.b     D3
                    18983   ; unsigned char err = NO_ACK;
00006598  4202      18984          clr.b     D2
                    18985   ; if(adc_channel > 3)
0000659A  102E 000B 18986          move.b    11(A6),D0
0000659E  0C00 0003 18987          cmp.b     #3,D0
000065A2  6310      18988          bls.s     I2C_ReadADCChannel_1
                    18989   ; {
                    18990   ; printf("\r\nMust select ADC channel between 0 and 3");
000065A4  4879 0000 18991          pea       @dac_ad~1_1.L
000065A8  73CC      
000065AA  4EB9 0000 18992          jsr       _printf
000065AE  67BE      
000065B0  584F      18993          addq.w    #4,A7
                    18994   ; while(1);
                    18995   I2C_ReadADCChannel_3:
000065B2  60FE      18996          bra       I2C_ReadADCChannel_3
                    18997   I2C_ReadADCChannel_1:
                    18998   ; }
                    18999   ; else
                    19000   ; {
                    19001   ; control_byte = adc_channel; // Read single-ended ADC channel w/o auto increment, analog output disabled
000065B4  162E 000B 19002          move.b    11(A6),D3
                    19003   ; }
                    19004   ; // Write to control register first
                    19005   ; if (err == I2C_WriteByte(address_byte_write, TRUE, FALSE)) return err; // With start bit
000065B8  42A7      19006          clr.l     -(A7)
000065BA  4878 0001 19007          pea       1
000065BE  C8BC 0000 19008          and.l     #255,D4
000065C2  00FF      
000065C4  2F04      19009          move.l    D4,-(A7)
000065C6  4E92      19010          jsr       (A2)
000065C8  DEFC 000C 19011          add.w     #12,A7
000065CC  B400      19012          cmp.b     D0,D2
000065CE  6606      19013          bne.s     I2C_ReadADCChannel_6
000065D0  1002      19014          move.b    D2,D0
000065D2  6000 0064 19015          bra       I2C_ReadADCChannel_8
                    19016   I2C_ReadADCChannel_6:
                    19017   ; if (err == I2C_WriteByte(control_byte, FALSE, FALSE)) return err;
000065D6  42A7      19018          clr.l     -(A7)
000065D8  42A7      19019          clr.l     -(A7)
000065DA  C6BC 0000 19020          and.l     #255,D3
000065DE  00FF      
000065E0  2F03      19021          move.l    D3,-(A7)
000065E2  4E92      19022          jsr       (A2)
000065E4  DEFC 000C 19023          add.w     #12,A7
000065E8  B400      19024          cmp.b     D0,D2
000065EA  6606      19025          bne.s     I2C_ReadADCChannel_9
000065EC  1002      19026          move.b    D2,D0
000065EE  6000 0048 19027          bra       I2C_ReadADCChannel_8
                    19028   I2C_ReadADCChannel_9:
                    19029   ; // Now request read of ADC conversion
                    19030   ; if (err == I2C_WriteByte(address_byte_read, TRUE, FALSE)) return err; // With repeated start condition
000065F2  42A7      19031          clr.l     -(A7)
000065F4  4878 0001 19032          pea       1
000065F8  122E FFFF 19033          move.b    -1(A6),D1
000065FC  C2BC 0000 19034          and.l     #255,D1
00006600  00FF      
00006602  2F01      19035          move.l    D1,-(A7)
00006604  4E92      19036          jsr       (A2)
00006606  DEFC 000C 19037          add.w     #12,A7
0000660A  B400      19038          cmp.b     D0,D2
0000660C  6604      19039          bne.s     I2C_ReadADCChannel_11
0000660E  1002      19040          move.b    D2,D0
00006610  6026      19041          bra.s     I2C_ReadADCChannel_8
                    19042   I2C_ReadADCChannel_11:
                    19043   ; // Read ADC conversion 
                    19044   ; I2C_ReadByte(FALSE, FALSE, adc_val); // Ignore previously converted byte
00006612  2F2E 000C 19045          move.l    12(A6),-(A7)
00006616  42A7      19046          clr.l     -(A7)
00006618  42A7      19047          clr.l     -(A7)
0000661A  4EB8 6528 19048          jsr       _I2C_ReadByte
0000661E  DEFC 000C 19049          add.w     #12,A7
                    19050   ; I2C_ReadByte(TRUE, TRUE, adc_val);   // With NACK and STOP condition
00006622  2F2E 000C 19051          move.l    12(A6),-(A7)
00006626  4878 0001 19052          pea       1
0000662A  4878 0001 19053          pea       1
0000662E  4EB8 6528 19054          jsr       _I2C_ReadByte
00006632  DEFC 000C 19055          add.w     #12,A7
                    19056   ; return SUCCESS;
00006636  7001      19057          moveq     #1,D0
                    19058   I2C_ReadADCChannel_8:
00006638  4CDF 041C 19059          movem.l   (A7)+,D2/D3/D4/A2
0000663C  4E5E      19060          unlk      A6
0000663E  4E75      19061          rts
                    19062   ; }
                    19063   ULMUL:
00006640  4E56 0000 19064          link    A6,#0
00006644  48E7 C000 19065          movem.l D0/D1,-(A7)
00006648  222E 0008 19066          move.l  8(A6),D1
0000664C  202E 000C 19067          move.l  12(A6),D0
00006650  602C      19068          bra.s   lmul_3
                    19069   LMUL:
00006652  4E56 0000 19070          link    A6,#0
00006656  48E7 C000 19071          movem.l D0/D1,-(A7)
0000665A  222E 0008 19072          move.l  8(A6),D1
0000665E  202E 000C 19073          move.l  12(A6),D0
00006662  4A80      19074          tst.l   D0
00006664  6A0A      19075          bpl.s   lmul_1
00006666  4480      19076          neg.l   D0
00006668  4A81      19077          tst.l   D1
0000666A  6A0A      19078          bpl.s   lmul_2
0000666C  4481      19079          neg.l   D1
0000666E  600E      19080          bra.s   lmul_3
                    19081   lmul_1:
00006670  4A81      19082          tst.l   D1
00006672  6A0A      19083          bpl.s   lmul_3
00006674  4481      19084          neg.l   D1
                    19085   lmul_2:
00006676  6114      19086          bsr.s   domul
00006678  4481      19087          neg.l   D1
0000667A  4080      19088          negx.l  D0
0000667C  6002      19089          bra.s   lmul_4
                    19090   lmul_3:
0000667E  610C      19091          bsr.s   domul
                    19092   lmul_4:
00006680  2D41 0008 19093          move.l  D1,8(A6)
00006684  4CDF 0003 19094          movem.l (A7)+,D0/D1
00006688  4E5E      19095          unlk    A6
0000668A  4E75      19096          rts
                    19097   domul:
0000668C  0C81 0000 19098          cmpi.l  #$FFFF,D1
00006690  FFFF      
00006692  620C      19099          bhi.s   domul_1
00006694  0C80 0000 19100          cmpi.l  #$FFFF,D0
00006698  FFFF      
0000669A  620E      19101          bhi.s   domul_2
0000669C  C2C0      19102          mulu    D0,D1
0000669E  4E75      19103          rts
                    19104   domul_1:
000066A0  0C80 0000 19105          cmpi.l  #$FFFF,D0
000066A4  FFFF      
000066A6  6218      19106          bhi.s   domul_4
000066A8  6002      19107          bra.s   domul_3
                    19108   domul_2
000066AA  C141      19109          exg     D0,D1
                    19110   domul_3:
000066AC  2F02      19111          move.l  D2,-(A7)
000066AE  2401      19112          move.l  D1,D2
000066B0  4842      19113          swap    D2
000066B2  C2C0      19114          mulu    D0,D1
000066B4  C4C0      19115          mulu    D0,D2
000066B6  4842      19116          swap    D2
000066B8  4242      19117          clr.w   D2
000066BA  D282      19118          add.l   D2,D1
000066BC  241F      19119          move.l  (A7)+,D2
000066BE  4E75      19120          rts
                    19121   domul_4:
000066C0  48E7 3000 19122          movem.l D2/D3,-(A7)
000066C4  2401      19123          move.l  D1,D2
000066C6  2601      19124          move.l  D1,D3
000066C8  C2C0      19125          mulu    D0,D1
000066CA  4842      19126          swap    D2
000066CC  C4C0      19127          mulu    D0,D2
000066CE  4840      19128          swap    D0
000066D0  C6C0      19129          mulu    D0,D3
000066D2  D483      19130          add.l   D3,D2
000066D4  4842      19131          swap    D2
000066D6  4242      19132          clr.w   D2
000066D8  D282      19133          add.l   D2,D1
000066DA  4CDF 000C 19134          movem.l (A7)+,D2/D3
000066DE  4E75      19135          rts
                    19136   ULDIV:
000066E0  4E56 0000 19137          link    A6,#0
000066E4  48E7 C000 19138          movem.l D0/D1,-(A7)
000066E8  222E 0008 19139          move.l  8(A6),D1
000066EC  202E 000C 19140          move.l  12(A6),D0
000066F0  6036      19141          bra.s   ldiv_3
                    19142   LDIV:
000066F2  4E56 0000 19143          link    A6,#0
000066F6  48E7 C000 19144          movem.l D0/D1,-(A7)
000066FA  222E 0008 19145          move.l  8(A6),D1
000066FE  202E 000C 19146          move.l  12(A6),D0
00006702  4A80      19147          tst.l   D0
00006704  6A0E      19148          bpl.s   ldiv_1
00006706  4480      19149          neg.l   D0
00006708  4A81      19150          tst.l   D1
0000670A  6A14      19151          bpl.s   ldiv_2
0000670C  4481      19152          neg.l   D1
0000670E  612A      19153          bsr.s   dodiv
00006710  4481      19154          neg.l   D1
00006712  6016      19155          bra.s   ldiv_4
                    19156   ldiv_1:
00006714  4A81      19157          tst.l   D1
00006716  6A10      19158          bpl.s   ldiv_3
00006718  4481      19159          neg.l   D1
0000671A  611E      19160          bsr.s   dodiv
0000671C  4480      19161          neg.l   D0
0000671E  600A      19162          bra.s   ldiv_4
                    19163   ldiv_2:
00006720  6118      19164          bsr.s   dodiv
00006722  4480      19165          neg.l   D0
00006724  4481      19166          neg.l   D1
00006726  6002      19167          bra.s   ldiv_4
                    19168   ldiv_3:
00006728  6110      19169          bsr.s   dodiv
                    19170   ldiv_4:
0000672A  2D40 0008 19171          move.l  D0,8(A6)
0000672E  2D41 000C 19172          move.l  D1,12(A6)
00006732  4CDF 0003 19173          movem.l (A7)+,D0/D1
00006736  4E5E      19174          unlk    A6
00006738  4E75      19175          rts
                    19176   dodiv:
0000673A  0C81 0000 19177          cmpi.l  #$FFFF,D1
0000673E  FFFF      
00006740  6236      19178          bhi.s   dodiv_2
00006742  0C80 0000 19179          cmpi.l  #$FFFF,D0
00006746  FFFF      
00006748  6210      19180          bhi.s   dodiv_1
0000674A  80C1      19181          divu    D1,D0
0000674C  2200      19182          move.l  D0,D1
0000674E  4241      19183          clr.w   D1
00006750  4841      19184          swap    D1
00006752  0280 0000 19185          andi.l  #$FFFF,D0
00006756  FFFF      
00006758  4E75      19186          rts
                    19187   dodiv_1:
0000675A  48A7 A000 19188          movem.w D0/D2,-(A7)
0000675E  4240      19189          clr.w   D0
00006760  4840      19190          swap    D0
00006762  80C1      19191          divu    D1,D0
00006764  3400      19192          move.w  D0,D2
00006766  301F      19193          move.w  (A7)+,D0
00006768  80C1      19194          divu    D1,D0
0000676A  4840      19195          swap    D0
0000676C  4281      19196          clr.l   D1
0000676E  3200      19197          move.w  D0,D1
00006770  3002      19198          move.w  D2,D0
00006772  4840      19199          swap    D0
00006774  341F      19200          move.w  (A7)+,D2
00006776  4E75      19201          rts
                    19202   dodiv_2:
00006778  48E7 3800 19203          movem.l D2/D3/D4,-(A7)
0000677C  2401      19204          move.l  D1,D2
0000677E  4242      19205          clr.w   D2
00006780  4842      19206          swap    D2
00006782  5282      19207          addq.l  #1,D2
00006784  2600      19208          move.l  D0,D3
00006786  2801      19209          move.l  D1,D4
00006788  2202      19210          move.l  D2,D1
0000678A  61CE      19211          bsr.s   dodiv_1
0000678C  2204      19212          move.l  D4,D1
0000678E  82C2      19213          divu    D2,D1
00006790  80C1      19214          divu    D1,D0
00006792  0280 0000 19215          andi.l  #$FFFF,D0
00006796  FFFF      
                    19216   dodiv_3:
00006798  2204      19217          move.l  D4,D1
0000679A  2404      19218          move.l  D4,D2
0000679C  4842      19219          swap    D2
0000679E  C2C0      19220          mulu    D0,D1
000067A0  C4C0      19221          mulu    D0,D2
000067A2  4842      19222          swap    D2
000067A4  D282      19223          add.l   D2,D1
000067A6  9283      19224          sub.l   D3,D1
000067A8  620A      19225          bhi.s   dodiv_4
000067AA  4481      19226          neg.l   D1
000067AC  B881      19227          cmp.l   D1,D4
000067AE  6208      19228          bhi.s   dodiv_5
000067B0  5280      19229          addq.l  #1,D0
000067B2  60E4      19230          bra.s   dodiv_3
                    19231   dodiv_4:
000067B4  5380      19232          subq.l  #1,D0
000067B6  60E0      19233          bra.s   dodiv_3
                    19234   dodiv_5:
000067B8  4CDF 001C 19235          movem.l (A7)+,D2/D3/D4
000067BC  4E75      19236          rts
                    19237   _printf:
000067BE  4E56 FFFC 19238          link      A6,#-4
000067C2  2F02      19239          move.l    D2,-(A7)
000067C4  41EE 0008 19240          lea       8(A6),A0
000067C8  5848      19241          addq.w    #4,A0
000067CA  2408      19242          move.l    A0,D2
000067CC  2F02      19243          move.l    D2,-(A7)
000067CE  2F2E 0008 19244          move.l    8(A6),-(A7)
000067D2  42A7      19245          clr.l     -(A7)
000067D4  4EB9 0000 19246          jsr       _doprint
000067D8  6894      
000067DA  DEFC 000C 19247          add.w     #12,A7
000067DE  2D40 FFFC 19248          move.l    D0,-4(A6)
000067E2  4282      19249          clr.l     D2
000067E4  202E FFFC 19250          move.l    -4(A6),D0
000067E8  241F      19251          move.l    (A7)+,D2
000067EA  4E5E      19252          unlk      A6
000067EC  4E75      19253          rts
                    19254   @doprint_copy:
000067EE  4E56 0000 19255          link      A6,#0
000067F2  206E 0008 19256          move.l    8(A6),A0
000067F6  4A90      19257          tst.l     (A0)
000067F8  6710      19258          beq.s     @doprint_copy_1
000067FA  202E 000C 19259          move.l    12(A6),D0
000067FE  206E 0008 19260          move.l    8(A6),A0
00006802  2250      19261          move.l    (A0),A1
00006804  5290      19262          addq.l    #1,(A0)
00006806  1280      19263          move.b    D0,(A1)
00006808  600C      19264          bra.s     @doprint_copy_2
                    19265   @doprint_copy_1:
0000680A  2F2E 000C 19266          move.l    12(A6),-(A7)
0000680E  4EB9 0000 19267          jsr       _putch
00006812  7034      
00006814  584F      19268          addq.w    #4,A7
                    19269   @doprint_copy_2:
00006816  4E5E      19270          unlk      A6
00006818  4E75      19271          rts
                    19272   @doprint_getval:
0000681A  4E56 0000 19273          link      A6,#0
0000681E  48E7 3000 19274          movem.l   D2/D3,-(A7)
00006822  262E 0008 19275          move.l    8(A6),D3
00006826  4282      19276          clr.l     D2
00006828  2043      19277          move.l    D3,A0
0000682A  2050      19278          move.l    (A0),A0
0000682C  1010      19279          move.b    (A0),D0
0000682E  0C00 002A 19280          cmp.b     #42,D0
00006832  6612      19281          bne.s     @doprint_getval_1
00006834  206E 000C 19282          move.l    12(A6),A0
00006838  2250      19283          move.l    (A0),A1
0000683A  5890      19284          addq.l    #4,(A0)
0000683C  2411      19285          move.l    (A1),D2
0000683E  2043      19286          move.l    D3,A0
00006840  5290      19287          addq.l    #1,(A0)
00006842  6000 0046 19288          bra       @doprint_getval_5
                    19289   @doprint_getval_1:
00006846  7001      19290          moveq     #1,D0
00006848  2043      19291          move.l    D3,A0
0000684A  2050      19292          move.l    (A0),A0
0000684C  1210      19293          move.b    (A0),D1
0000684E  4881      19294          ext.w     D1
00006850  48C1      19295          ext.l     D1
00006852  D081      19296          add.l     D1,D0
00006854  41F9 0000 19297          lea       __ctype.L,A0
00006858  7402      
0000685A  1030 0800 19298          move.b    0(A0,D0.L),D0
0000685E  C03C 0004 19299          and.b     #4,D0
00006862  6726      19300          beq.s     @doprint_getval_5
00006864  2F02      19301          move.l    D2,-(A7)
00006866  4878 000A 19302          pea       10
0000686A  4EB8 6652 19303          jsr       LMUL
0000686E  2017      19304          move.l    (A7),D0
00006870  504F      19305          addq.w    #8,A7
00006872  2043      19306          move.l    D3,A0
00006874  2250      19307          move.l    (A0),A1
00006876  5290      19308          addq.l    #1,(A0)
00006878  1211      19309          move.b    (A1),D1
0000687A  4881      19310          ext.w     D1
0000687C  48C1      19311          ext.l     D1
0000687E  D081      19312          add.l     D1,D0
00006880  0480 0000 19313          sub.l     #48,D0
00006884  0030      
00006886  2400      19314          move.l    D0,D2
00006888  60BC      19315          bra       @doprint_getval_1
                    19316   @doprint_getval_5:
0000688A  2002      19317          move.l    D2,D0
0000688C  4CDF 000C 19318          movem.l   (A7)+,D2/D3
00006890  4E5E      19319          unlk      A6
00006892  4E75      19320          rts
                    19321   _doprint:
00006894  4E56 FFCC 19322          link      A6,#-52
00006898  48E7 3F3C 19323          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
0000689C  45EE 0008 19324          lea       8(A6),A2
000068A0  47F8 67EE 19325          lea       @doprint_copy.L,A3
000068A4  49F9 0000 19326          lea       _ultoa.L,A4
000068A8  6FC0      
000068AA  4286      19327          clr.l     D6
                    19328   doprint_1:
000068AC  206E 000C 19329          move.l    12(A6),A0
000068B0  4A10      19330          tst.b     (A0)
000068B2  6700 05EC 19331          beq       doprint_3
000068B6  206E 000C 19332          move.l    12(A6),A0
000068BA  1010      19333          move.b    (A0),D0
000068BC  0C00 0025 19334          cmp.b     #37,D0
000068C0  671C      19335          beq.s     doprint_4
000068C2  206E 000C 19336          move.l    12(A6),A0
000068C6  52AE 000C 19337          addq.l    #1,12(A6)
000068CA  1210      19338          move.b    (A0),D1
000068CC  4881      19339          ext.w     D1
000068CE  48C1      19340          ext.l     D1
000068D0  2F01      19341          move.l    D1,-(A7)
000068D2  2F0A      19342          move.l    A2,-(A7)
000068D4  4E93      19343          jsr       (A3)
000068D6  504F      19344          addq.w    #8,A7
000068D8  5286      19345          addq.l    #1,D6
000068DA  6000 05C0 19346          bra       doprint_2
                    19347   doprint_4:
000068DE  52AE 000C 19348          addq.l    #1,12(A6)
000068E2  422E FFD3 19349          clr.b     -45(A6)
000068E6  422E FFD2 19350          clr.b     -46(A6)
000068EA  422E FFD0 19351          clr.b     -48(A6)
000068EE  422E FFCF 19352          clr.b     -49(A6)
000068F2  422E FFCE 19353          clr.b     -50(A6)
000068F6  422E FFCD 19354          clr.b     -51(A6)
000068FA  42AE FFFC 19355          clr.l     -4(A6)
000068FE  7AFF      19356          moveq     #-1,D5
00006900  41EE FFDC 19357          lea       -36(A6),A0
00006904  2608      19358          move.l    A0,D3
00006906  2408      19359          move.l    A0,D2
                    19360   doprint_6:
00006908  206E 000C 19361          move.l    12(A6),A0
0000690C  1010      19362          move.b    (A0),D0
0000690E  4880      19363          ext.w     D0
00006910  48C0      19364          ext.l     D0
00006912  0C80 0000 19365          cmp.l     #43,D0
00006916  002B      
00006918  6730      19366          beq.s     doprint_12
0000691A  6E18      19367          bgt.s     doprint_15
0000691C  0C80 0000 19368          cmp.l     #35,D0
00006920  0023      
00006922  6700 003E 19369          beq       doprint_14
00006926  6E00 0046 19370          bgt       doprint_9
0000692A  0C80 0000 19371          cmp.l     #32,D0
0000692E  0020      
00006930  6724      19372          beq.s     doprint_13
00006932  603A      19373          bra.s     doprint_9
                    19374   doprint_15:
00006934  0C80 0000 19375          cmp.l     #45,D0
00006938  002D      
0000693A  6702      19376          beq.s     doprint_11
0000693C  6030      19377          bra.s     doprint_9
                    19378   doprint_11:
0000693E  1D7C 0001 19379          move.b    #1,-51(A6)
00006942  FFCD      
00006944  52AE 000C 19380          addq.l    #1,12(A6)
00006948  6026      19381          bra.s     doprint_7
                    19382   doprint_12:
0000694A  1D7C 0001 19383          move.b    #1,-50(A6)
0000694E  FFCE      
00006950  52AE 000C 19384          addq.l    #1,12(A6)
00006954  601A      19385          bra.s     doprint_7
                    19386   doprint_13:
00006956  1D7C 0001 19387          move.b    #1,-49(A6)
0000695A  FFCF      
0000695C  52AE 000C 19388          addq.l    #1,12(A6)
00006960  600E      19389          bra.s     doprint_7
                    19390   doprint_14:
00006962  1D7C 0001 19391          move.b    #1,-48(A6)
00006966  FFD0      
00006968  52AE 000C 19392          addq.l    #1,12(A6)
0000696C  6002      19393          bra.s     doprint_7
                    19394   doprint_9:
0000696E  6002      19395          bra.s     doprint_8
                    19396   doprint_7:
00006970  6096      19397          bra       doprint_6
                    19398   doprint_8:
00006972  206E 000C 19399          move.l    12(A6),A0
00006976  1010      19400          move.b    (A0),D0
00006978  0C00 0030 19401          cmp.b     #48,D0
0000697C  660A      19402          bne.s     doprint_16
0000697E  52AE 000C 19403          addq.l    #1,12(A6)
00006982  1D7C 0001 19404          move.b    #1,-46(A6)
00006986  FFD2      
                    19405   doprint_16:
00006988  486E 0010 19406          pea       16(A6)
0000698C  486E 000C 19407          pea       12(A6)
00006990  4EB8 681A 19408          jsr       @doprint_getval
00006994  504F      19409          addq.w    #8,A7
00006996  2A40      19410          move.l    D0,A5
00006998  206E 000C 19411          move.l    12(A6),A0
0000699C  1010      19412          move.b    (A0),D0
0000699E  0C00 002E 19413          cmp.b     #46,D0
000069A2  6614      19414          bne.s     doprint_18
000069A4  52AE 000C 19415          addq.l    #1,12(A6)
000069A8  486E 0010 19416          pea       16(A6)
000069AC  486E 000C 19417          pea       12(A6)
000069B0  4EB8 681A 19418          jsr       @doprint_getval
000069B4  504F      19419          addq.w    #8,A7
000069B6  2A00      19420          move.l    D0,D5
                    19421   doprint_18:
000069B8  206E 000C 19422          move.l    12(A6),A0
000069BC  1010      19423          move.b    (A0),D0
000069BE  0C00 006C 19424          cmp.b     #108,D0
000069C2  660A      19425          bne.s     doprint_20
000069C4  52AE 000C 19426          addq.l    #1,12(A6)
000069C8  1D7C 0001 19427          move.b    #1,-45(A6)
000069CC  FFD3      
                    19428   doprint_20:
000069CE  206E 000C 19429          move.l    12(A6),A0
000069D2  1010      19430          move.b    (A0),D0
000069D4  4880      19431          ext.w     D0
000069D6  48C0      19432          ext.l     D0
000069D8  0C80 0000 19433          cmp.l     #111,D0
000069DC  006F      
000069DE  6700 00D8 19434          beq       doprint_27
000069E2  6E34      19435          bgt.s     doprint_33
000069E4  0C80 0000 19436          cmp.l     #100,D0
000069E8  0064      
000069EA  6700 0054 19437          beq       doprint_24
000069EE  6E1C      19438          bgt.s     doprint_34
000069F0  0C80 0000 19439          cmp.l     #99,D0
000069F4  0063      
000069F6  6700 0130 19440          beq       doprint_30
000069FA  6E00 0174 19441          bgt       doprint_22
000069FE  0C80 0000 19442          cmp.l     #88,D0
00006A02  0058      
00006A04  6700 00EA 19443          beq       doprint_28
00006A08  6000 0166 19444          bra       doprint_22
                    19445   doprint_34:
00006A0C  0C80 0000 19446          cmp.l     #105,D0
00006A10  0069      
00006A12  672C      19447          beq.s     doprint_24
00006A14  6000 015A 19448          bra       doprint_22
                    19449   doprint_33:
00006A18  0C80 0000 19450          cmp.l     #117,D0
00006A1C  0075      
00006A1E  6700 0060 19451          beq       doprint_26
00006A22  6E0E      19452          bgt.s     doprint_35
00006A24  0C80 0000 19453          cmp.l     #115,D0
00006A28  0073      
00006A2A  6700 0124 19454          beq       doprint_31
00006A2E  6000 0140 19455          bra       doprint_22
                    19456   doprint_35:
00006A32  0C80 0000 19457          cmp.l     #120,D0
00006A36  0078      
00006A38  6700 00B6 19458          beq       doprint_28
00006A3C  6000 0132 19459          bra       doprint_22
                    19460   doprint_24:
00006A40  4A2E FFD3 19461          tst.b     -45(A6)
00006A44  671C      19462          beq.s     doprint_36
00006A46  4878 000A 19463          pea       10
00006A4A  2F03      19464          move.l    D3,-(A7)
00006A4C  206E 0010 19465          move.l    16(A6),A0
00006A50  58AE 0010 19466          addq.l    #4,16(A6)
00006A54  2F10      19467          move.l    (A0),-(A7)
00006A56  4EB9 0000 19468          jsr       _ltoa
00006A5A  6F3A      
00006A5C  DEFC 000C 19469          add.w     #12,A7
00006A60  601A      19470          bra.s     doprint_37
                    19471   doprint_36:
00006A62  4878 000A 19472          pea       10
00006A66  2F03      19473          move.l    D3,-(A7)
00006A68  206E 0010 19474          move.l    16(A6),A0
00006A6C  58AE 0010 19475          addq.l    #4,16(A6)
00006A70  2F10      19476          move.l    (A0),-(A7)
00006A72  4EB9 0000 19477          jsr       _ltoa
00006A76  6F3A      
00006A78  DEFC 000C 19478          add.w     #12,A7
                    19479   doprint_37:
00006A7C  6000 0100 19480          bra       doprint_23
                    19481   doprint_26:
00006A80  4A2E FFD3 19482          tst.b     -45(A6)
00006A84  6718      19483          beq.s     doprint_38
00006A86  4878 000A 19484          pea       10
00006A8A  2F03      19485          move.l    D3,-(A7)
00006A8C  206E 0010 19486          move.l    16(A6),A0
00006A90  58AE 0010 19487          addq.l    #4,16(A6)
00006A94  2F10      19488          move.l    (A0),-(A7)
00006A96  4E94      19489          jsr       (A4)
00006A98  DEFC 000C 19490          add.w     #12,A7
00006A9C  6016      19491          bra.s     doprint_39
                    19492   doprint_38:
00006A9E  4878 000A 19493          pea       10
00006AA2  2F03      19494          move.l    D3,-(A7)
00006AA4  206E 0010 19495          move.l    16(A6),A0
00006AA8  58AE 0010 19496          addq.l    #4,16(A6)
00006AAC  2F10      19497          move.l    (A0),-(A7)
00006AAE  4E94      19498          jsr       (A4)
00006AB0  DEFC 000C 19499          add.w     #12,A7
                    19500   doprint_39:
00006AB4  6000 00C8 19501          bra       doprint_23
                    19502   doprint_27:
00006AB8  4A2E FFD3 19503          tst.b     -45(A6)
00006ABC  6718      19504          beq.s     doprint_40
00006ABE  4878 0008 19505          pea       8
00006AC2  2F03      19506          move.l    D3,-(A7)
00006AC4  206E 0010 19507          move.l    16(A6),A0
00006AC8  58AE 0010 19508          addq.l    #4,16(A6)
00006ACC  2F10      19509          move.l    (A0),-(A7)
00006ACE  4E94      19510          jsr       (A4)
00006AD0  DEFC 000C 19511          add.w     #12,A7
00006AD4  6016      19512          bra.s     doprint_41
                    19513   doprint_40:
00006AD6  4878 0008 19514          pea       8
00006ADA  2F03      19515          move.l    D3,-(A7)
00006ADC  206E 0010 19516          move.l    16(A6),A0
00006AE0  58AE 0010 19517          addq.l    #4,16(A6)
00006AE4  2F10      19518          move.l    (A0),-(A7)
00006AE6  4E94      19519          jsr       (A4)
00006AE8  DEFC 000C 19520          add.w     #12,A7
                    19521   doprint_41:
00006AEC  6000 0090 19522          bra       doprint_23
                    19523   doprint_28:
00006AF0  4A2E FFD3 19524          tst.b     -45(A6)
00006AF4  6718      19525          beq.s     doprint_42
00006AF6  4878 0010 19526          pea       16
00006AFA  2F03      19527          move.l    D3,-(A7)
00006AFC  206E 0010 19528          move.l    16(A6),A0
00006B00  58AE 0010 19529          addq.l    #4,16(A6)
00006B04  2F10      19530          move.l    (A0),-(A7)
00006B06  4E94      19531          jsr       (A4)
00006B08  DEFC 000C 19532          add.w     #12,A7
00006B0C  6016      19533          bra.s     doprint_43
                    19534   doprint_42:
00006B0E  4878 0010 19535          pea       16
00006B12  2F03      19536          move.l    D3,-(A7)
00006B14  206E 0010 19537          move.l    16(A6),A0
00006B18  58AE 0010 19538          addq.l    #4,16(A6)
00006B1C  2F10      19539          move.l    (A0),-(A7)
00006B1E  4E94      19540          jsr       (A4)
00006B20  DEFC 000C 19541          add.w     #12,A7
                    19542   doprint_43:
00006B24  6000 0058 19543          bra       doprint_23
                    19544   doprint_30:
00006B28  206E 0010 19545          move.l    16(A6),A0
00006B2C  58AE 0010 19546          addq.l    #4,16(A6)
00006B30  2010      19547          move.l    (A0),D0
00006B32  2042      19548          move.l    D2,A0
00006B34  5282      19549          addq.l    #1,D2
00006B36  1080      19550          move.b    D0,(A0)
00006B38  2042      19551          move.l    D2,A0
00006B3A  4210      19552          clr.b     (A0)
00006B3C  200D      19553          move.l    A5,D0
00006B3E  6704      19554          beq.s     doprint_44
00006B40  200D      19555          move.l    A5,D0
00006B42  6006      19556          bra.s     doprint_45
                    19557   doprint_44:
00006B44  7001      19558          moveq     #1,D0
00006B46  4880      19559          ext.w     D0
00006B48  48C0      19560          ext.l     D0
                    19561   doprint_45:
00006B4A  2A00      19562          move.l    D0,D5
00006B4C  6000 0030 19563          bra       doprint_23
                    19564   doprint_31:
00006B50  206E 0010 19565          move.l    16(A6),A0
00006B54  58AE 0010 19566          addq.l    #4,16(A6)
00006B58  2610      19567          move.l    (A0),D3
00006B5A  0C85 FFFF 19568          cmp.l     #-1,D5
00006B5E  FFFF      
00006B60  660C      19569          bne.s     doprint_46
00006B62  2F03      19570          move.l    D3,-(A7)
00006B64  4EB9 0000 19571          jsr       _strlen
00006B68  7022      
00006B6A  584F      19572          addq.w    #4,A7
00006B6C  2A00      19573          move.l    D0,D5
                    19574   doprint_46:
00006B6E  600E      19575          bra.s     doprint_23
                    19576   doprint_22:
00006B70  206E 000C 19577          move.l    12(A6),A0
00006B74  2242      19578          move.l    D2,A1
00006B76  5282      19579          addq.l    #1,D2
00006B78  1290      19580          move.b    (A0),(A1)
00006B7A  2042      19581          move.l    D2,A0
00006B7C  4210      19582          clr.b     (A0)
                    19583   doprint_23:
00006B7E  2F03      19584          move.l    D3,-(A7)
00006B80  4EB9 0000 19585          jsr       _strlen
00006B84  7022      
00006B86  584F      19586          addq.w    #4,A7
00006B88  1800      19587          move.b    D0,D4
00006B8A  206E 000C 19588          move.l    12(A6),A0
00006B8E  1010      19589          move.b    (A0),D0
00006B90  0C00 0073 19590          cmp.b     #115,D0
00006B94  661C      19591          bne.s     doprint_48
00006B96  0C85 0000 19592          cmp.l     #0,D5
00006B9A  0000      
00006B9C  6D14      19593          blt.s     doprint_48
00006B9E  4884      19594          ext.w     D4
00006BA0  48C4      19595          ext.l     D4
00006BA2  B885      19596          cmp.l     D5,D4
00006BA4  6F04      19597          ble.s     doprint_50
00006BA6  2005      19598          move.l    D5,D0
00006BA8  6006      19599          bra.s     doprint_51
                    19600   doprint_50:
00006BAA  1004      19601          move.b    D4,D0
00006BAC  4880      19602          ext.w     D0
00006BAE  48C0      19603          ext.l     D0
                    19604   doprint_51:
00006BB0  1800      19605          move.b    D0,D4
                    19606   doprint_48:
00006BB2  206E 000C 19607          move.l    12(A6),A0
00006BB6  1010      19608          move.b    (A0),D0
00006BB8  0C00 0058 19609          cmp.b     #88,D0
00006BBC  6600 0028 19610          bne       doprint_56
00006BC0  41EE FFDC 19611          lea       -36(A6),A0
00006BC4  2408      19612          move.l    A0,D2
                    19613   doprint_54:
00006BC6  2042      19614          move.l    D2,A0
00006BC8  4A10      19615          tst.b     (A0)
00006BCA  671A      19616          beq.s     doprint_56
00006BCC  2042      19617          move.l    D2,A0
00006BCE  1210      19618          move.b    (A0),D1
00006BD0  4881      19619          ext.w     D1
00006BD2  48C1      19620          ext.l     D1
00006BD4  2F01      19621          move.l    D1,-(A7)
00006BD6  4EB9 0000 19622          jsr       _toupper
00006BDA  7060      
00006BDC  584F      19623          addq.w    #4,A7
00006BDE  2042      19624          move.l    D2,A0
00006BE0  1080      19625          move.b    D0,(A0)
00006BE2  5282      19626          addq.l    #1,D2
00006BE4  60E0      19627          bra       doprint_54
                    19628   doprint_56:
00006BE6  7E00      19629          moveq     #0,D7
00006BE8  41EE FFD4 19630          lea       -44(A6),A0
00006BEC  2408      19631          move.l    A0,D2
00006BEE  206E 000C 19632          move.l    12(A6),A0
00006BF2  1010      19633          move.b    (A0),D0
00006BF4  0C00 0064 19634          cmp.b     #100,D0
00006BF8  670E      19635          beq.s     doprint_59
00006BFA  206E 000C 19636          move.l    12(A6),A0
00006BFE  1010      19637          move.b    (A0),D0
00006C00  0C00 0069 19638          cmp.b     #105,D0
00006C04  6600 0068 19639          bne       doprint_65
                    19640   doprint_59:
00006C08  102E FFCE 19641          move.b    -50(A6),D0
00006C0C  4880      19642          ext.w     D0
00006C0E  48C0      19643          ext.l     D0
00006C10  4A80      19644          tst.l     D0
00006C12  660C      19645          bne.s     doprint_62
00006C14  2043      19646          move.l    D3,A0
00006C16  1010      19647          move.b    (A0),D0
00006C18  0C00 002D 19648          cmp.b     #45,D0
00006C1C  6600 0028 19649          bne       doprint_60
                    19650   doprint_62:
00006C20  2043      19651          move.l    D3,A0
00006C22  1010      19652          move.b    (A0),D0
00006C24  0C00 002D 19653          cmp.b     #45,D0
00006C28  660E      19654          bne.s     doprint_63
00006C2A  2043      19655          move.l    D3,A0
00006C2C  5283      19656          addq.l    #1,D3
00006C2E  2242      19657          move.l    D2,A1
00006C30  5282      19658          addq.l    #1,D2
00006C32  1290      19659          move.b    (A0),(A1)
00006C34  5304      19660          subq.b    #1,D4
00006C36  6008      19661          bra.s     doprint_64
                    19662   doprint_63:
00006C38  2042      19663          move.l    D2,A0
00006C3A  5282      19664          addq.l    #1,D2
00006C3C  10BC 002B 19665          move.b    #43,(A0)
                    19666   doprint_64:
00006C40  5287      19667          addq.l    #1,D7
00006C42  6000 002A 19668          bra       doprint_65
                    19669   doprint_60:
00006C46  4A2E FFCF 19670          tst.b     -49(A6)
00006C4A  6722      19671          beq.s     doprint_65
00006C4C  2043      19672          move.l    D3,A0
00006C4E  1010      19673          move.b    (A0),D0
00006C50  0C00 002D 19674          cmp.b     #45,D0
00006C54  660E      19675          bne.s     doprint_67
00006C56  2043      19676          move.l    D3,A0
00006C58  5283      19677          addq.l    #1,D3
00006C5A  2242      19678          move.l    D2,A1
00006C5C  5282      19679          addq.l    #1,D2
00006C5E  1290      19680          move.b    (A0),(A1)
00006C60  5304      19681          subq.b    #1,D4
00006C62  6008      19682          bra.s     doprint_68
                    19683   doprint_67:
00006C64  2042      19684          move.l    D2,A0
00006C66  5282      19685          addq.l    #1,D2
00006C68  10BC 0020 19686          move.b    #32,(A0)
                    19687   doprint_68:
00006C6C  5287      19688          addq.l    #1,D7
                    19689   doprint_65:
00006C6E  4A2E FFD0 19690          tst.b     -48(A6)
00006C72  6700 005A 19691          beq       doprint_77
00006C76  206E 000C 19692          move.l    12(A6),A0
00006C7A  1010      19693          move.b    (A0),D0
00006C7C  4880      19694          ext.w     D0
00006C7E  48C0      19695          ext.l     D0
00006C80  0C80 0000 19696          cmp.l     #111,D0
00006C84  006F      
00006C86  671A      19697          beq.s     doprint_73
00006C88  6E0C      19698          bgt.s     doprint_76
00006C8A  0C80 0000 19699          cmp.l     #88,D0
00006C8E  0058      
00006C90  6710      19700          beq.s     doprint_73
00006C92  6000 003A 19701          bra       doprint_77
                    19702   doprint_76:
00006C96  0C80 0000 19703          cmp.l     #120,D0
00006C9A  0078      
00006C9C  6704      19704          beq.s     doprint_73
00006C9E  6000 002E 19705          bra       doprint_77
                    19706   doprint_73:
00006CA2  2042      19707          move.l    D2,A0
00006CA4  5282      19708          addq.l    #1,D2
00006CA6  10BC 0030 19709          move.b    #48,(A0)
00006CAA  5287      19710          addq.l    #1,D7
00006CAC  206E 000C 19711          move.l    12(A6),A0
00006CB0  1010      19712          move.b    (A0),D0
00006CB2  0C00 0078 19713          cmp.b     #120,D0
00006CB6  670C      19714          beq.s     doprint_79
00006CB8  206E 000C 19715          move.l    12(A6),A0
00006CBC  1010      19716          move.b    (A0),D0
00006CBE  0C00 0058 19717          cmp.b     #88,D0
00006CC2  660A      19718          bne.s     doprint_77
                    19719   doprint_79:
00006CC4  2042      19720          move.l    D2,A0
00006CC6  5282      19721          addq.l    #1,D2
00006CC8  10BC 0078 19722          move.b    #120,(A0)
00006CCC  5287      19723          addq.l    #1,D7
                    19724   doprint_77:
00006CCE  2042      19725          move.l    D2,A0
00006CD0  4210      19726          clr.b     (A0)
00006CD2  206E 000C 19727          move.l    12(A6),A0
00006CD6  1010      19728          move.b    (A0),D0
00006CD8  4880      19729          ext.w     D0
00006CDA  48C0      19730          ext.l     D0
00006CDC  0C80 0000 19731          cmp.l     #105,D0
00006CE0  0069      
00006CE2  6700 0076 19732          beq       doprint_82
00006CE6  6E42      19733          bgt.s     doprint_93
00006CE8  0C80 0000 19734          cmp.l     #99,D0
00006CEC  0063      
00006CEE  6700 0084 19735          beq       doprint_96
00006CF2  6E1C      19736          bgt.s     doprint_94
00006CF4  0C80 0000 19737          cmp.l     #88,D0
00006CF8  0058      
00006CFA  6700 005E 19738          beq       doprint_82
00006CFE  6E00 0184 19739          bgt       doprint_80
00006D02  0C80 0000 19740          cmp.l     #69,D0
00006D06  0045      
00006D08  6700 0050 19741          beq       doprint_82
00006D0C  6000 0176 19742          bra       doprint_80
                    19743   doprint_94:
00006D10  0C80 0000 19744          cmp.l     #101,D0
00006D14  0065      
00006D16  6700 0042 19745          beq       doprint_82
00006D1A  6E00 0168 19746          bgt       doprint_80
00006D1E  0C80 0000 19747          cmp.l     #100,D0
00006D22  0064      
00006D24  6734      19748          beq.s     doprint_82
00006D26  6000 015C 19749          bra       doprint_80
                    19750   doprint_93:
00006D2A  0C80 0000 19751          cmp.l     #117,D0
00006D2E  0075      
00006D30  6728      19752          beq.s     doprint_82
00006D32  6E1A      19753          bgt.s     doprint_95
00006D34  0C80 0000 19754          cmp.l     #115,D0
00006D38  0073      
00006D3A  6700 0038 19755          beq       doprint_96
00006D3E  6E00 0144 19756          bgt       doprint_80
00006D42  0C80 0000 19757          cmp.l     #111,D0
00006D46  006F      
00006D48  6710      19758          beq.s     doprint_82
00006D4A  6000 0138 19759          bra       doprint_80
                    19760   doprint_95:
00006D4E  0C80 0000 19761          cmp.l     #120,D0
00006D52  0078      
00006D54  6704      19762          beq.s     doprint_82
00006D56  6000 012C 19763          bra       doprint_80
                    19764   doprint_82:
00006D5A  4A2E FFD2 19765          tst.b     -46(A6)
00006D5E  6714      19766          beq.s     doprint_96
00006D60  4A2E FFCD 19767          tst.b     -51(A6)
00006D64  660E      19768          bne.s     doprint_96
00006D66  200D      19769          move.l    A5,D0
00006D68  9087      19770          sub.l     D7,D0
00006D6A  4884      19771          ext.w     D4
00006D6C  48C4      19772          ext.l     D4
00006D6E  9084      19773          sub.l     D4,D0
00006D70  2D40 FFFC 19774          move.l    D0,-4(A6)
                    19775   doprint_96:
00006D74  202E FFFC 19776          move.l    -4(A6),D0
00006D78  0C80 0000 19777          cmp.l     #0,D0
00006D7C  0000      
00006D7E  6C04      19778          bge.s     doprint_98
00006D80  42AE FFFC 19779          clr.l     -4(A6)
                    19780   doprint_98:
00006D84  4A2E FFCD 19781          tst.b     -51(A6)
00006D88  6600 0030 19782          bne       doprint_104
00006D8C  1004      19783          move.b    D4,D0
00006D8E  4880      19784          ext.w     D0
00006D90  48C0      19785          ext.l     D0
00006D92  D0AE FFFC 19786          add.l     -4(A6),D0
00006D96  D087      19787          add.l     D7,D0
00006D98  1D40 FFD1 19788          move.b    D0,-47(A6)
                    19789   doprint_102:
00006D9C  102E FFD1 19790          move.b    -47(A6),D0
00006DA0  4880      19791          ext.w     D0
00006DA2  48C0      19792          ext.l     D0
00006DA4  220D      19793          move.l    A5,D1
00006DA6  534D      19794          subq.w    #1,A5
00006DA8  B081      19795          cmp.l     D1,D0
00006DAA  6C0E      19796          bge.s     doprint_104
00006DAC  4878 0020 19797          pea       32
00006DB0  2F0A      19798          move.l    A2,-(A7)
00006DB2  4E93      19799          jsr       (A3)
00006DB4  504F      19800          addq.w    #8,A7
00006DB6  5286      19801          addq.l    #1,D6
00006DB8  60E2      19802          bra       doprint_102
                    19803   doprint_104:
00006DBA  41EE FFD4 19804          lea       -44(A6),A0
00006DBE  2408      19805          move.l    A0,D2
                    19806   doprint_105:
00006DC0  2042      19807          move.l    D2,A0
00006DC2  4A10      19808          tst.b     (A0)
00006DC4  6716      19809          beq.s     doprint_107
00006DC6  2042      19810          move.l    D2,A0
00006DC8  5282      19811          addq.l    #1,D2
00006DCA  1210      19812          move.b    (A0),D1
00006DCC  4881      19813          ext.w     D1
00006DCE  48C1      19814          ext.l     D1
00006DD0  2F01      19815          move.l    D1,-(A7)
00006DD2  2F0A      19816          move.l    A2,-(A7)
00006DD4  4E93      19817          jsr       (A3)
00006DD6  504F      19818          addq.w    #8,A7
00006DD8  5286      19819          addq.l    #1,D6
00006DDA  60E4      19820          bra       doprint_105
                    19821   doprint_107:
00006DDC  202E FFFC 19822          move.l    -4(A6),D0
00006DE0  1D40 FFD1 19823          move.b    D0,-47(A6)
                    19824   doprint_108:
00006DE4  102E FFD1 19825          move.b    -47(A6),D0
00006DE8  532E FFD1 19826          subq.b    #1,-47(A6)
00006DEC  4A00      19827          tst.b     D0
00006DEE  670E      19828          beq.s     doprint_110
00006DF0  4878 0030 19829          pea       48
00006DF4  2F0A      19830          move.l    A2,-(A7)
00006DF6  4E93      19831          jsr       (A3)
00006DF8  504F      19832          addq.w    #8,A7
00006DFA  5286      19833          addq.l    #1,D6
00006DFC  60E6      19834          bra       doprint_108
                    19835   doprint_110:
00006DFE  2043      19836          move.l    D3,A0
00006E00  4A10      19837          tst.b     (A0)
00006E02  6700 0048 19838          beq       doprint_113
00006E06  206E 000C 19839          move.l    12(A6),A0
00006E0A  1010      19840          move.b    (A0),D0
00006E0C  4880      19841          ext.w     D0
00006E0E  48C0      19842          ext.l     D0
00006E10  0C80 0000 19843          cmp.l     #115,D0
00006E14  0073      
00006E16  670C      19844          beq.s     doprint_116
00006E18  6E18      19845          bgt.s     doprint_119
00006E1A  0C80 0000 19846          cmp.l     #99,D0
00006E1E  0063      
00006E20  6702      19847          beq.s     doprint_116
00006E22  600E      19848          bra.s     doprint_119
                    19849   doprint_116:
00006E24  2005      19850          move.l    D5,D0
00006E26  5385      19851          subq.l    #1,D5
00006E28  0C80 0000 19852          cmp.l     #0,D0
00006E2C  0000      
00006E2E  6E02      19853          bgt.s     doprint_119
00006E30  6016      19854          bra.s     doprint_115
                    19855   doprint_119:
00006E32  2043      19856          move.l    D3,A0
00006E34  5283      19857          addq.l    #1,D3
00006E36  1210      19858          move.b    (A0),D1
00006E38  4881      19859          ext.w     D1
00006E3A  48C1      19860          ext.l     D1
00006E3C  2F01      19861          move.l    D1,-(A7)
00006E3E  2F0A      19862          move.l    A2,-(A7)
00006E40  4E93      19863          jsr       (A3)
00006E42  504F      19864          addq.w    #8,A7
00006E44  5286      19865          addq.l    #1,D6
00006E46  6002      19866          bra.s     doprint_112
                    19867   doprint_115:
00006E48  6002      19868          bra.s     doprint_113
                    19869   doprint_112:
00006E4A  60B2      19870          bra       doprint_110
                    19871   doprint_113:
00006E4C  4A2E FFCD 19872          tst.b     -51(A6)
00006E50  6700 0030 19873          beq       doprint_125
00006E54  1004      19874          move.b    D4,D0
00006E56  4880      19875          ext.w     D0
00006E58  48C0      19876          ext.l     D0
00006E5A  D0AE FFFC 19877          add.l     -4(A6),D0
00006E5E  D087      19878          add.l     D7,D0
00006E60  1D40 FFD1 19879          move.b    D0,-47(A6)
                    19880   doprint_123:
00006E64  102E FFD1 19881          move.b    -47(A6),D0
00006E68  4880      19882          ext.w     D0
00006E6A  48C0      19883          ext.l     D0
00006E6C  220D      19884          move.l    A5,D1
00006E6E  534D      19885          subq.w    #1,A5
00006E70  B081      19886          cmp.l     D1,D0
00006E72  6C0E      19887          bge.s     doprint_125
00006E74  4878 0020 19888          pea       32
00006E78  2F0A      19889          move.l    A2,-(A7)
00006E7A  4E93      19890          jsr       (A3)
00006E7C  504F      19891          addq.w    #8,A7
00006E7E  5386      19892          subq.l    #1,D6
00006E80  60E2      19893          bra       doprint_123
                    19894   doprint_125:
00006E82  6014      19895          bra.s     doprint_81
                    19896   doprint_80:
00006E84  206E 000C 19897          move.l    12(A6),A0
00006E88  1210      19898          move.b    (A0),D1
00006E8A  4881      19899          ext.w     D1
00006E8C  48C1      19900          ext.l     D1
00006E8E  2F01      19901          move.l    D1,-(A7)
00006E90  2F0A      19902          move.l    A2,-(A7)
00006E92  4E93      19903          jsr       (A3)
00006E94  504F      19904          addq.w    #8,A7
00006E96  5286      19905          addq.l    #1,D6
                    19906   doprint_81:
00006E98  52AE 000C 19907          addq.l    #1,12(A6)
                    19908   doprint_2:
00006E9C  6000 FA0E 19909          bra       doprint_1
                    19910   doprint_3:
00006EA0  4A92      19911          tst.l     (A2)
00006EA2  6710      19912          beq.s     doprint_126
00006EA4  4201      19913          clr.b     D1
00006EA6  C2BC 0000 19914          and.l     #255,D1
00006EAA  00FF      
00006EAC  2F01      19915          move.l    D1,-(A7)
00006EAE  2F0A      19916          move.l    A2,-(A7)
00006EB0  4E93      19917          jsr       (A3)
00006EB2  504F      19918          addq.w    #8,A7
                    19919   doprint_126:
00006EB4  2006      19920          move.l    D6,D0
00006EB6  4CDF 3CFC 19921          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00006EBA  4E5E      19922          unlk      A6
00006EBC  4E75      19923          rts
                    19924   @itoa_convert:
00006EBE  4E56 0000 19925          link      A6,#0
00006EC2  48E7 3C00 19926          movem.l   D2/D3/D4/D5,-(A7)
00006EC6  242E 0008 19927          move.l    8(A6),D2
00006ECA  262E 0010 19928          move.l    16(A6),D3
00006ECE  2A2E 000C 19929          move.l    12(A6),D5
00006ED2  2F05      19930          move.l    D5,-(A7)
00006ED4  2F03      19931          move.l    D3,-(A7)
00006ED6  4EB8 66E0 19932          jsr       ULDIV
00006EDA  202F 0004 19933          move.l    4(A7),D0
00006EDE  504F      19934          addq.w    #8,A7
00006EE0  2800      19935          move.l    D0,D4
00006EE2  BA83      19936          cmp.l     D3,D5
00006EE4  651C      19937          blo.s     @itoa_convert_1
00006EE6  2F03      19938          move.l    D3,-(A7)
00006EE8  2F05      19939          move.l    D5,-(A7)
00006EEA  2F03      19940          move.l    D3,-(A7)
00006EEC  4EB8 66E0 19941          jsr       ULDIV
00006EF0  2217      19942          move.l    (A7),D1
00006EF2  504F      19943          addq.w    #8,A7
00006EF4  2F01      19944          move.l    D1,-(A7)
00006EF6  2F02      19945          move.l    D2,-(A7)
00006EF8  4EB8 6EBE 19946          jsr       @itoa_convert
00006EFC  DEFC 000C 19947          add.w     #12,A7
00006F00  2400      19948          move.l    D0,D2
                    19949   @itoa_convert_1:
00006F02  0C84 0000 19950          cmp.l     #9,D4
00006F06  0009      
00006F08  6E0E      19951          bgt.s     @itoa_convert_3
00006F0A  2004      19952          move.l    D4,D0
00006F0C  7230      19953          moveq     #48,D1
00006F0E  C2BC 0000 19954          and.l     #255,D1
00006F12  00FF      
00006F14  D081      19955          add.l     D1,D0
00006F16  6012      19956          bra.s     @itoa_convert_4
                    19957   @itoa_convert_3:
00006F18  2004      19958          move.l    D4,D0
00006F1A  7261      19959          moveq     #97,D1
00006F1C  C2BC 0000 19960          and.l     #255,D1
00006F20  00FF      
00006F22  D081      19961          add.l     D1,D0
00006F24  0480 0000 19962          sub.l     #10,D0
00006F28  000A      
                    19963   @itoa_convert_4:
00006F2A  2042      19964          move.l    D2,A0
00006F2C  1080      19965          move.b    D0,(A0)
00006F2E  2002      19966          move.l    D2,D0
00006F30  5280      19967          addq.l    #1,D0
00006F32  4CDF 003C 19968          movem.l   (A7)+,D2/D3/D4/D5
00006F36  4E5E      19969          unlk      A6
00006F38  4E75      19970          rts
                    19971   _ltoa:
00006F3A  4E56 0000 19972          link      A6,#0
00006F3E  48E7 3C00 19973          movem.l   D2/D3/D4/D5,-(A7)
00006F42  242E 0008 19974          move.l    8(A6),D2
00006F46  262E 000C 19975          move.l    12(A6),D3
00006F4A  2A2E 0010 19976          move.l    16(A6),D5
00006F4E  2803      19977          move.l    D3,D4
00006F50  0C85 0000 19978          cmp.l     #2,D5
00006F54  0002      
00006F56  6D08      19979          blt.s     ltoa_3
00006F58  0C85 0000 19980          cmp.l     #36,D5
00006F5C  0024      
00006F5E  6F06      19981          ble.s     ltoa_1
                    19982   ltoa_3:
00006F60  2003      19983          move.l    D3,D0
00006F62  6000 0054 19984          bra       ltoa_4
                    19985   ltoa_1:
00006F66  0C85 0000 19986          cmp.l     #10,D5
00006F6A  000A      
00006F6C  6600 0034 19987          bne       ltoa_5
00006F70  0C82 0000 19988          cmp.l     #0,D2
00006F74  0000      
00006F76  6C2A      19989          bge.s     ltoa_5
00006F78  2002      19990          move.l    D2,D0
00006F7A  4480      19991          neg.l     D0
00006F7C  2400      19992          move.l    D0,D2
00006F7E  0C82 0000 19993          cmp.l     #0,D2
00006F82  0000      
00006F84  6C14      19994          bge.s     ltoa_7
00006F86  4879 0000 19995          pea       @itoa_1.L
00006F8A  73F6      
00006F8C  2F03      19996          move.l    D3,-(A7)
00006F8E  4EB9 0000 19997          jsr       _strcpy
00006F92  707C      
00006F94  504F      19998          addq.w    #8,A7
00006F96  2003      19999          move.l    D3,D0
00006F98  601E      20000          bra.s     ltoa_4
                    20001   ltoa_7:
00006F9A  2044      20002          move.l    D4,A0
00006F9C  5284      20003          addq.l    #1,D4
00006F9E  10BC 002D 20004          move.b    #45,(A0)
                    20005   ltoa_5:
00006FA2  2F05      20006          move.l    D5,-(A7)
00006FA4  2F02      20007          move.l    D2,-(A7)
00006FA6  2F04      20008          move.l    D4,-(A7)
00006FA8  4EB8 6EBE 20009          jsr       @itoa_convert
00006FAC  DEFC 000C 20010          add.w     #12,A7
00006FB0  2800      20011          move.l    D0,D4
00006FB2  2044      20012          move.l    D4,A0
00006FB4  4210      20013          clr.b     (A0)
00006FB6  2003      20014          move.l    D3,D0
                    20015   ltoa_4:
00006FB8  4CDF 003C 20016          movem.l   (A7)+,D2/D3/D4/D5
00006FBC  4E5E      20017          unlk      A6
00006FBE  4E75      20018          rts
                    20019   _ultoa:
00006FC0  4E56 0000 20020          link      A6,#0
00006FC4  48E7 3800 20021          movem.l   D2/D3/D4,-(A7)
00006FC8  262E 0010 20022          move.l    16(A6),D3
00006FCC  282E 000C 20023          move.l    12(A6),D4
00006FD0  2404      20024          move.l    D4,D2
00006FD2  0C83 0000 20025          cmp.l     #2,D3
00006FD6  0002      
00006FD8  6D08      20026          blt.s     ultoa_3
00006FDA  0C83 0000 20027          cmp.l     #36,D3
00006FDE  0024      
00006FE0  6F04      20028          ble.s     ultoa_1
                    20029   ultoa_3:
00006FE2  2004      20030          move.l    D4,D0
00006FE4  6018      20031          bra.s     ultoa_4
                    20032   ultoa_1:
00006FE6  2F03      20033          move.l    D3,-(A7)
00006FE8  2F2E 0008 20034          move.l    8(A6),-(A7)
00006FEC  2F02      20035          move.l    D2,-(A7)
00006FEE  4EB8 6EBE 20036          jsr       @itoa_convert
00006FF2  DEFC 000C 20037          add.w     #12,A7
00006FF6  2400      20038          move.l    D0,D2
00006FF8  2042      20039          move.l    D2,A0
00006FFA  4210      20040          clr.b     (A0)
00006FFC  2004      20041          move.l    D4,D0
                    20042   ultoa_4:
00006FFE  4CDF 001C 20043          movem.l   (A7)+,D2/D3/D4
00007002  4E5E      20044          unlk      A6
00007004  4E75      20045          rts
                    20046   _itoa:
00007006  4E56 0000 20047          link      A6,#0
0000700A  2F2E 0010 20048          move.l    16(A6),-(A7)
0000700E  2F2E 000C 20049          move.l    12(A6),-(A7)
00007012  2F2E 0008 20050          move.l    8(A6),-(A7)
00007016  4EB8 6F3A 20051          jsr       _ltoa
0000701A  DEFC 000C 20052          add.w     #12,A7
0000701E  4E5E      20053          unlk      A6
00007020  4E75      20054          rts
                    20055   _strlen:
00007022  206F 0004 20056          move.l    (4,A7),A0
00007026  2248      20057          move.l    A0,A1
                    20058   strlen_1:
00007028  4A19      20059          tst.b     (A1)+
0000702A  66FC      20060          bne       strlen_1
0000702C  2009      20061          move.l    A1,D0
0000702E  9088      20062          sub.l     A0,D0
00007030  5380      20063          subq.l    #1,D0
00007032  4E75      20064          rts
                    20065   _putch:
00007034  4E56 0000 20066          link      A6,#0
00007038  2F02      20067          move.l    D2,-(A7)
0000703A  242E 0008 20068          move.l    8(A6),D2
0000703E  0C82 0000 20069          cmp.l     #10,D2
00007042  000A      
00007044  660A      20070          bne.s     putch_1
00007046  4878 000D 20071          pea       13
0000704A  4EB8 5A46 20072          jsr       __putch
0000704E  584F      20073          addq.w    #4,A7
                    20074   putch_1:
00007050  2F02      20075          move.l    D2,-(A7)
00007052  4EB8 5A46 20076          jsr       __putch
00007056  584F      20077          addq.w    #4,A7
00007058  2002      20078          move.l    D2,D0
0000705A  241F      20079          move.l    (A7)+,D2
0000705C  4E5E      20080          unlk      A6
0000705E  4E75      20081          rts
                    20082   _toupper:
00007060  202F 0004 20083          move.l    4(A7),D0
00007064  0C80 0000 20084          cmp.l     #'a',D0
00007068  0061      
0000706A  6D0E      20085          blt.s     toupper_1
0000706C  0C80 0000 20086          cmp.l     #'z',D0
00007070  007A      
00007072  6E06      20087          bgt.s     toupper_1
00007074  0480 0000 20088          sub.l     #$20,D0
00007078  0020      
                    20089   toupper_1:
0000707A  4E75      20090          rts
                    20091   _strcpy:
0000707C  206F 0004 20092          move.l    (4,A7),A0
00007080  226F 0008 20093          move.l    (8,A7),A1
00007084  2008      20094          move.l    A0,D0
                    20095   strcpy_1:
00007086  10D9      20096          move.b    (A1)+,(A0)+
00007088  66FC      20097          bne.s     strcpy_1
0000708A  4E75      20098          rts
                    20099          section   const
          0000 708C 20100   const      equ         *				; consts start whever the linker groups them, after the code section (but still in rom)
                    20101   
                    20102   @ucos_ii_1:
0000708C  3F00      20103          dc.b      63,0
                    20104   @ucos_ii_2:
0000708E  7543 2F4F 20105          dc.b      117,67,47,79,83,45,73,73,32,73,100,108,101,0
00007092  532D 4949 
00007096  2049 646C 
0000709A  6500      
                    20106   @ucos_ii_3:
0000709C  7543 2F4F 20107          dc.b      117,67,47,79,83,45,73,73,32,83,116,97,116,0
000070A0  532D 4949 
000070A4  2053 7461 
000070A8  7400      
                    20108   @ucos_ii_4:
000070AA  7543 2F4F 20109          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,76,111
000070AE  532D 4949 
000070B2  2054 6D72 
000070B6  4C6F      
000070B8  636B 00   20110          dc.b      99,107,0
                    20111   @ucos_ii_5:
000070BC  7543 2F4F 20112          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,83,105
000070C0  532D 4949 
000070C4  2054 6D72 
000070C8  5369      
000070CA  676E 616C 20113          dc.b      103,110,97,108,0
000070CE  00        
                    20114   @ucos_ii_6:
000070D0  7543 2F4F 20115          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,0
000070D4  532D 4949 
000070D8  2054 6D72 
000070DC  00        
                    20116   _OSUnMapTbl:
000070DE  0000 0100 20117          dc.b      0,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0
000070E2  0200 0100 
000070E6  0300 0100 
000070EA  0200 0100 
000070EE  0400 0100 
000070F2  0200      
000070F4  0100 0300 20118          dc.b      1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0
000070F8  0100 0200 
000070FC  0100 0500 
00007100  0100 0200 
00007104  0100 0300 
00007108  0100      
0000710A  0200 0100 20119          dc.b      2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0
0000710E  0400 0100 
00007112  0200 0100 
00007116  0300 0100 
0000711A  0200 0100 
0000711E  0600      
00007120  0100 0200 20120          dc.b      1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0
00007124  0100 0300 
00007128  0100 0200 
0000712C  0100 0400 
00007130  0100 0200 
00007134  0100      
00007136  0300 0100 20121          dc.b      3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0
0000713A  0200 0100 
0000713E  0500 0100 
00007142  0200 0100 
00007146  0300 0100 
0000714A  0200      
0000714C  0100 0400 20122          dc.b      1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0
00007150  0100 0200 
00007154  0100 0300 
00007158  0100 0200 
0000715C  0100 0700 
00007160  0100      
00007162  0200 0100 20123          dc.b      2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0
00007166  0300 0100 
0000716A  0200 0100 
0000716E  0400 0100 
00007172  0200 0100 
00007176  0300      
00007178  0100 0200 20124          dc.b      1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0
0000717C  0100 0500 
00007180  0100 0200 
00007184  0100 0300 
00007188  0100 0200 
0000718C  0100      
0000718E  0400 0100 20125          dc.b      4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0
00007192  0200 0100 
00007196  0300 0100 
0000719A  0200 0100 
0000719E  0600 0100 
000071A2  0200      
000071A4  0100 0300 20126          dc.b      1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0
000071A8  0100 0200 
000071AC  0100 0400 
000071B0  0100 0200 
000071B4  0100 0300 
000071B8  0100      
000071BA  0200 0100 20127          dc.b      2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0
000071BE  0500 0100 
000071C2  0200 0100 
000071C6  0300 0100 
000071CA  0200 0100 
000071CE  0400      
000071D0  0100 0200 20128          dc.b      1,0,2,0,1,0,3,0,1,0,2,0,1,0
000071D4  0100 0300 
000071D8  0100 0200 
000071DC  0100      
                    20129   @part_b_1:
000071DE  416C 7465 20130          dc.b      65,108,116,101,114,97,32,68,69,49,47,54,56,75
000071E2  7261 2044 
000071E6  4531 2F36 
000071EA  384B      
000071EC  00        20131          dc.b      0
                    20132   @part_b_2:
000071EE  4D69 6372 20133          dc.b      77,105,99,114,105,117,109,32,117,67,47,79,83
000071F2  6975 6D20 
000071F6  7543 2F4F 
000071FA  53        
000071FB  2D49 4920 20134          dc.b      45,73,73,32,82,84,79,83,0
000071FF  5254 4F53 
00007203  00        
                    20135   @part_b_3:
00007204  536C 6964 20136          dc.b      83,108,105,100,101,114,32,115,119,105,116,99
00007208  6572 2073 
0000720C  7769 7463 
00007210  6873 3A20 20137          dc.b      104,115,58,32,37,48,50,88,10,0
00007214  2530 3258 
00007218  0A00      
                    20138   @part_b_4:
0000721A  2020 2020 20139          dc.b      32,32,32,32,65,68,67,32,114,101,97,100,105,110
0000721E  4144 4320 
00007222  7265 6164 
00007226  696E      
00007228  673A 2020 20140          dc.b      103,58,32,32,32,32,37,100,10,0
0000722C  2020 2564 
00007230  0A00      
                    20141   @part_b_5:
00007232  2020 2020 20142          dc.b      32,32,32,32,32,32,32,32,108,105,103,104,116
00007236  2020 2020 
0000723A  6C69 6768 
0000723E  74        
0000723F  2073 656E 20143          dc.b      32,115,101,110,115,111,114,32,114,101,97,100
00007243  736F 7220 
00007247  7265 6164 
0000724B  696E 673A 20144          dc.b      105,110,103,58,32,32,32,37,100,10,0
0000724F  2020 2025 
00007253  640A 00   
                    20145   @part_b_6:
00007256  2020 2020 20146          dc.b      32,32,32,32,32,32,32,32,32,32,32,32,84,104,101
0000725A  2020 2020 
0000725E  2020 2020 
00007262  5468 65   
00007265  726D 6973 20147          dc.b      114,109,105,115,116,101,114,32,114,101,97,100
00007269  7465 7220 
0000726D  7265 6164 
00007271  696E 673A 20148          dc.b      105,110,103,58,32,32,32,32,32,37,100,10,0
00007275  2020 2020 
00007279  2025 640A 
0000727D  00        
                    20149   @part_b_7:
0000727E  4144 433A 20150          dc.b      65,68,67,58,32,37,100,44,32,108,105,103,104
00007282  2025 642C 
00007286  206C 6967 
0000728A  68        
0000728B  7420 7365 20151          dc.b      116,32,115,101,110,115,111,114,58,32,37,100
0000728F  6E73 6F72 
00007293  3A20 2564 
00007297  2C20 0A74 20152          dc.b      44,32,10,116,104,101,114,109,105,115,116,101
0000729B  6865 726D 
0000729F  6973 7465 
000072A3  723A 2025 20153          dc.b      114,58,32,37,100,44,32,115,108,105,100,101,114
000072A7  642C 2073 
000072AB  6C69 6465 
000072AF  72        
000072B0  3A20 2564 20154          dc.b      58,32,37,100,10,0
000072B4  0A00      
                    20155   @canbus~1_1:
000072B6  0D0A 5B43 20156          dc.b      13,10,91,67,97,110,66,117,115,48,93,58,87,97
000072BA  616E 4275 
000072BE  7330 5D3A 
000072C2  5761      
000072C4  6974 2066 20157          dc.b      105,116,32,102,111,114,32,84,120,32,66,101,103
000072C8  6F72 2054 
000072CC  7820 4265 
000072D0  67        
000072D1  696E 00   20158          dc.b      105,110,0
                    20159   @canbus~1_2:
000072D4  0D0A 5B43 20160          dc.b      13,10,91,67,97,110,66,117,115,48,93,58,87,97
000072D8  616E 4275 
000072DC  7330 5D3A 
000072E0  5761      
000072E2  6974 2066 20161          dc.b      105,116,32,102,111,114,32,84,120,32,70,105,110
000072E6  6F72 2054 
000072EA  7820 4669 
000072EE  6E        
000072EF  6973 6800 20162          dc.b      105,115,104,0
                    20163   @canbus~1_3:
000072F4  5B43 616E 20164          dc.b      91,67,97,110,66,117,115,48,84,120,93,58,0
000072F8  4275 7330 
000072FC  5478 5D3A 
00007300  00        
                    20165   @canbus~1_4:
00007302  5B43 616E 20166          dc.b      91,67,97,110,66,117,115,49,84,120,93,58,0
00007306  4275 7331 
0000730A  5478 5D3A 
0000730E  00        
                    20167   @canbus~1_5:
00007310  5B43 616E 20168          dc.b      91,67,97,110,66,117,115,48,82,120,93,58,0
00007314  4275 7330 
00007318  5278 5D3A 
0000731C  00        
                    20169   @canbus~1_6:
0000731E  5B43 616E 20170          dc.b      91,67,97,110,66,117,115,49,82,120,93,58,0
00007322  4275 7331 
00007326  5278 5D3A 
0000732A  00        
                    20171   @canbus~1_7:
0000732C  0D0A 4361 20172          dc.b      13,10,67,97,110,66,117,115,32,73,110,105,116
00007330  6E42 7573 
00007334  2049 6E69 
00007338  74        
00007339  00        20173          dc.b      0
                    20174   @canbus~1_8:
0000733A  0D0A 0D0A 20175          dc.b      13,10,13,10,45,45,45,45,32,67,65,78,66,85,83
0000733E  2D2D 2D2D 
00007342  2043 414E 
00007346  4255 53   
00007349  2054 6573 20176          dc.b      32,84,101,115,116,32,45,45,45,45,13,10,0
0000734D  7420 2D2D 
00007351  2D2D 0D0A 
00007355  00        
                    20177   @canbus~1_9:
00007356  0D0A 5B43 20178          dc.b      13,10,91,67,97,110,66,117,115,84,101,115,116
0000735A  616E 4275 
0000735E  7354 6573 
00007362  74        
00007363  5D3A 4361 20179          dc.b      93,58,67,97,110,66,117,115,48,32,84,120,32,116
00007367  6E42 7573 
0000736B  3020 5478 
0000736F  2074      
00007371  6F20 4361 20180          dc.b      111,32,67,97,110,66,117,115,49,0
00007375  6E42 7573 
00007379  3100      
                    20181   @canbus~1_10:
0000737C  0D0A 5B43 20182          dc.b      13,10,91,67,97,110,66,117,115,49,93,58,82,101
00007380  616E 4275 
00007384  7331 5D3A 
00007388  5265      
0000738A  6365 6976 20183          dc.b      99,101,105,118,101,100,32,68,97,116,97,58,32
0000738E  6564 2044 
00007392  6174 613A 
00007396  20        
00007397  2578 2040 20184          dc.b      37,120,32,64,32,73,68,32,37,100,0
0000739B  2049 4420 
0000739F  2564 00   
                    20185   @canbus~1_11:
000073A2  0D0A 00   20186          dc.b      13,10,0
                    20187   @canbus~1_12:
000073A6  0D0A 5B43 20188          dc.b      13,10,91,67,97,110,66,117,115,84,101,115,116
000073AA  616E 4275 
000073AE  7354 6573 
000073B2  74        
000073B3  5D3A 4361 20189          dc.b      93,58,67,97,110,66,117,115,49,32,84,120,32,116
000073B7  6E42 7573 
000073BB  3120 5478 
000073BF  2074      
000073C1  6F20 4361 20190          dc.b      111,32,67,97,110,66,117,115,48,0
000073C5  6E42 7573 
000073C9  3000      
                    20191   @dac_ad~1_1:
000073CC  0D0A 4D75 20192          dc.b      13,10,77,117,115,116,32,115,101,108,101,99,116
000073D0  7374 2073 
000073D4  656C 6563 
000073D8  74        
000073D9  2041 4443 20193          dc.b      32,65,68,67,32,99,104,97,110,110,101,108,32
000073DD  2063 6861 
000073E1  6E6E 656C 
000073E5  20        
000073E6  6265 7477 20194          dc.b      98,101,116,119,101,101,110,32,48,32,97,110,100
000073EA  6565 6E20 
000073EE  3020 616E 
000073F2  64        
000073F3  2033 00   20195          dc.b      32,51,0
                    20196   @itoa_1:
000073F6  2D32 3134 20197          dc.b      45,50,49,52,55,52,56,51,54,52,56,0
000073FA  3734 3833 
000073FE  3634 3800 
                    20198   __ctype:
00007402  0040 4040 20199          dc.b      0,64,64,64,64,64,64,64,64,64,80,80,80,80,80
00007406  4040 4040 
0000740A  4040 5050 
0000740E  5050 50   
00007411  4040 4040 20200          dc.b      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64
00007415  4040 4040 
00007419  4040 4040 
0000741D  4040 40   
00007420  4040 40D0 20201          dc.b      64,64,64,208,160,160,160,160,160,160,160,160
00007424  A0A0 A0A0 
00007428  A0A0 A0A0 
0000742C  A0A0 A0A0 20202          dc.b      160,160,160,160,160,160,160,140,140,140,140
00007430  A0A0 A08C 
00007434  8C8C 8C   
00007437  8C8C 8C8C 20203          dc.b      140,140,140,140,140,140,160,160,160,160,160
0000743B  8C8C A0A0 
0000743F  A0A0 A0   
00007442  A0A0 8A8A 20204          dc.b      160,160,138,138,138,138,138,138,130,130,130
00007446  8A8A 8A8A 
0000744A  8282 82   
0000744D  8282 8282 20205          dc.b      130,130,130,130,130,130,130,130,130,130,130
00007451  8282 8282 
00007455  8282 82   
00007458  8282 8282 20206          dc.b      130,130,130,130,130,130,160,160,160,160,160
0000745C  8282 A0A0 
00007460  A0A0 A0   
00007463  A089 8989 20207          dc.b      160,137,137,137,137,137,137,129,129,129,129
00007467  8989 8981 
0000746B  8181 81   
0000746E  8181 8181 20208          dc.b      129,129,129,129,129,129,129,129,129,129,129
00007472  8181 8181 
00007476  8181 81   
00007479  8181 8181 20209          dc.b      129,129,129,129,129,160,160,160,160,64,0,0,0
0000747D  81A0 A0A0 
00007481  A040 0000 
00007485  00        
00007486  0000 0000 20210          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0000748A  0000 0000 
0000748E  0000 0000 
00007492  0000 0000 
00007496  0000 0000 
0000749A  0000      
0000749C  0000 0000 20211          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
000074A0  0000 0000 
000074A4  0000 0000 
000074A8  0000 0000 
000074AC  0000 0000 
000074B0  0000      
000074B2  0000 0000 20212          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
000074B6  0000 0000 
000074BA  0000 0000 
000074BE  0000 0000 
000074C2  0000 0000 
000074C6  0000      
000074C8  0000 0000 20213          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
000074CC  0000 0000 
000074D0  0000 0000 
000074D4  0000 0000 
000074D8  0000 0000 
000074DC  0000      
000074DE  0000 0000 20214          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
000074E2  0000 0000 
000074E6  0000 0000 
000074EA  0000 0000 
000074EE  0000 0000 
000074F2  0000      
000074F4  0000 0000 20215          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
000074F8  0000 0000 
000074FC  0000 0000 
00007500  0000 00   
                    20216          section   data
          0000 7504 20217   end_ROM    equ         *				; end of rom is wherever the last code/constant appears (* means here)
                    20218   
08000000            20219              org         RAM				; starting at address $08000000
          0800 0000 20220   begin_RAM  equ         *				; begin ram starts here
          0800 0000 20221   data       equ         *				; data starts here also
                    20222   
                    20223   _adc_reading:
08000000  AA        20224          dc.b      170
                    20225   _light_reading:
08000002  00        20226          dc.b      0
                    20227   _therm_reading:
08000004  00        20228          dc.b      0
                    20229   _zero:
08000006  00        20230          dc.b      0
                    20231          section   bss
          0800 0008 20232   bss        equ         *
                    20233   
                    20234   ;           org         $0B000000               Ram based vector table must be stored here otherwise InstallException Handler will not work
                    20235   
                    20236   *********************************************************************************************************
                    20237   * Build a ram based vector table for interrupts so we can install our own Exception Handlers in C code at run time
                    20238   * install the exception handler using the C function InstallExceptionHandler()
                    20239   *********************************************************************************************************
                    20240   
08000008            20241   VInitialSP       ds.l    1      dummy as we can't really install a handler for this
0800000C            20242   VInitialPC       ds.l    1      dummy as we can't reallin install a handler for this
08000010            20243   VBusError        ds.l    1      storage for address of Bus Error Handler
08000014            20244   VAddressError    ds.l    1      storage for address of Address Error Handler
08000018            20245   VIllegalInstr    ds.l    1      storage for address of Illegal Instruction handler
0800001C            20246   VDividebyZero    ds.l    1      storage for address of divide by zero handler
08000020            20247   VCheck           ds.l    1      ditto
08000024            20248   VTrapV           ds.l    1      ditto
08000028            20249   VPrivilege       ds.l    1      ditto
0800002C            20250   VTrace           ds.l    1
08000030            20251   VLine1010emul    ds.l    1
08000034            20252   VLine1111emul    ds.l    1
08000038            20253   VUnassigned1     ds.l    1
0800003C            20254   VUnassigned2     ds.l    1
08000040            20255   VUnassigned3     ds.l    1
08000044            20256   VUninit_IRQ      ds.l    1
08000048            20257   VUnassigned4     ds.l    1
0800004C            20258   VUnassigned5     ds.l    1
08000050            20259   VUnassigned6     ds.l    1
08000054            20260   VUnassigned7     ds.l    1
08000058            20261   VUnassigned8     ds.l    1
0800005C            20262   VUnassigned9     ds.l    1
08000060            20263   VUnassigned10    ds.l    1
08000064            20264   VUnassigned11    ds.l    1
08000068            20265   VSpuriousIRQ     ds.l    1
                    20266   
                    20267   * Interrupt handlers Vector 25-31
0800006C            20268   VL1IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000070            20269   VL2IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000074            20270   VL3IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000078            20271   VL4IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0800007C            20272   VL5IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000080            20273   VL6IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000084            20274   VL7IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
                    20275   
                    20276   * Trap Handler vectors 32-47
08000088            20277   VTrap0           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0800008C            20278   VTrap1           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08000090            20279   VTrap2           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08000094            20280   VTrap3           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08000098            20281   VTrap4           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0800009C            20282   VTrap5           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000A0            20283   VTrap6           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000A4            20284   VTrap7           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000A8            20285   VTrap8           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000AC            20286   VTrap9           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000B0            20287   VTrap10          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000B4            20288   VTrap11          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000B8            20289   VTrap12          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000BC            20290   VTrap13          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000C0            20291   VTrap14          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000C4            20292   VTrap15          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
                    20293   
                    20294   __ungetbuf:                            ; ungetbuffer for stdio functions
080000C8            20295              ds.l        1
                    20296   __timezone:                            ; difference, in seconds, between local time and UTC
080000CC            20297              ds.l        1
                    20298   __daylight:                            ; flag, '1' for daylight saving time, '0' for standard time.
080000D0            20299              ds.l        1
                    20300   __romsize:                             ; size of ROM used by program
080000D4            20301              ds.l        1
                    20302   __ramsize:                             ; size of RAM used by program
080000D8            20303              ds.l        1
                    20304   
                    20305   _OSTmrTickCtr:
080000DC            20306          ds.b      1
                    20307   _OSCtxSwCtr:
080000DE            20308          ds.b      4
                    20309   _OSEventFreeList:
080000E2            20310          ds.b      4
                    20311   _OSEventTbl:
080000E6            20312          ds.b      220
                    20313   _OSFlagTbl:
080001C2            20314          ds.b      60
                    20315   _OSFlagFreeList:
080001FE            20316          ds.b      4
                    20317   _OSCPUUsage:
08000202            20318          ds.b      1
                    20319   _OSIdleCtrMax:
08000204            20320          ds.b      4
                    20321   _OSIdleCtrRun:
08000208            20322          ds.b      4
                    20323   _OSStatRdy:
0800020C            20324          ds.b      1
                    20325   _OSTaskStatStk:
0800020E            20326          ds.b      256
                    20327   _OSIntNesting:
0800030E            20328          ds.b      1
                    20329   _OSLockNesting:
08000310            20330          ds.b      1
                    20331   _OSPrioCur:
08000312            20332          ds.b      1
                    20333   _OSPrioHighRdy:
08000314            20334          ds.b      1
                    20335   _OSRdyGrp:
08000316            20336          ds.b      1
                    20337   _OSRdyTbl:
08000318            20338          ds.b      8
                    20339   _OSRunning:
08000320            20340          ds.b      1
                    20341   _OSTaskCtr:
08000322            20342          ds.b      1
                    20343   _OSIdleCtr:
08000324            20344          ds.b      4
                    20345   _OSTaskIdleStk:
08000328            20346          ds.b      256
                    20347   _OSTCBCur:
08000428            20348          ds.b      4
                    20349   _OSTCBFreeList:
0800042C            20350          ds.b      4
                    20351   _OSTCBHighRdy:
08000430            20352          ds.b      4
                    20353   _OSTCBList:
08000434            20354          ds.b      4
                    20355   _OSTCBPrioTbl:
08000438            20356          ds.b      256
                    20357   _OSTCBTbl:
08000538            20358          ds.b      1892
                    20359   _OSMemFreeList:
08000C9C            20360          ds.b      4
                    20361   _OSMemTbl:
08000CA0            20362          ds.b      120
                    20363   _OSQFreeList:
08000D18            20364          ds.b      4
                    20365   _OSQTbl:
08000D1C            20366          ds.b      96
                    20367   _OSTaskRegNextAvailID:
08000D7C            20368          ds.b      1
                    20369   _OSTime:
08000D7E            20370          ds.b      4
                    20371   _OSTmrFree:
08000D82            20372          ds.b      2
                    20373   _OSTmrUsed:
08000D84            20374          ds.b      2
                    20375   _OSTmrTime:
08000D86            20376          ds.b      4
                    20377   _OSTmrSem:
08000D8A            20378          ds.b      4
                    20379   _OSTmrSemSignal:
08000D8E            20380          ds.b      4
                    20381   _OSTmrTbl:
08000D92            20382          ds.b      576
                    20383   _OSTmrFreeList:
08000FD2            20384          ds.b      4
                    20385   _OSTmrTaskStk:
08000FD6            20386          ds.b      256
                    20387   _OSTmrWheelTbl:
080010D6            20388          ds.b      32
                    20389   _Task1Stk:
080010F6            20390          ds.b      512
                    20391   _Task2Stk:
080012F6            20392          ds.b      512
                    20393   _Task3Stk:
080014F6            20394          ds.b      512
                    20395   _Task4Stk:
080016F6            20396          ds.b      512
                    20397   _Task5Stk:
080018F6            20398          ds.b      512
                    20399   _CANMutex:
08001AF6            20400          ds.b      4
                    20401   _Timer1Count:
08001AFA            20402          ds.b      1
                    20403   _Timer2Count:
08001AFC            20404          ds.b      1
                    20405   _Timer3Count:
08001AFE            20406          ds.b      1
                    20407   _Timer4Count:
08001B00            20408          ds.b      1
                    20409   _receied_data1:
08001B02            20410          ds.b      1
                    20411   _receied_data2:
08001B04            20412          ds.b      1
                    20413   _receied_data3:
08001B06            20414          ds.b      1
                    20415   _receied_data4:
08001B08            20416          ds.b      1
                    20417   _receied_data5:
08001B0A            20418          ds.b      1
                    20419   _receied_data6:
08001B0C            20420          ds.b      1
                    20421   _receied_data7:
08001B0E            20422          ds.b      1
                    20423   _receied_data8:
08001B10            20424          ds.b      1
                    20425          section   heap
          0800 1B12 20426   end_RAM    equ         *				; wherever the program variables end, is the start of the heap
          0800 1B12 20427   heap       equ         *
                    20428   
          0801 0000 20429   __stack    equ         RAM+RAMsize     ; stack for main function, no longer needed after OSStart() is called
          0000 0000

Assembly errors: 0
