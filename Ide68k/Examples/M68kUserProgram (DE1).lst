680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 17 Jan 2022      Time: 16:54:58          Source: C:\M68KV6.0 - 800BY480\PROGRAMS\DEBUGMONITORCODE\M68KUSERPROGRAM (DE1).C

                       1   ; C:\M68KV6.0 - 800BY480\PROGRAMS\DEBUGMONITORCODE\M68KUSERPROGRAM (DE1).C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                       2   ; #include <stdio.h>
                       3   ; #include <string.h>
                       4   ; #include <ctype.h>
                       5   ; //IMPORTANT
                       6   ; //
                       7   ; // Uncomment one of the two #defines below
                       8   ; // Define StartOfExceptionVectorTable as 08030000 if running programs from sram or
                       9   ; // 0B000000 for running programs from dram
                      10   ; //
                      11   ; // In your labs, you will initially start by designing a system with SRam and later move to
                      12   ; // Dram, so these constants will need to be changed based on the version of the system you have
                      13   ; // building
                      14   ; //
                      15   ; // The working 68k system SOF file posted on canvas that you can use for your pre-lab
                      16   ; // is based around Dram so #define accordingly before building
                      17   ; //#define StartOfExceptionVectorTable 0x08030000
                      18   ; #define StartOfExceptionVectorTable 0x0B000000
                      19   ; /**********************************************************************************************
                      20   ; **	Parallel port addresses
                      21   ; **********************************************************************************************/
                      22   ; #define PortA   *(volatile unsigned char *)(0x00400000)
                      23   ; #define PortB   *(volatile unsigned char *)(0x00400002)
                      24   ; #define PortC   *(volatile unsigned char *)(0x00400004)
                      25   ; #define PortD   *(volatile unsigned char *)(0x00400006)
                      26   ; #define PortE   *(volatile unsigned char *)(0x00400008)
                      27   ; /*********************************************************************************************
                      28   ; **	Hex 7 seg displays port addresses
                      29   ; *********************************************************************************************/
                      30   ; #define HEX_A        *(volatile unsigned char *)(0x00400010)
                      31   ; #define HEX_B        *(volatile unsigned char *)(0x00400012)
                      32   ; #define HEX_C        *(volatile unsigned char *)(0x00400014)    // de2 only
                      33   ; #define HEX_D        *(volatile unsigned char *)(0x00400016)    // de2 only
                      34   ; /**********************************************************************************************
                      35   ; **	LCD display port addresses
                      36   ; **********************************************************************************************/
                      37   ; #define LCDcommand   *(volatile unsigned char *)(0x00400020)
                      38   ; #define LCDdata      *(volatile unsigned char *)(0x00400022)
                      39   ; /********************************************************************************************
                      40   ; **	Timer Port addresses
                      41   ; *********************************************************************************************/
                      42   ; #define Timer1Data      *(volatile unsigned char *)(0x00400030)
                      43   ; #define Timer1Control   *(volatile unsigned char *)(0x00400032)
                      44   ; #define Timer1Status    *(volatile unsigned char *)(0x00400032)
                      45   ; #define Timer2Data      *(volatile unsigned char *)(0x00400034)
                      46   ; #define Timer2Control   *(volatile unsigned char *)(0x00400036)
                      47   ; #define Timer2Status    *(volatile unsigned char *)(0x00400036)
                      48   ; #define Timer3Data      *(volatile unsigned char *)(0x00400038)
                      49   ; #define Timer3Control   *(volatile unsigned char *)(0x0040003A)
                      50   ; #define Timer3Status    *(volatile unsigned char *)(0x0040003A)
                      51   ; #define Timer4Data      *(volatile unsigned char *)(0x0040003C)
                      52   ; #define Timer4Control   *(volatile unsigned char *)(0x0040003E)
                      53   ; #define Timer4Status    *(volatile unsigned char *)(0x0040003E)
                      54   ; /*********************************************************************************************
                      55   ; **	RS232 port addresses
                      56   ; *********************************************************************************************/
                      57   ; #define RS232_Control     *(volatile unsigned char *)(0x00400040)
                      58   ; #define RS232_Status      *(volatile unsigned char *)(0x00400040)
                      59   ; #define RS232_TxData      *(volatile unsigned char *)(0x00400042)
                      60   ; #define RS232_RxData      *(volatile unsigned char *)(0x00400042)
                      61   ; #define RS232_Baud        *(volatile unsigned char *)(0x00400044)
                      62   ; /*********************************************************************************************
                      63   ; **	PIA 1 and 2 port addresses
                      64   ; *********************************************************************************************/
                      65   ; #define PIA1_PortA_Data     *(volatile unsigned char *)(0x00400050)         // combined data and data direction register share same address
                      66   ; #define PIA1_PortA_Control *(volatile unsigned char *)(0x00400052)
                      67   ; #define PIA1_PortB_Data     *(volatile unsigned char *)(0x00400054)         // combined data and data direction register share same address
                      68   ; #define PIA1_PortB_Control *(volatile unsigned char *)(0x00400056)
                      69   ; #define PIA2_PortA_Data     *(volatile unsigned char *)(0x00400060)         // combined data and data direction register share same address
                      70   ; #define PIA2_PortA_Control *(volatile unsigned char *)(0x00400062)
                      71   ; #define PIA2_PortB_data     *(volatile unsigned char *)(0x00400064)         // combined data and data direction register share same address
                      72   ; #define PIA2_PortB_Control *(volatile unsigned char *)(0x00400066)
                      73   ; /*********************************************************************************************************************************
                      74   ; (( DO NOT initialise global variables here, do it main even if you want 0
                      75   ; (( it's a limitation of the compiler
                      76   ; (( YOU HAVE BEEN WARNED
                      77   ; *********************************************************************************************************************************/
                      78   ; unsigned int i, x, y, z, PortA_Count;
                      79   ; unsigned char Timer1Count, Timer2Count, Timer3Count, Timer4Count ;
                      80   ; /*******************************************************************************************
                      81   ; ** Function Prototypes
                      82   ; *******************************************************************************************/
                      83   ; void Wait1ms(void);
                      84   ; void Wait3ms(void);
                      85   ; void Init_LCD(void) ;
                      86   ; void LCDOutchar(int c);
                      87   ; void LCDOutMess(char *theMessage);
                      88   ; void LCDClearln(void);
                      89   ; void LCDline1Message(char *theMessage);
                      90   ; void LCDline2Message(char *theMessage);
                      91   ; int sprintf(char *out, const char *format, ...) ;
                      92   ; /*****************************************************************************************
                      93   ; **	Interrupt service routine for Timers
                      94   ; **
                      95   ; **  Timers 1 - 4 share a common IRQ on the CPU  so this function uses polling to figure
                      96   ; **  out which timer is producing the interrupt
                      97   ; **
                      98   ; *****************************************************************************************/
                      99   ; void Timer_ISR()
                     100   ; {
                     101          section   code
                     102          xdef      _Timer_ISR
                     103   _Timer_ISR:
                     104   ; if(Timer1Status == 1) {         // Did Timer 1 produce the Interrupt?
00000000  1039 0040  105          move.b    4194354,D0
00000004  0032      
00000006  0C00 0001  106          cmp.b     #1,D0
0000000A  661A       107          bne.s     Timer_ISR_1
                     108   ; Timer1Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
0000000C  13FC 0003  109          move.b    #3,4194354
00000010  0040 0032 
                     110   ; PortA = Timer1Count++ ;     // increment an LED count on PortA with each tick of Timer 1
00000014  1039 0000  111          move.b    _Timer1Count.L,D0
00000018  041C      
0000001A  5239 0000  112          addq.b    #1,_Timer1Count.L
0000001E  041C      
00000020  13C0 0040  113          move.b    D0,4194304
00000024  0000      
                     114   Timer_ISR_1:
                     115   ; }
                     116   ; if(Timer2Status == 1) {         // Did Timer 2 produce the Interrupt?
00000026  1039 0040  117          move.b    4194358,D0
0000002A  0036      
0000002C  0C00 0001  118          cmp.b     #1,D0
00000030  661A       119          bne.s     Timer_ISR_3
                     120   ; Timer2Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
00000032  13FC 0003  121          move.b    #3,4194358
00000036  0040 0036 
                     122   ; PortC = Timer2Count++ ;     // increment an LED count on PortC with each tick of Timer 2
0000003A  1039 0000  123          move.b    _Timer2Count.L,D0
0000003E  041E      
00000040  5239 0000  124          addq.b    #1,_Timer2Count.L
00000044  041E      
00000046  13C0 0040  125          move.b    D0,4194308
0000004A  0004      
                     126   Timer_ISR_3:
                     127   ; }
                     128   ; if(Timer3Status == 1) {         // Did Timer 3 produce the Interrupt?
0000004C  1039 0040  129          move.b    4194362,D0
00000050  003A      
00000052  0C00 0001  130          cmp.b     #1,D0
00000056  661A       131          bne.s     Timer_ISR_5
                     132   ; Timer3Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
00000058  13FC 0003  133          move.b    #3,4194362
0000005C  0040 003A 
                     134   ; HEX_A = Timer3Count++ ;     // increment a HEX count on Port HEX_A with each tick of Timer 3
00000060  1039 0000  135          move.b    _Timer3Count.L,D0
00000064  0420      
00000066  5239 0000  136          addq.b    #1,_Timer3Count.L
0000006A  0420      
0000006C  13C0 0040  137          move.b    D0,4194320
00000070  0010      
                     138   Timer_ISR_5:
                     139   ; }
                     140   ; if(Timer4Status == 1) {         // Did Timer 4 produce the Interrupt?
00000072  1039 0040  141          move.b    4194366,D0
00000076  003E      
00000078  0C00 0001  142          cmp.b     #1,D0
0000007C  661A       143          bne.s     Timer_ISR_7
                     144   ; Timer4Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
0000007E  13FC 0003  145          move.b    #3,4194366
00000082  0040 003E 
                     146   ; HEX_B = Timer4Count++ ;     // increment a HEX count on HEX_B with each tick of Timer 4
00000086  1039 0000  147          move.b    _Timer4Count.L,D0
0000008A  0422      
0000008C  5239 0000  148          addq.b    #1,_Timer4Count.L
00000090  0422      
00000092  13C0 0040  149          move.b    D0,4194322
00000096  0012      
                     150   Timer_ISR_7:
00000098  4E75       151          rts
                     152   ; }
                     153   ; }
                     154   ; /*****************************************************************************************
                     155   ; **	Interrupt service routine for ACIA. This device has it's own dedicate IRQ level
                     156   ; **  Add your code here to poll Status register and clear interrupt
                     157   ; *****************************************************************************************/
                     158   ; void ACIA_ISR()
                     159   ; {}
                     160          xdef      _ACIA_ISR
                     161   _ACIA_ISR:
0000009A  4E75       162          rts
                     163   ; /***************************************************************************************
                     164   ; **	Interrupt service routine for PIAs 1 and 2. These devices share an IRQ level
                     165   ; **  Add your code here to poll Status register and clear interrupt
                     166   ; *****************************************************************************************/
                     167   ; void PIA_ISR()
                     168   ; {}
                     169          xdef      _PIA_ISR
                     170   _PIA_ISR:
0000009C  4E75       171          rts
                     172   ; /***********************************************************************************
                     173   ; **	Interrupt service routine for Key 2 on DE1 board. Add your own response here
                     174   ; ************************************************************************************/
                     175   ; void Key2PressISR()
                     176   ; {}
                     177          xdef      _Key2PressISR
                     178   _Key2PressISR:
0000009E  4E75       179          rts
                     180   ; /***********************************************************************************
                     181   ; **	Interrupt service routine for Key 1 on DE1 board. Add your own response here
                     182   ; ************************************************************************************/
                     183   ; void Key1PressISR()
                     184   ; {}
                     185          xdef      _Key1PressISR
                     186   _Key1PressISR:
000000A0  4E75       187          rts
                     188   ; /************************************************************************************
                     189   ; **   Delay Subroutine to give the 68000 something useless to do to waste 1 mSec
                     190   ; ************************************************************************************/
                     191   ; void Wait1ms(void)
                     192   ; {
                     193          xdef      _Wait1ms
                     194   _Wait1ms:
000000A2  2F02       195          move.l    D2,-(A7)
                     196   ; int  i ;
                     197   ; for(i = 0; i < 1000; i ++)
000000A4  4282       198          clr.l     D2
                     199   Wait1ms_1:
000000A6  0C82 0000  200          cmp.l     #1000,D2
000000AA  03E8      
000000AC  6C04       201          bge.s     Wait1ms_3
000000AE  5282       202          addq.l    #1,D2
000000B0  60F4       203          bra       Wait1ms_1
                     204   Wait1ms_3:
000000B2  241F       205          move.l    (A7)+,D2
000000B4  4E75       206          rts
                     207   ; ;
                     208   ; }
                     209   ; /************************************************************************************
                     210   ; **  Subroutine to give the 68000 something useless to do to waste 3 mSec
                     211   ; **************************************************************************************/
                     212   ; void Wait3ms(void)
                     213   ; {
                     214          xdef      _Wait3ms
                     215   _Wait3ms:
000000B6  2F02       216          move.l    D2,-(A7)
                     217   ; int i ;
                     218   ; for(i = 0; i < 3; i++)
000000B8  4282       219          clr.l     D2
                     220   Wait3ms_1:
000000BA  0C82 0000  221          cmp.l     #3,D2
000000BE  0003      
000000C0  6C08       222          bge.s     Wait3ms_3
                     223   ; Wait1ms() ;
000000C2  4EB8 00A2  224          jsr       _Wait1ms
000000C6  5282       225          addq.l    #1,D2
000000C8  60F0       226          bra       Wait3ms_1
                     227   Wait3ms_3:
000000CA  241F       228          move.l    (A7)+,D2
000000CC  4E75       229          rts
                     230   ; }
                     231   ; /*********************************************************************************************
                     232   ; **  Subroutine to initialise the LCD display by writing some commands to the LCD internal registers
                     233   ; **  Sets it for parallel port and 2 line display mode (if I recall correctly)
                     234   ; *********************************************************************************************/
                     235   ; void Init_LCD(void)
                     236   ; {
                     237          xdef      _Init_LCD
                     238   _Init_LCD:
                     239   ; LCDcommand = 0x0c ;
000000CE  13FC 000C  240          move.b    #12,4194336
000000D2  0040 0020 
                     241   ; Wait3ms() ;
000000D6  4EB8 00B6  242          jsr       _Wait3ms
                     243   ; LCDcommand = 0x38 ;
000000DA  13FC 0038  244          move.b    #56,4194336
000000DE  0040 0020 
                     245   ; Wait3ms() ;
000000E2  4EB8 00B6  246          jsr       _Wait3ms
000000E6  4E75       247          rts
                     248   ; }
                     249   ; /*********************************************************************************************
                     250   ; **  Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                     251   ; *********************************************************************************************/
                     252   ; void Init_RS232(void)
                     253   ; {
                     254          xdef      _Init_RS232
                     255   _Init_RS232:
                     256   ; RS232_Control = 0x15 ; //  %00010101 set up 6850 uses divide by 16 clock, set RTS low, 8 bits no parity, 1 stop bit, transmitter interrupt disabled
000000E8  13FC 0015  257          move.b    #21,4194368
000000EC  0040 0040 
                     258   ; RS232_Baud = 0x1 ;      // program baud rate generator 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
000000F0  13FC 0001  259          move.b    #1,4194372
000000F4  0040 0044 
000000F8  4E75       260          rts
                     261   ; }
                     262   ; /*********************************************************************************************************
                     263   ; **  Subroutine to provide a low level output function to 6850 ACIA
                     264   ; **  This routine provides the basic functionality to output a single character to the serial Port
                     265   ; **  to allow the board to communicate with HyperTerminal Program
                     266   ; **
                     267   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                     268   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                     269   ; **  call _putch() also
                     270   ; *********************************************************************************************************/
                     271   ; int _putch( int c)
                     272   ; {
                     273          xdef      __putch
                     274   __putch:
000000FA  4E56 0000  275          link      A6,#0
                     276   ; while((RS232_Status & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                     277   _putch_1:
000000FE  1039 0040  278          move.b    4194368,D0
00000102  0040      
00000104  C03C 0002  279          and.b     #2,D0
00000108  0C00 0002  280          cmp.b     #2,D0
0000010C  6702       281          beq.s     _putch_3
0000010E  60EE       282          bra       _putch_1
                     283   _putch_3:
                     284   ; ;
                     285   ; RS232_TxData = (c & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
00000110  202E 0008  286          move.l    8(A6),D0
00000114  C0BC 0000  287          and.l     #127,D0
00000118  007F      
0000011A  13C0 0040  288          move.b    D0,4194370
0000011E  0042      
                     289   ; return c ;                                              // putchar() expects the character to be returned
00000120  202E 0008  290          move.l    8(A6),D0
00000124  4E5E       291          unlk      A6
00000126  4E75       292          rts
                     293   ; }
                     294   ; /*********************************************************************************************************
                     295   ; **  Subroutine to provide a low level input function to 6850 ACIA
                     296   ; **  This routine provides the basic functionality to input a single character from the serial Port
                     297   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                     298   ; **
                     299   ; **  NOTE you do not call this function directly, instead you call the normal getchar() function
                     300   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call getchar() so will
                     301   ; **  call _getch() also
                     302   ; *********************************************************************************************************/
                     303   ; int _getch( void )
                     304   ; {
                     305          xdef      __getch
                     306   __getch:
00000128  4E56 FFFC  307          link      A6,#-4
                     308   ; char c ;
                     309   ; while((RS232_Status & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                     310   _getch_1:
0000012C  1039 0040  311          move.b    4194368,D0
00000130  0040      
00000132  C03C 0001  312          and.b     #1,D0
00000136  0C00 0001  313          cmp.b     #1,D0
0000013A  6702       314          beq.s     _getch_3
0000013C  60EE       315          bra       _getch_1
                     316   _getch_3:
                     317   ; ;
                     318   ; return (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
0000013E  1039 0040  319          move.b    4194370,D0
00000142  0042      
00000144  C0BC 0000  320          and.l     #255,D0
00000148  00FF      
0000014A  C0BC 0000  321          and.l     #127,D0
0000014E  007F      
00000150  4E5E       322          unlk      A6
00000152  4E75       323          rts
                     324   ; }
                     325   ; /******************************************************************************
                     326   ; **  Subroutine to output a single character to the 2 row LCD display
                     327   ; **  It is assumed the character is an ASCII code and it will be displayed at the
                     328   ; **  current cursor position
                     329   ; *******************************************************************************/
                     330   ; void LCDOutchar(int c)
                     331   ; {
                     332          xdef      _LCDOutchar
                     333   _LCDOutchar:
00000154  4E56 0000  334          link      A6,#0
                     335   ; LCDdata = (char)(c);
00000158  202E 0008  336          move.l    8(A6),D0
0000015C  13C0 0040  337          move.b    D0,4194338
00000160  0022      
                     338   ; Wait1ms() ;
00000162  4EB8 00A2  339          jsr       _Wait1ms
00000166  4E5E       340          unlk      A6
00000168  4E75       341          rts
                     342   ; }
                     343   ; /**********************************************************************************
                     344   ; *subroutine to output a message at the current cursor position of the LCD display
                     345   ; ************************************************************************************/
                     346   ; void LCDOutMessage(char *theMessage)
                     347   ; {
                     348          xdef      _LCDOutMessage
                     349   _LCDOutMessage:
0000016A  4E56 FFFC  350          link      A6,#-4
                     351   ; char c ;
                     352   ; while((c = *theMessage++) != 0)     // output characters from the string until NULL
                     353   LCDOutMessage_1:
0000016E  206E 0008  354          move.l    8(A6),A0
00000172  52AE 0008  355          addq.l    #1,8(A6)
00000176  1D50 FFFF  356          move.b    (A0),-1(A6)
0000017A  1010       357          move.b    (A0),D0
0000017C  6712       358          beq.s     LCDOutMessage_3
                     359   ; LCDOutchar(c) ;
0000017E  122E FFFF  360          move.b    -1(A6),D1
00000182  4881       361          ext.w     D1
00000184  48C1       362          ext.l     D1
00000186  2F01       363          move.l    D1,-(A7)
00000188  4EB8 0154  364          jsr       _LCDOutchar
0000018C  584F       365          addq.w    #4,A7
0000018E  60DE       366          bra       LCDOutMessage_1
                     367   LCDOutMessage_3:
00000190  4E5E       368          unlk      A6
00000192  4E75       369          rts
                     370   ; }
                     371   ; /******************************************************************************
                     372   ; *subroutine to clear the line by issuing 24 space characters
                     373   ; *******************************************************************************/
                     374   ; void LCDClearln(void)
                     375   ; {
                     376          xdef      _LCDClearln
                     377   _LCDClearln:
00000194  2F02       378          move.l    D2,-(A7)
                     379   ; int i ;
                     380   ; for(i = 0; i < 24; i ++)
00000196  4282       381          clr.l     D2
                     382   LCDClearln_1:
00000198  0C82 0000  383          cmp.l     #24,D2
0000019C  0018      
0000019E  6C0E       384          bge.s     LCDClearln_3
                     385   ; LCDOutchar(' ') ;       // write a space char to the LCD display
000001A0  4878 0020  386          pea       32
000001A4  4EB8 0154  387          jsr       _LCDOutchar
000001A8  584F       388          addq.w    #4,A7
000001AA  5282       389          addq.l    #1,D2
000001AC  60EA       390          bra       LCDClearln_1
                     391   LCDClearln_3:
000001AE  241F       392          move.l    (A7)+,D2
000001B0  4E75       393          rts
                     394   ; }
                     395   ; /******************************************************************************
                     396   ; **  Subroutine to move the LCD cursor to the start of line 1 and clear that line
                     397   ; *******************************************************************************/
                     398   ; void LCDLine1Message(char *theMessage)
                     399   ; {
                     400          xdef      _LCDLine1Message
                     401   _LCDLine1Message:
000001B2  4E56 0000  402          link      A6,#0
                     403   ; LCDcommand = 0x80 ;
000001B6  13FC 0080  404          move.b    #128,4194336
000001BA  0040 0020 
                     405   ; Wait3ms();
000001BE  4EB8 00B6  406          jsr       _Wait3ms
                     407   ; LCDClearln() ;
000001C2  4EB8 0194  408          jsr       _LCDClearln
                     409   ; LCDcommand = 0x80 ;
000001C6  13FC 0080  410          move.b    #128,4194336
000001CA  0040 0020 
                     411   ; Wait3ms() ;
000001CE  4EB8 00B6  412          jsr       _Wait3ms
                     413   ; LCDOutMessage(theMessage) ;
000001D2  2F2E 0008  414          move.l    8(A6),-(A7)
000001D6  4EB8 016A  415          jsr       _LCDOutMessage
000001DA  584F       416          addq.w    #4,A7
000001DC  4E5E       417          unlk      A6
000001DE  4E75       418          rts
                     419   ; }
                     420   ; /******************************************************************************
                     421   ; **  Subroutine to move the LCD cursor to the start of line 2 and clear that line
                     422   ; *******************************************************************************/
                     423   ; void LCDLine2Message(char *theMessage)
                     424   ; {
                     425          xdef      _LCDLine2Message
                     426   _LCDLine2Message:
000001E0  4E56 0000  427          link      A6,#0
                     428   ; LCDcommand = 0xC0 ;
000001E4  13FC 00C0  429          move.b    #192,4194336
000001E8  0040 0020 
                     430   ; Wait3ms();
000001EC  4EB8 00B6  431          jsr       _Wait3ms
                     432   ; LCDClearln() ;
000001F0  4EB8 0194  433          jsr       _LCDClearln
                     434   ; LCDcommand = 0xC0 ;
000001F4  13FC 00C0  435          move.b    #192,4194336
000001F8  0040 0020 
                     436   ; Wait3ms() ;
000001FC  4EB8 00B6  437          jsr       _Wait3ms
                     438   ; LCDOutMessage(theMessage) ;
00000200  2F2E 0008  439          move.l    8(A6),-(A7)
00000204  4EB8 016A  440          jsr       _LCDOutMessage
00000208  584F       441          addq.w    #4,A7
0000020A  4E5E       442          unlk      A6
0000020C  4E75       443          rts
                     444   ; }
                     445   ; /*********************************************************************************************************************************
                     446   ; **  IMPORTANT FUNCTION
                     447   ; **  This function install an exception handler so you can capture and deal with any 68000 exception in your program
                     448   ; **  You pass it the name of a function in your code that will get called in response to the exception (as the 1st parameter)
                     449   ; **  and in the 2nd parameter, you pass it the exception number that you want to take over (see 68000 exceptions for details)
                     450   ; **  Calling this function allows you to deal with Interrupts for example
                     451   ; ***********************************************************************************************************************************/
                     452   ; void InstallExceptionHandler( void (*function_ptr)(), int level)
                     453   ; {
                     454          xdef      _InstallExceptionHandler
                     455   _InstallExceptionHandler:
0000020E  4E56 FFFC  456          link      A6,#-4
                     457   ; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
00000212  2D7C 0B00  458          move.l    #184549376,-4(A6)
00000216  0000 FFFC 
                     459   ; RamVectorAddress[level] = (long int *)(function_ptr);                       // install the address of our function into the exception table
0000021A  206E FFFC  460          move.l    -4(A6),A0
0000021E  202E 000C  461          move.l    12(A6),D0
00000222  E588       462          lsl.l     #2,D0
00000224  21AE 0008  463          move.l    8(A6),0(A0,D0.L)
00000228  0800      
0000022A  4E5E       464          unlk      A6
0000022C  4E75       465          rts
                     466   ; }
                     467   ; /******************************************************************************************************************************
                     468   ; * Start of user program
                     469   ; ******************************************************************************************************************************/
                     470   ; void main()
                     471   ; {
                     472          xdef      _main
                     473   _main:
0000022E  4E56 FF54  474          link      A6,#-172
00000232  48E7 0030  475          movem.l   A2/A3,-(A7)
00000236  45F8 020E  476          lea       _InstallExceptionHandler.L,A2
                     477          lea       _printf.L,A3
********  **** ****  Error: Undefined or illegal symbol
                     478   ; unsigned int row, i=0, count=0, counter1=1;
00000240  42AE FF58  479          clr.l     -168(A6)
00000244  42AE FF5C  480          clr.l     -164(A6)
00000248  2D7C 0000  481          move.l    #1,-160(A6)
0000024C  0001 FF60 
                     482   ; char c, text[150] ;
                     483   ; int PassFailFlag = 1 ;
00000250  2D7C 0000  484          move.l    #1,-4(A6)
00000254  0001 FFFC 
                     485   ; i = x = y = z = PortA_Count =0;
00000258  42B9 0000  486          clr.l     _PortA_Count.L
0000025C  0418      
0000025E  42B9 0000  487          clr.l     _z.L
00000262  0414      
00000264  42B9 0000  488          clr.l     _y.L
00000268  0410      
0000026A  42B9 0000  489          clr.l     _x.L
0000026E  040C      
00000270  42AE FF58  490          clr.l     -168(A6)
                     491   ; Timer1Count = Timer2Count = Timer3Count = Timer4Count = 0;
00000274  4239 0000  492          clr.b     _Timer4Count.L
00000278  0422      
0000027A  4239 0000  493          clr.b     _Timer3Count.L
0000027E  0420      
00000280  4239 0000  494          clr.b     _Timer2Count.L
00000284  041E      
00000286  4239 0000  495          clr.b     _Timer1Count.L
0000028A  041C      
                     496   ; InstallExceptionHandler(PIA_ISR, 25) ;          // install interrupt handler for PIAs 1 and 2 on level 1 IRQ
0000028C  4878 0019  497          pea       25
00000290  4878 009C  498          pea       _PIA_ISR.L
00000294  4E92       499          jsr       (A2)
00000296  504F       500          addq.w    #8,A7
                     501   ; InstallExceptionHandler(ACIA_ISR, 26) ;		    // install interrupt handler for ACIA on level 2 IRQ
00000298  4878 001A  502          pea       26
0000029C  4878 009A  503          pea       _ACIA_ISR.L
000002A0  4E92       504          jsr       (A2)
000002A2  504F       505          addq.w    #8,A7
                     506   ; InstallExceptionHandler(Timer_ISR, 27) ;		// install interrupt handler for Timers 1-4 on level 3 IRQ
000002A4  4878 001B  507          pea       27
000002A8  4878 0000  508          pea       _Timer_ISR.L
000002AC  4E92       509          jsr       (A2)
000002AE  504F       510          addq.w    #8,A7
                     511   ; InstallExceptionHandler(Key2PressISR, 28) ;	    // install interrupt handler for Key Press 2 on DE1 board for level 4 IRQ
000002B0  4878 001C  512          pea       28
000002B4  4878 009E  513          pea       _Key2PressISR.L
000002B8  4E92       514          jsr       (A2)
000002BA  504F       515          addq.w    #8,A7
                     516   ; InstallExceptionHandler(Key1PressISR, 29) ;	    // install interrupt handler for Key Press 1 on DE1 board for level 5 IRQ
000002BC  4878 001D  517          pea       29
000002C0  4878 00A0  518          pea       _Key1PressISR.L
000002C4  4E92       519          jsr       (A2)
000002C6  504F       520          addq.w    #8,A7
                     521   ; Timer1Data = 0x10;		// program time delay into timers 1-4
000002C8  13FC 0010  522          move.b    #16,4194352
000002CC  0040 0030 
                     523   ; Timer2Data = 0x20;
000002D0  13FC 0020  524          move.b    #32,4194356
000002D4  0040 0034 
                     525   ; Timer3Data = 0x15;
000002D8  13FC 0015  526          move.b    #21,4194360
000002DC  0040 0038 
                     527   ; Timer4Data = 0x25;
000002E0  13FC 0025  528          move.b    #37,4194364
000002E4  0040 003C 
                     529   ; Timer1Control = 3;		// write 3 to control register to Bit0 = 1 (enable interrupt from timers) 1 - 4 and allow them to count Bit 1 = 1
000002E8  13FC 0003  530          move.b    #3,4194354
000002EC  0040 0032 
                     531   ; Timer2Control = 3;
000002F0  13FC 0003  532          move.b    #3,4194358
000002F4  0040 0036 
                     533   ; Timer3Control = 3;
000002F8  13FC 0003  534          move.b    #3,4194362
000002FC  0040 003A 
                     535   ; Timer4Control = 3;
00000300  13FC 0003  536          move.b    #3,4194366
00000304  0040 003E 
                     537   ; Init_LCD();             // initialise the LCD display to use a parallel data interface and 2 lines of display
00000308  4EB8 00CE  538          jsr       _Init_LCD
                     539   ; Init_RS232() ;          // initialise the RS232 port for use with hyper terminal
0000030C  4EB8 00E8  540          jsr       _Init_RS232
                     541   ; /*************************************************************************************************
                     542   ; **  Test of scanf function
                     543   ; *************************************************************************************************/
                     544   ; scanflush() ;                       // flush any text that may have been typed ahead
                     545          jsr       _scanflush
********  **** ****  Error: Undefined or illegal symbol
                     546   ; printf("\r\nEnter Integer: ") ;
00000316  4879 0000  547          pea       @m68kus~1_1.L
0000031A  0372      
0000031C  4E93       548          jsr       (A3)
0000031E  584F       549          addq.w    #4,A7
                     550   ; scanf("%d", &i) ;
00000320  486E FF58  551          pea       -168(A6)
00000324  4879 0000  552          pea       @m68kus~1_2.L
00000328  0384      
                     553          jsr       _scanf
********  **** ****  Error: Undefined or illegal symbol
00000330  504F       554          addq.w    #8,A7
                     555   ; printf("You entered %d", i) ;
00000332  2F2E FF58  556          move.l    -168(A6),-(A7)
00000336  4879 0000  557          pea       @m68kus~1_3.L
0000033A  0388      
0000033C  4E93       558          jsr       (A3)
0000033E  504F       559          addq.w    #8,A7
                     560   ; sprintf(text, "Hello CPEN 412 Student") ;
00000340  4879 0000  561          pea       @m68kus~1_4.L
00000344  0398      
00000346  486E FF66  562          pea       -154(A6)
                     563          jsr       _sprintf
********  **** ****  Error: Undefined or illegal symbol
00000350  504F       564          addq.w    #8,A7
                     565   ; LCDLine1Message(text) ;
00000352  486E FF66  566          pea       -154(A6)
00000356  4EB8 01B2  567          jsr       _LCDLine1Message
0000035A  584F       568          addq.w    #4,A7
                     569   ; printf("\r\nHello CPEN 412 Student\r\nYour LEDs should be Flashing") ;
0000035C  4879 0000  570          pea       @m68kus~1_5.L
00000360  03B0      
00000362  4E93       571          jsr       (A3)
00000364  584F       572          addq.w    #4,A7
                     573   ; printf("\r\nYour LCD should be displaying") ;
00000366  4879 0000  574          pea       @m68kus~1_6.L
0000036A  03E8      
0000036C  4E93       575          jsr       (A3)
0000036E  584F       576          addq.w    #4,A7
                     577   ; while(1)
                     578   main_1:
00000370  60FE       579          bra       main_1
                     580   ; ;
                     581   ; // programs should NOT exit as there is nothing to Exit TO !!!!!!
                     582   ; // There is no OS - just press the reset button to end program and call debug
                     583   ; }
                     584          section   const
                     585   @m68kus~1_1:
00000372  0D0A 456E  586          dc.b      13,10,69,110,116,101,114,32,73,110,116,101,103
00000376  7465 7220 
0000037A  496E 7465 
0000037E  67        
0000037F  6572 3A20  587          dc.b      101,114,58,32,0
00000383  00        
                     588   @m68kus~1_2:
00000384  2564 00    589          dc.b      37,100,0
                     590   @m68kus~1_3:
00000388  596F 7520  591          dc.b      89,111,117,32,101,110,116,101,114,101,100,32
0000038C  656E 7465 
00000390  7265 6420 
00000394  2564 00    592          dc.b      37,100,0
                     593   @m68kus~1_4:
00000398  4865 6C6C  594          dc.b      72,101,108,108,111,32,67,80,69,78,32,52,49,50
0000039C  6F20 4350 
000003A0  454E 2034 
000003A4  3132      
000003A6  2053 7475  595          dc.b      32,83,116,117,100,101,110,116,0
000003AA  6465 6E74 
000003AE  00        
                     596   @m68kus~1_5:
000003B0  0D0A 4865  597          dc.b      13,10,72,101,108,108,111,32,67,80,69,78,32,52
000003B4  6C6C 6F20 
000003B8  4350 454E 
000003BC  2034      
000003BE  3132 2053  598          dc.b      49,50,32,83,116,117,100,101,110,116,13,10,89
000003C2  7475 6465 
000003C6  6E74 0D0A 
000003CA  59        
000003CB  6F75 7220  599          dc.b      111,117,114,32,76,69,68,115,32,115,104,111,117
000003CF  4C45 4473 
000003D3  2073 686F 
000003D7  75        
000003D8  6C64 2062  600          dc.b      108,100,32,98,101,32,70,108,97,115,104,105,110
000003DC  6520 466C 
000003E0  6173 6869 
000003E4  6E        
000003E5  6700       601          dc.b      103,0
                     602   @m68kus~1_6:
000003E8  0D0A 596F  603          dc.b      13,10,89,111,117,114,32,76,67,68,32,115,104
000003EC  7572 204C 
000003F0  4344 2073 
000003F4  68        
000003F5  6F75 6C64  604          dc.b      111,117,108,100,32,98,101,32,100,105,115,112
000003F9  2062 6520 
000003FD  6469 7370 
00000401  6C61 7969  605          dc.b      108,97,121,105,110,103,0
00000405  6E67 00   
                     606          section   bss
                     607          xdef      _i
                     608   _i:
00000408             609          ds.b      4
                     610          xdef      _x
                     611   _x:
0000040C             612          ds.b      4
                     613          xdef      _y
                     614   _y:
00000410             615          ds.b      4
                     616          xdef      _z
                     617   _z:
00000414             618          ds.b      4
                     619          xdef      _PortA_Count
                     620   _PortA_Count:
00000418             621          ds.b      4
                     622          xdef      _Timer1Count
                     623   _Timer1Count:
0000041C             624          ds.b      1
                     625          xdef      _Timer2Count
                     626   _Timer2Count:
0000041E             627          ds.b      1
                     628          xdef      _Timer3Count
                     629   _Timer3Count:
00000420             630          ds.b      1
                     631          xdef      _Timer4Count
                     632   _Timer4Count:
00000422             633          ds.b      1
                     634          xref      _sprintf
                     635          xref      _scanf
                     636          xref      _scanflush
                     637          xref      _printf
          0000 0000

Assembly errors: 4
