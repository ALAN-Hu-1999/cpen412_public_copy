680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 17 Jan 2022      Time: 16:58:46          Source: C:\IDE68K\EXAMPLES\1.SRC

                       1          section   code
                       2   ; C:\M68KV6.0 - 800BY480\PROGRAMS\DEBUGMONITORCODE\M68KUSERPROGRAM (DE1).C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                       3   ; #include <stdio.h>
                       4   ; #include <string.h>
                       5   ; #include <ctype.h>
                       6   ; //IMPORTANT
                       7   ; //
                       8   ; // Uncomment one of the two #defines below
                       9   ; // Define StartOfExceptionVectorTable as 08030000 if running programs from sram or
                      10   ; // 0B000000 for running programs from dram
                      11   ; //
                      12   ; // In your labs, you will initially start by designing a system with SRam and later move to
                      13   ; // Dram, so these constants will need to be changed based on the version of the system you have
                      14   ; // building
                      15   ; //
                      16   ; // The working 68k system SOF file posted on canvas that you can use for your pre-lab
                      17   ; // is based around Dram so #define accordingly before building
                      18   ; //#define StartOfExceptionVectorTable 0x08030000
                      19   ; #define StartOfExceptionVectorTable 0x0B000000
                      20   ; /**********************************************************************************************
                      21   ; **	Parallel port addresses
                      22   ; **********************************************************************************************/
                      23   ; #define PortA   *(volatile unsigned char *)(0x00400000)
                      24   ; #define PortB   *(volatile unsigned char *)(0x00400002)
                      25   ; #define PortC   *(volatile unsigned char *)(0x00400004)
                      26   ; #define PortD   *(volatile unsigned char *)(0x00400006)
                      27   ; #define PortE   *(volatile unsigned char *)(0x00400008)
                      28   ; /*********************************************************************************************
                      29   ; **	Hex 7 seg displays port addresses
                      30   ; *********************************************************************************************/
                      31   ; #define HEX_A        *(volatile unsigned char *)(0x00400010)
                      32   ; #define HEX_B        *(volatile unsigned char *)(0x00400012)
                      33   ; #define HEX_C        *(volatile unsigned char *)(0x00400014)    // de2 only
                      34   ; #define HEX_D        *(volatile unsigned char *)(0x00400016)    // de2 only
                      35   ; /**********************************************************************************************
                      36   ; **	LCD display port addresses
                      37   ; **********************************************************************************************/
                      38   ; #define LCDcommand   *(volatile unsigned char *)(0x00400020)
                      39   ; #define LCDdata      *(volatile unsigned char *)(0x00400022)
                      40   ; /********************************************************************************************
                      41   ; **	Timer Port addresses
                      42   ; *********************************************************************************************/
                      43   ; #define Timer1Data      *(volatile unsigned char *)(0x00400030)
                      44   ; #define Timer1Control   *(volatile unsigned char *)(0x00400032)
                      45   ; #define Timer1Status    *(volatile unsigned char *)(0x00400032)
                      46   ; #define Timer2Data      *(volatile unsigned char *)(0x00400034)
                      47   ; #define Timer2Control   *(volatile unsigned char *)(0x00400036)
                      48   ; #define Timer2Status    *(volatile unsigned char *)(0x00400036)
                      49   ; #define Timer3Data      *(volatile unsigned char *)(0x00400038)
                      50   ; #define Timer3Control   *(volatile unsigned char *)(0x0040003A)
                      51   ; #define Timer3Status    *(volatile unsigned char *)(0x0040003A)
                      52   ; #define Timer4Data      *(volatile unsigned char *)(0x0040003C)
                      53   ; #define Timer4Control   *(volatile unsigned char *)(0x0040003E)
                      54   ; #define Timer4Status    *(volatile unsigned char *)(0x0040003E)
                      55   ; /*********************************************************************************************
                      56   ; **	RS232 port addresses
                      57   ; *********************************************************************************************/
                      58   ; #define RS232_Control     *(volatile unsigned char *)(0x00400040)
                      59   ; #define RS232_Status      *(volatile unsigned char *)(0x00400040)
                      60   ; #define RS232_TxData      *(volatile unsigned char *)(0x00400042)
                      61   ; #define RS232_RxData      *(volatile unsigned char *)(0x00400042)
                      62   ; #define RS232_Baud        *(volatile unsigned char *)(0x00400044)
                      63   ; /*********************************************************************************************
                      64   ; **	PIA 1 and 2 port addresses
                      65   ; *********************************************************************************************/
                      66   ; #define PIA1_PortA_Data     *(volatile unsigned char *)(0x00400050)         // combined data and data direction register share same address
                      67   ; #define PIA1_PortA_Control *(volatile unsigned char *)(0x00400052)
                      68   ; #define PIA1_PortB_Data     *(volatile unsigned char *)(0x00400054)         // combined data and data direction register share same address
                      69   ; #define PIA1_PortB_Control *(volatile unsigned char *)(0x00400056)
                      70   ; #define PIA2_PortA_Data     *(volatile unsigned char *)(0x00400060)         // combined data and data direction register share same address
                      71   ; #define PIA2_PortA_Control *(volatile unsigned char *)(0x00400062)
                      72   ; #define PIA2_PortB_data     *(volatile unsigned char *)(0x00400064)         // combined data and data direction register share same address
                      73   ; #define PIA2_PortB_Control *(volatile unsigned char *)(0x00400066)
                      74   ; /*********************************************************************************************************************************
                      75   ; (( DO NOT initialise global variables here, do it main even if you want 0
                      76   ; (( it's a limitation of the compiler
                      77   ; (( YOU HAVE BEEN WARNED
                      78   ; *********************************************************************************************************************************/
                      79   ; unsigned int i, x, y, z, PortA_Count;
                      80   ; unsigned char Timer1Count, Timer2Count, Timer3Count, Timer4Count ;
                      81   ; /*******************************************************************************************
                      82   ; ** Function Prototypes
                      83   ; *******************************************************************************************/
                      84   ; void Wait1ms(void);
                      85   ; void Wait3ms(void);
                      86   ; void Init_LCD(void) ;
                      87   ; void LCDOutchar(int c);
                      88   ; void LCDOutMess(char *theMessage);
                      89   ; void LCDClearln(void);
                      90   ; void LCDline1Message(char *theMessage);
                      91   ; void LCDline2Message(char *theMessage);
                      92   ; int sprintf(char *out, const char *format, ...) ;
                      93   ; /*****************************************************************************************
                      94   ; **	Interrupt service routine for Timers
                      95   ; **
                      96   ; **  Timers 1 - 4 share a common IRQ on the CPU  so this function uses polling to figure
                      97   ; **  out which timer is producing the interrupt
                      98   ; **
                      99   ; *****************************************************************************************/
                     100   ; void Timer_ISR()
                     101   ; {
                     102   _Timer_ISR:
                     103   ; if(Timer1Status == 1) {         // Did Timer 1 produce the Interrupt?
00000000  1039 0040  104          move.b    4194354,D0
00000004  0032      
00000006  0C00 0001  105          cmp.b     #1,D0
0000000A  661A       106          bne.s     Timer_ISR_1
                     107   ; Timer1Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
0000000C  13FC 0003  108          move.b    #3,4194354
00000010  0040 0032 
                     109   ; PortA = Timer1Count++ ;     // increment an LED count on PortA with each tick of Timer 1
00000014  1039 0000  110          move.b    _Timer1Count.L,D0
00000018  041C      
0000001A  5239 0000  111          addq.b    #1,_Timer1Count.L
0000001E  041C      
00000020  13C0 0040  112          move.b    D0,4194304
00000024  0000      
                     113   Timer_ISR_1:
                     114   ; }
                     115   ; if(Timer2Status == 1) {         // Did Timer 2 produce the Interrupt?
00000026  1039 0040  116          move.b    4194358,D0
0000002A  0036      
0000002C  0C00 0001  117          cmp.b     #1,D0
00000030  661A       118          bne.s     Timer_ISR_3
                     119   ; Timer2Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
00000032  13FC 0003  120          move.b    #3,4194358
00000036  0040 0036 
                     121   ; PortC = Timer2Count++ ;     // increment an LED count on PortC with each tick of Timer 2
0000003A  1039 0000  122          move.b    _Timer2Count.L,D0
0000003E  041E      
00000040  5239 0000  123          addq.b    #1,_Timer2Count.L
00000044  041E      
00000046  13C0 0040  124          move.b    D0,4194308
0000004A  0004      
                     125   Timer_ISR_3:
                     126   ; }
                     127   ; if(Timer3Status == 1) {         // Did Timer 3 produce the Interrupt?
0000004C  1039 0040  128          move.b    4194362,D0
00000050  003A      
00000052  0C00 0001  129          cmp.b     #1,D0
00000056  661A       130          bne.s     Timer_ISR_5
                     131   ; Timer3Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
00000058  13FC 0003  132          move.b    #3,4194362
0000005C  0040 003A 
                     133   ; HEX_A = Timer3Count++ ;     // increment a HEX count on Port HEX_A with each tick of Timer 3
00000060  1039 0000  134          move.b    _Timer3Count.L,D0
00000064  0420      
00000066  5239 0000  135          addq.b    #1,_Timer3Count.L
0000006A  0420      
0000006C  13C0 0040  136          move.b    D0,4194320
00000070  0010      
                     137   Timer_ISR_5:
                     138   ; }
                     139   ; if(Timer4Status == 1) {         // Did Timer 4 produce the Interrupt?
00000072  1039 0040  140          move.b    4194366,D0
00000076  003E      
00000078  0C00 0001  141          cmp.b     #1,D0
0000007C  661A       142          bne.s     Timer_ISR_7
                     143   ; Timer4Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
0000007E  13FC 0003  144          move.b    #3,4194366
00000082  0040 003E 
                     145   ; HEX_B = Timer4Count++ ;     // increment a HEX count on HEX_B with each tick of Timer 4
00000086  1039 0000  146          move.b    _Timer4Count.L,D0
0000008A  0422      
0000008C  5239 0000  147          addq.b    #1,_Timer4Count.L
00000090  0422      
00000092  13C0 0040  148          move.b    D0,4194322
00000096  0012      
                     149   Timer_ISR_7:
00000098  4E75       150          rts
                     151   ; }
                     152   ; }
                     153   ; /*****************************************************************************************
                     154   ; **	Interrupt service routine for ACIA. This device has it's own dedicate IRQ level
                     155   ; **  Add your code here to poll Status register and clear interrupt
                     156   ; *****************************************************************************************/
                     157   ; void ACIA_ISR()
                     158   ; {}
                     159   _ACIA_ISR:
0000009A  4E75       160          rts
                     161   ; /***************************************************************************************
                     162   ; **	Interrupt service routine for PIAs 1 and 2. These devices share an IRQ level
                     163   ; **  Add your code here to poll Status register and clear interrupt
                     164   ; *****************************************************************************************/
                     165   ; void PIA_ISR()
                     166   ; {}
                     167   _PIA_ISR:
0000009C  4E75       168          rts
                     169   ; /***********************************************************************************
                     170   ; **	Interrupt service routine for Key 2 on DE1 board. Add your own response here
                     171   ; ************************************************************************************/
                     172   ; void Key2PressISR()
                     173   ; {}
                     174   _Key2PressISR:
0000009E  4E75       175          rts
                     176   ; /***********************************************************************************
                     177   ; **	Interrupt service routine for Key 1 on DE1 board. Add your own response here
                     178   ; ************************************************************************************/
                     179   ; void Key1PressISR()
                     180   ; {}
                     181   _Key1PressISR:
000000A0  4E75       182          rts
                     183   ; /************************************************************************************
                     184   ; **   Delay Subroutine to give the 68000 something useless to do to waste 1 mSec
                     185   ; ************************************************************************************/
                     186   ; void Wait1ms(void)
                     187   ; {
                     188   _Wait1ms:
000000A2  2F02       189          move.l    D2,-(A7)
                     190   ; int  i ;
                     191   ; for(i = 0; i < 1000; i ++)
000000A4  4282       192          clr.l     D2
                     193   Wait1ms_1:
000000A6  0C82 0000  194          cmp.l     #1000,D2
000000AA  03E8      
000000AC  6C04       195          bge.s     Wait1ms_3
000000AE  5282       196          addq.l    #1,D2
000000B0  60F4       197          bra       Wait1ms_1
                     198   Wait1ms_3:
000000B2  241F       199          move.l    (A7)+,D2
000000B4  4E75       200          rts
                     201   ; ;
                     202   ; }
                     203   ; /************************************************************************************
                     204   ; **  Subroutine to give the 68000 something useless to do to waste 3 mSec
                     205   ; **************************************************************************************/
                     206   ; void Wait3ms(void)
                     207   ; {
                     208   _Wait3ms:
000000B6  2F02       209          move.l    D2,-(A7)
                     210   ; int i ;
                     211   ; for(i = 0; i < 3; i++)
000000B8  4282       212          clr.l     D2
                     213   Wait3ms_1:
000000BA  0C82 0000  214          cmp.l     #3,D2
000000BE  0003      
000000C0  6C08       215          bge.s     Wait3ms_3
                     216   ; Wait1ms() ;
000000C2  4EB8 00A2  217          jsr       _Wait1ms
000000C6  5282       218          addq.l    #1,D2
000000C8  60F0       219          bra       Wait3ms_1
                     220   Wait3ms_3:
000000CA  241F       221          move.l    (A7)+,D2
000000CC  4E75       222          rts
                     223   ; }
                     224   ; /*********************************************************************************************
                     225   ; **  Subroutine to initialise the LCD display by writing some commands to the LCD internal registers
                     226   ; **  Sets it for parallel port and 2 line display mode (if I recall correctly)
                     227   ; *********************************************************************************************/
                     228   ; void Init_LCD(void)
                     229   ; {
                     230   _Init_LCD:
                     231   ; LCDcommand = 0x0c ;
000000CE  13FC 000C  232          move.b    #12,4194336
000000D2  0040 0020 
                     233   ; Wait3ms() ;
000000D6  4EB8 00B6  234          jsr       _Wait3ms
                     235   ; LCDcommand = 0x38 ;
000000DA  13FC 0038  236          move.b    #56,4194336
000000DE  0040 0020 
                     237   ; Wait3ms() ;
000000E2  4EB8 00B6  238          jsr       _Wait3ms
000000E6  4E75       239          rts
                     240   ; }
                     241   ; /*********************************************************************************************
                     242   ; **  Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                     243   ; *********************************************************************************************/
                     244   ; void Init_RS232(void)
                     245   ; {
                     246   _Init_RS232:
                     247   ; RS232_Control = 0x15 ; //  %00010101 set up 6850 uses divide by 16 clock, set RTS low, 8 bits no parity, 1 stop bit, transmitter interrupt disabled
000000E8  13FC 0015  248          move.b    #21,4194368
000000EC  0040 0040 
                     249   ; RS232_Baud = 0x1 ;      // program baud rate generator 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
000000F0  13FC 0001  250          move.b    #1,4194372
000000F4  0040 0044 
000000F8  4E75       251          rts
                     252   ; }
                     253   ; /*********************************************************************************************************
                     254   ; **  Subroutine to provide a low level output function to 6850 ACIA
                     255   ; **  This routine provides the basic functionality to output a single character to the serial Port
                     256   ; **  to allow the board to communicate with HyperTerminal Program
                     257   ; **
                     258   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                     259   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                     260   ; **  call _putch() also
                     261   ; *********************************************************************************************************/
                     262   ; int _putch( int c)
                     263   ; {
                     264   __putch:
000000FA  4E56 0000  265          link      A6,#0
                     266   ; while((RS232_Status & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                     267   _putch_1:
000000FE  1039 0040  268          move.b    4194368,D0
00000102  0040      
00000104  C03C 0002  269          and.b     #2,D0
00000108  0C00 0002  270          cmp.b     #2,D0
0000010C  6702       271          beq.s     _putch_3
0000010E  60EE       272          bra       _putch_1
                     273   _putch_3:
                     274   ; ;
                     275   ; RS232_TxData = (c & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
00000110  202E 0008  276          move.l    8(A6),D0
00000114  C0BC 0000  277          and.l     #127,D0
00000118  007F      
0000011A  13C0 0040  278          move.b    D0,4194370
0000011E  0042      
                     279   ; return c ;                                              // putchar() expects the character to be returned
00000120  202E 0008  280          move.l    8(A6),D0
00000124  4E5E       281          unlk      A6
00000126  4E75       282          rts
                     283   ; }
                     284   ; /*********************************************************************************************************
                     285   ; **  Subroutine to provide a low level input function to 6850 ACIA
                     286   ; **  This routine provides the basic functionality to input a single character from the serial Port
                     287   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                     288   ; **
                     289   ; **  NOTE you do not call this function directly, instead you call the normal getchar() function
                     290   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call getchar() so will
                     291   ; **  call _getch() also
                     292   ; *********************************************************************************************************/
                     293   ; int _getch( void )
                     294   ; {
                     295   __getch:
00000128  4E56 FFFC  296          link      A6,#-4
                     297   ; char c ;
                     298   ; while((RS232_Status & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                     299   _getch_1:
0000012C  1039 0040  300          move.b    4194368,D0
00000130  0040      
00000132  C03C 0001  301          and.b     #1,D0
00000136  0C00 0001  302          cmp.b     #1,D0
0000013A  6702       303          beq.s     _getch_3
0000013C  60EE       304          bra       _getch_1
                     305   _getch_3:
                     306   ; ;
                     307   ; return (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
0000013E  1039 0040  308          move.b    4194370,D0
00000142  0042      
00000144  C0BC 0000  309          and.l     #255,D0
00000148  00FF      
0000014A  C0BC 0000  310          and.l     #127,D0
0000014E  007F      
00000150  4E5E       311          unlk      A6
00000152  4E75       312          rts
                     313   ; }
                     314   ; /******************************************************************************
                     315   ; **  Subroutine to output a single character to the 2 row LCD display
                     316   ; **  It is assumed the character is an ASCII code and it will be displayed at the
                     317   ; **  current cursor position
                     318   ; *******************************************************************************/
                     319   ; void LCDOutchar(int c)
                     320   ; {
                     321   _LCDOutchar:
00000154  4E56 0000  322          link      A6,#0
                     323   ; LCDdata = (char)(c);
00000158  202E 0008  324          move.l    8(A6),D0
0000015C  13C0 0040  325          move.b    D0,4194338
00000160  0022      
                     326   ; Wait1ms() ;
00000162  4EB8 00A2  327          jsr       _Wait1ms
00000166  4E5E       328          unlk      A6
00000168  4E75       329          rts
                     330   ; }
                     331   ; /**********************************************************************************
                     332   ; *subroutine to output a message at the current cursor position of the LCD display
                     333   ; ************************************************************************************/
                     334   ; void LCDOutMessage(char *theMessage)
                     335   ; {
                     336   _LCDOutMessage:
0000016A  4E56 FFFC  337          link      A6,#-4
                     338   ; char c ;
                     339   ; while((c = *theMessage++) != 0)     // output characters from the string until NULL
                     340   LCDOutMessage_1:
0000016E  206E 0008  341          move.l    8(A6),A0
00000172  52AE 0008  342          addq.l    #1,8(A6)
00000176  1D50 FFFF  343          move.b    (A0),-1(A6)
0000017A  1010       344          move.b    (A0),D0
0000017C  6712       345          beq.s     LCDOutMessage_3
                     346   ; LCDOutchar(c) ;
0000017E  122E FFFF  347          move.b    -1(A6),D1
00000182  4881       348          ext.w     D1
00000184  48C1       349          ext.l     D1
00000186  2F01       350          move.l    D1,-(A7)
00000188  4EB8 0154  351          jsr       _LCDOutchar
0000018C  584F       352          addq.w    #4,A7
0000018E  60DE       353          bra       LCDOutMessage_1
                     354   LCDOutMessage_3:
00000190  4E5E       355          unlk      A6
00000192  4E75       356          rts
                     357   ; }
                     358   ; /******************************************************************************
                     359   ; *subroutine to clear the line by issuing 24 space characters
                     360   ; *******************************************************************************/
                     361   ; void LCDClearln(void)
                     362   ; {
                     363   _LCDClearln:
00000194  2F02       364          move.l    D2,-(A7)
                     365   ; int i ;
                     366   ; for(i = 0; i < 24; i ++)
00000196  4282       367          clr.l     D2
                     368   LCDClearln_1:
00000198  0C82 0000  369          cmp.l     #24,D2
0000019C  0018      
0000019E  6C0E       370          bge.s     LCDClearln_3
                     371   ; LCDOutchar(' ') ;       // write a space char to the LCD display
000001A0  4878 0020  372          pea       32
000001A4  4EB8 0154  373          jsr       _LCDOutchar
000001A8  584F       374          addq.w    #4,A7
000001AA  5282       375          addq.l    #1,D2
000001AC  60EA       376          bra       LCDClearln_1
                     377   LCDClearln_3:
000001AE  241F       378          move.l    (A7)+,D2
000001B0  4E75       379          rts
                     380   ; }
                     381   ; /******************************************************************************
                     382   ; **  Subroutine to move the LCD cursor to the start of line 1 and clear that line
                     383   ; *******************************************************************************/
                     384   ; void LCDLine1Message(char *theMessage)
                     385   ; {
                     386   _LCDLine1Message:
000001B2  4E56 0000  387          link      A6,#0
                     388   ; LCDcommand = 0x80 ;
000001B6  13FC 0080  389          move.b    #128,4194336
000001BA  0040 0020 
                     390   ; Wait3ms();
000001BE  4EB8 00B6  391          jsr       _Wait3ms
                     392   ; LCDClearln() ;
000001C2  4EB8 0194  393          jsr       _LCDClearln
                     394   ; LCDcommand = 0x80 ;
000001C6  13FC 0080  395          move.b    #128,4194336
000001CA  0040 0020 
                     396   ; Wait3ms() ;
000001CE  4EB8 00B6  397          jsr       _Wait3ms
                     398   ; LCDOutMessage(theMessage) ;
000001D2  2F2E 0008  399          move.l    8(A6),-(A7)
000001D6  4EB8 016A  400          jsr       _LCDOutMessage
000001DA  584F       401          addq.w    #4,A7
000001DC  4E5E       402          unlk      A6
000001DE  4E75       403          rts
                     404   ; }
                     405   ; /******************************************************************************
                     406   ; **  Subroutine to move the LCD cursor to the start of line 2 and clear that line
                     407   ; *******************************************************************************/
                     408   ; void LCDLine2Message(char *theMessage)
                     409   ; {
                     410   _LCDLine2Message:
000001E0  4E56 0000  411          link      A6,#0
                     412   ; LCDcommand = 0xC0 ;
000001E4  13FC 00C0  413          move.b    #192,4194336
000001E8  0040 0020 
                     414   ; Wait3ms();
000001EC  4EB8 00B6  415          jsr       _Wait3ms
                     416   ; LCDClearln() ;
000001F0  4EB8 0194  417          jsr       _LCDClearln
                     418   ; LCDcommand = 0xC0 ;
000001F4  13FC 00C0  419          move.b    #192,4194336
000001F8  0040 0020 
                     420   ; Wait3ms() ;
000001FC  4EB8 00B6  421          jsr       _Wait3ms
                     422   ; LCDOutMessage(theMessage) ;
00000200  2F2E 0008  423          move.l    8(A6),-(A7)
00000204  4EB8 016A  424          jsr       _LCDOutMessage
00000208  584F       425          addq.w    #4,A7
0000020A  4E5E       426          unlk      A6
0000020C  4E75       427          rts
                     428   ; }
                     429   ; /*********************************************************************************************************************************
                     430   ; **  IMPORTANT FUNCTION
                     431   ; **  This function install an exception handler so you can capture and deal with any 68000 exception in your program
                     432   ; **  You pass it the name of a function in your code that will get called in response to the exception (as the 1st parameter)
                     433   ; **  and in the 2nd parameter, you pass it the exception number that you want to take over (see 68000 exceptions for details)
                     434   ; **  Calling this function allows you to deal with Interrupts for example
                     435   ; ***********************************************************************************************************************************/
                     436   ; void InstallExceptionHandler( void (*function_ptr)(), int level)
                     437   ; {
                     438   _InstallExceptionHandler:
0000020E  4E56 FFFC  439          link      A6,#-4
                     440   ; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
00000212  2D7C 0B00  441          move.l    #184549376,-4(A6)
00000216  0000 FFFC 
                     442   ; RamVectorAddress[level] = (long int *)(function_ptr);                       // install the address of our function into the exception table
0000021A  206E FFFC  443          move.l    -4(A6),A0
0000021E  202E 000C  444          move.l    12(A6),D0
00000222  E588       445          lsl.l     #2,D0
00000224  21AE 0008  446          move.l    8(A6),0(A0,D0.L)
00000228  0800      
0000022A  4E5E       447          unlk      A6
0000022C  4E75       448          rts
                     449   ; }
                     450   ; /******************************************************************************************************************************
                     451   ; * Start of user program
                     452   ; ******************************************************************************************************************************/
                     453   ; void main()
                     454   ; {
                     455   _main:
0000022E  4E56 FF54  456          link      A6,#-172
00000232  48E7 0030  457          movem.l   A2/A3,-(A7)
00000236  45F8 020E  458          lea       _InstallExceptionHandler.L,A2
                     459          lea       _printf.L,A3
********  **** ****  Error: Undefined or illegal symbol
                     460   ; unsigned int row, i=0, count=0, counter1=1;
00000240  42AE FF58  461          clr.l     -168(A6)
00000244  42AE FF5C  462          clr.l     -164(A6)
00000248  2D7C 0000  463          move.l    #1,-160(A6)
0000024C  0001 FF60 
                     464   ; char c, text[150] ;
                     465   ; int PassFailFlag = 1 ;
00000250  2D7C 0000  466          move.l    #1,-4(A6)
00000254  0001 FFFC 
                     467   ; i = x = y = z = PortA_Count =0;
00000258  42B9 0000  468          clr.l     _PortA_Count.L
0000025C  0418      
0000025E  42B9 0000  469          clr.l     _z.L
00000262  0414      
00000264  42B9 0000  470          clr.l     _y.L
00000268  0410      
0000026A  42B9 0000  471          clr.l     _x.L
0000026E  040C      
00000270  42AE FF58  472          clr.l     -168(A6)
                     473   ; Timer1Count = Timer2Count = Timer3Count = Timer4Count = 0;
00000274  4239 0000  474          clr.b     _Timer4Count.L
00000278  0422      
0000027A  4239 0000  475          clr.b     _Timer3Count.L
0000027E  0420      
00000280  4239 0000  476          clr.b     _Timer2Count.L
00000284  041E      
00000286  4239 0000  477          clr.b     _Timer1Count.L
0000028A  041C      
                     478   ; InstallExceptionHandler(PIA_ISR, 25) ;          // install interrupt handler for PIAs 1 and 2 on level 1 IRQ
0000028C  4878 0019  479          pea       25
00000290  4878 009C  480          pea       _PIA_ISR.L
00000294  4E92       481          jsr       (A2)
00000296  504F       482          addq.w    #8,A7
                     483   ; InstallExceptionHandler(ACIA_ISR, 26) ;		    // install interrupt handler for ACIA on level 2 IRQ
00000298  4878 001A  484          pea       26
0000029C  4878 009A  485          pea       _ACIA_ISR.L
000002A0  4E92       486          jsr       (A2)
000002A2  504F       487          addq.w    #8,A7
                     488   ; InstallExceptionHandler(Timer_ISR, 27) ;		// install interrupt handler for Timers 1-4 on level 3 IRQ
000002A4  4878 001B  489          pea       27
000002A8  4878 0000  490          pea       _Timer_ISR.L
000002AC  4E92       491          jsr       (A2)
000002AE  504F       492          addq.w    #8,A7
                     493   ; InstallExceptionHandler(Key2PressISR, 28) ;	    // install interrupt handler for Key Press 2 on DE1 board for level 4 IRQ
000002B0  4878 001C  494          pea       28
000002B4  4878 009E  495          pea       _Key2PressISR.L
000002B8  4E92       496          jsr       (A2)
000002BA  504F       497          addq.w    #8,A7
                     498   ; InstallExceptionHandler(Key1PressISR, 29) ;	    // install interrupt handler for Key Press 1 on DE1 board for level 5 IRQ
000002BC  4878 001D  499          pea       29
000002C0  4878 00A0  500          pea       _Key1PressISR.L
000002C4  4E92       501          jsr       (A2)
000002C6  504F       502          addq.w    #8,A7
                     503   ; Timer1Data = 0x10;		// program time delay into timers 1-4
000002C8  13FC 0010  504          move.b    #16,4194352
000002CC  0040 0030 
                     505   ; Timer2Data = 0x20;
000002D0  13FC 0020  506          move.b    #32,4194356
000002D4  0040 0034 
                     507   ; Timer3Data = 0x15;
000002D8  13FC 0015  508          move.b    #21,4194360
000002DC  0040 0038 
                     509   ; Timer4Data = 0x25;
000002E0  13FC 0025  510          move.b    #37,4194364
000002E4  0040 003C 
                     511   ; Timer1Control = 3;		// write 3 to control register to Bit0 = 1 (enable interrupt from timers) 1 - 4 and allow them to count Bit 1 = 1
000002E8  13FC 0003  512          move.b    #3,4194354
000002EC  0040 0032 
                     513   ; Timer2Control = 3;
000002F0  13FC 0003  514          move.b    #3,4194358
000002F4  0040 0036 
                     515   ; Timer3Control = 3;
000002F8  13FC 0003  516          move.b    #3,4194362
000002FC  0040 003A 
                     517   ; Timer4Control = 3;
00000300  13FC 0003  518          move.b    #3,4194366
00000304  0040 003E 
                     519   ; Init_LCD();             // initialise the LCD display to use a parallel data interface and 2 lines of display
00000308  4EB8 00CE  520          jsr       _Init_LCD
                     521   ; Init_RS232() ;          // initialise the RS232 port for use with hyper terminal
0000030C  4EB8 00E8  522          jsr       _Init_RS232
                     523   ; /*************************************************************************************************
                     524   ; **  Test of scanf function
                     525   ; *************************************************************************************************/
                     526   ; scanflush() ;                       // flush any text that may have been typed ahead
                     527          jsr       _scanflush
********  **** ****  Error: Undefined or illegal symbol
                     528   ; printf("\r\nEnter Integer: ") ;
00000316  4879 0000  529          pea       @m68kus~1_1.L
0000031A  0372      
0000031C  4E93       530          jsr       (A3)
0000031E  584F       531          addq.w    #4,A7
                     532   ; scanf("%d", &i) ;
00000320  486E FF58  533          pea       -168(A6)
00000324  4879 0000  534          pea       @m68kus~1_2.L
00000328  0384      
                     535          jsr       _scanf
********  **** ****  Error: Undefined or illegal symbol
00000330  504F       536          addq.w    #8,A7
                     537   ; printf("You entered %d", i) ;
00000332  2F2E FF58  538          move.l    -168(A6),-(A7)
00000336  4879 0000  539          pea       @m68kus~1_3.L
0000033A  0388      
0000033C  4E93       540          jsr       (A3)
0000033E  504F       541          addq.w    #8,A7
                     542   ; sprintf(text, "Hello CPEN 412 Student") ;
00000340  4879 0000  543          pea       @m68kus~1_4.L
00000344  0398      
00000346  486E FF66  544          pea       -154(A6)
                     545          jsr       _sprintf
********  **** ****  Error: Undefined or illegal symbol
00000350  504F       546          addq.w    #8,A7
                     547   ; LCDLine1Message(text) ;
00000352  486E FF66  548          pea       -154(A6)
00000356  4EB8 01B2  549          jsr       _LCDLine1Message
0000035A  584F       550          addq.w    #4,A7
                     551   ; printf("\r\nHello CPEN 412 Student\r\nYour LEDs should be Flashing") ;
0000035C  4879 0000  552          pea       @m68kus~1_5.L
00000360  03B0      
00000362  4E93       553          jsr       (A3)
00000364  584F       554          addq.w    #4,A7
                     555   ; printf("\r\nYour LCD should be displaying") ;
00000366  4879 0000  556          pea       @m68kus~1_6.L
0000036A  03E8      
0000036C  4E93       557          jsr       (A3)
0000036E  584F       558          addq.w    #4,A7
                     559   ; while(1)
                     560   main_1:
00000370  60FE       561          bra       main_1
                     562   ; ;
                     563   ; // programs should NOT exit as there is nothing to Exit TO !!!!!!
                     564   ; // There is no OS - just press the reset button to end program and call debug
                     565   ; }
                     566          section   const
                     567   @m68kus~1_1:
00000372  0D0A 456E  568          dc.b      13,10,69,110,116,101,114,32,73,110,116,101,103
00000376  7465 7220 
0000037A  496E 7465 
0000037E  67        
0000037F  6572 3A20  569          dc.b      101,114,58,32,0
00000383  00        
                     570   @m68kus~1_2:
00000384  2564 00    571          dc.b      37,100,0
                     572   @m68kus~1_3:
00000388  596F 7520  573          dc.b      89,111,117,32,101,110,116,101,114,101,100,32
0000038C  656E 7465 
00000390  7265 6420 
00000394  2564 00    574          dc.b      37,100,0
                     575   @m68kus~1_4:
00000398  4865 6C6C  576          dc.b      72,101,108,108,111,32,67,80,69,78,32,52,49,50
0000039C  6F20 4350 
000003A0  454E 2034 
000003A4  3132      
000003A6  2053 7475  577          dc.b      32,83,116,117,100,101,110,116,0
000003AA  6465 6E74 
000003AE  00        
                     578   @m68kus~1_5:
000003B0  0D0A 4865  579          dc.b      13,10,72,101,108,108,111,32,67,80,69,78,32,52
000003B4  6C6C 6F20 
000003B8  4350 454E 
000003BC  2034      
000003BE  3132 2053  580          dc.b      49,50,32,83,116,117,100,101,110,116,13,10,89
000003C2  7475 6465 
000003C6  6E74 0D0A 
000003CA  59        
000003CB  6F75 7220  581          dc.b      111,117,114,32,76,69,68,115,32,115,104,111,117
000003CF  4C45 4473 
000003D3  2073 686F 
000003D7  75        
000003D8  6C64 2062  582          dc.b      108,100,32,98,101,32,70,108,97,115,104,105,110
000003DC  6520 466C 
000003E0  6173 6869 
000003E4  6E        
000003E5  6700       583          dc.b      103,0
                     584   @m68kus~1_6:
000003E8  0D0A 596F  585          dc.b      13,10,89,111,117,114,32,76,67,68,32,115,104
000003EC  7572 204C 
000003F0  4344 2073 
000003F4  68        
000003F5  6F75 6C64  586          dc.b      111,117,108,100,32,98,101,32,100,105,115,112
000003F9  2062 6520 
000003FD  6469 7370 
00000401  6C61 7969  587          dc.b      108,97,121,105,110,103,0
00000405  6E67 00   
                     588          section   bss
                     589   _i:
00000408             590          ds.b      4
                     591   _x:
0000040C             592          ds.b      4
                     593   _y:
00000410             594          ds.b      4
                     595   _z:
00000414             596          ds.b      4
                     597   _PortA_Count:
00000418             598          ds.b      4
                     599   _Timer1Count:
0000041C             600          ds.b      1
                     601   _Timer2Count:
0000041E             602          ds.b      1
                     603   _Timer3Count:
00000420             604          ds.b      1
                     605   _Timer4Count:
00000422             606          ds.b      1
          0000 0000

Assembly errors: 4
